/*
 * Copyright (C) 2015 The Gravitee team (http://gravitee.io)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* Gravitee.io - Access Management API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/* tslint:disable */
/* eslint-disable */

import * as runtime from '../runtime';
import {
  AccessPolicy,
  AccessPolicyFromJSON,
  AccessPolicyToJSON,
  AccessPolicyListItem,
  AccessPolicyListItemFromJSON,
  AccessPolicyListItemToJSON,
  AlertNotifier,
  AlertNotifierFromJSON,
  AlertNotifierToJSON,
  AlertTrigger,
  AlertTriggerFromJSON,
  AlertTriggerToJSON,
  AnalyticsTypeParam,
  AnalyticsTypeParamFromJSON,
  AnalyticsTypeParamToJSON,
  Application,
  ApplicationFromJSON,
  ApplicationToJSON,
  ApplicationPage,
  ApplicationPageFromJSON,
  ApplicationPageToJSON,
  AssignPasswordPolicy,
  AssignPasswordPolicyFromJSON,
  AssignPasswordPolicyToJSON,
  Audit,
  AuditFromJSON,
  AuditToJSON,
  AuthenticationDeviceNotifier,
  AuthenticationDeviceNotifierFromJSON,
  AuthenticationDeviceNotifierToJSON,
  AuthorizationEngine,
  AuthorizationEngineFromJSON,
  AuthorizationEngineToJSON,
  BotDetection,
  BotDetectionFromJSON,
  BotDetectionToJSON,
  BulkResponse,
  BulkResponseFromJSON,
  BulkResponseToJSON,
  CertificateEntity,
  CertificateEntityFromJSON,
  CertificateEntityToJSON,
  CertificateKey,
  CertificateKeyFromJSON,
  CertificateKeyToJSON,
  ClientSecret,
  ClientSecretFromJSON,
  ClientSecretToJSON,
  Credential,
  CredentialFromJSON,
  CredentialToJSON,
  DeviceIdentifier,
  DeviceIdentifierFromJSON,
  DeviceIdentifierToJSON,
  Domain,
  DomainFromJSON,
  DomainToJSON,
  DomainPage,
  DomainPageFromJSON,
  DomainPageToJSON,
  DomainUserBulkRequest,
  DomainUserBulkRequestFromJSON,
  DomainUserBulkRequestToJSON,
  Email,
  EmailFromJSON,
  EmailToJSON,
  EnrolledFactorEntity,
  EnrolledFactorEntityFromJSON,
  EnrolledFactorEntityToJSON,
  Entrypoint,
  EntrypointFromJSON,
  EntrypointToJSON,
  ExtensionGrant,
  ExtensionGrantFromJSON,
  ExtensionGrantToJSON,
  Factor,
  FactorFromJSON,
  FactorToJSON,
  FilteredIdentityProviderInfo,
  FilteredIdentityProviderInfoFromJSON,
  FilteredIdentityProviderInfoToJSON,
  Flow,
  FlowFromJSON,
  FlowToJSON,
  FlowEntity,
  FlowEntityFromJSON,
  FlowEntityToJSON,
  Form,
  FormFromJSON,
  FormToJSON,
  Group,
  GroupFromJSON,
  GroupToJSON,
  GroupPage,
  GroupPageFromJSON,
  GroupPageToJSON,
  I18nDictionary,
  I18nDictionaryFromJSON,
  I18nDictionaryToJSON,
  IdentityProvider,
  IdentityProviderFromJSON,
  IdentityProviderToJSON,
  MembershipListItem,
  MembershipListItemFromJSON,
  MembershipListItemToJSON,
  ModifiedCertificateEntity,
  ModifiedCertificateEntityFromJSON,
  ModifiedCertificateEntityToJSON,
  NewAlertNotifier,
  NewAlertNotifierFromJSON,
  NewAlertNotifierToJSON,
  NewApplication,
  NewApplicationFromJSON,
  NewApplicationToJSON,
  NewAuthenticationDeviceNotifier,
  NewAuthenticationDeviceNotifierFromJSON,
  NewAuthenticationDeviceNotifierToJSON,
  NewAuthorizationEngine,
  NewAuthorizationEngineFromJSON,
  NewAuthorizationEngineToJSON,
  NewBotDetection,
  NewBotDetectionFromJSON,
  NewBotDetectionToJSON,
  NewCertificate,
  NewCertificateFromJSON,
  NewCertificateToJSON,
  NewClientSecret,
  NewClientSecretFromJSON,
  NewClientSecretToJSON,
  NewDeviceIdentifier,
  NewDeviceIdentifierFromJSON,
  NewDeviceIdentifierToJSON,
  NewDictionary,
  NewDictionaryFromJSON,
  NewDictionaryToJSON,
  NewDomain,
  NewDomainFromJSON,
  NewDomainToJSON,
  NewEmail,
  NewEmailFromJSON,
  NewEmailToJSON,
  NewExtensionGrant,
  NewExtensionGrantFromJSON,
  NewExtensionGrantToJSON,
  NewFactor,
  NewFactorFromJSON,
  NewFactorToJSON,
  NewForm,
  NewFormFromJSON,
  NewFormToJSON,
  NewGroup,
  NewGroupFromJSON,
  NewGroupToJSON,
  NewIdentityProvider,
  NewIdentityProviderFromJSON,
  NewIdentityProviderToJSON,
  NewMembership,
  NewMembershipFromJSON,
  NewMembershipToJSON,
  NewPasswordPolicy,
  NewPasswordPolicyFromJSON,
  NewPasswordPolicyToJSON,
  NewProtectedResource,
  NewProtectedResourceFromJSON,
  NewProtectedResourceToJSON,
  NewReporter,
  NewReporterFromJSON,
  NewReporterToJSON,
  NewRole,
  NewRoleFromJSON,
  NewRoleToJSON,
  NewScope,
  NewScopeFromJSON,
  NewScopeToJSON,
  NewServiceResource,
  NewServiceResourceFromJSON,
  NewServiceResourceToJSON,
  NewTheme,
  NewThemeFromJSON,
  NewThemeToJSON,
  NewUser,
  NewUserFromJSON,
  NewUserToJSON,
  PasswordPolicy,
  PasswordPolicyFromJSON,
  PasswordPolicyToJSON,
  PasswordPolicyEntity,
  PasswordPolicyEntityFromJSON,
  PasswordPolicyEntityToJSON,
  PasswordValue,
  PasswordValueFromJSON,
  PasswordValueToJSON,
  PatchAlertNotifier,
  PatchAlertNotifierFromJSON,
  PatchAlertNotifierToJSON,
  PatchAlertTrigger,
  PatchAlertTriggerFromJSON,
  PatchAlertTriggerToJSON,
  PatchApplication,
  PatchApplicationFromJSON,
  PatchApplicationToJSON,
  PatchApplicationType,
  PatchApplicationTypeFromJSON,
  PatchApplicationTypeToJSON,
  PatchDomain,
  PatchDomainFromJSON,
  PatchDomainToJSON,
  PatchScope,
  PatchScopeFromJSON,
  PatchScopeToJSON,
  PreviewRequest,
  PreviewRequestFromJSON,
  PreviewRequestToJSON,
  PreviewResponse,
  PreviewResponseFromJSON,
  PreviewResponseToJSON,
  ProtectedResource,
  ProtectedResourceFromJSON,
  ProtectedResourceToJSON,
  ProtectedResourcePage,
  ProtectedResourcePageFromJSON,
  ProtectedResourcePageToJSON,
  ProtectedResourcePrimaryData,
  ProtectedResourcePrimaryDataFromJSON,
  ProtectedResourcePrimaryDataToJSON,
  ProtectedResourceSecret,
  ProtectedResourceSecretFromJSON,
  ProtectedResourceSecretToJSON,
  Reporter,
  ReporterFromJSON,
  ReporterToJSON,
  Resource,
  ResourceFromJSON,
  ResourceToJSON,
  ResourceListItem,
  ResourceListItemFromJSON,
  ResourceListItemToJSON,
  Role,
  RoleFromJSON,
  RoleToJSON,
  RoleEntity,
  RoleEntityFromJSON,
  RoleEntityToJSON,
  RolePage,
  RolePageFromJSON,
  RolePageToJSON,
  Scope,
  ScopeFromJSON,
  ScopeToJSON,
  ScopeApprovalEntity,
  ScopeApprovalEntityFromJSON,
  ScopeApprovalEntityToJSON,
  ScopePage,
  ScopePageFromJSON,
  ScopePageToJSON,
  ServiceResource,
  ServiceResourceFromJSON,
  ServiceResourceToJSON,
  StatusEntity,
  StatusEntityFromJSON,
  StatusEntityToJSON,
  ThemeEntity,
  ThemeEntityFromJSON,
  ThemeEntityToJSON,
  UpdateAuthenticationDeviceNotifier,
  UpdateAuthenticationDeviceNotifierFromJSON,
  UpdateAuthenticationDeviceNotifierToJSON,
  UpdateAuthorizationEngine,
  UpdateAuthorizationEngineFromJSON,
  UpdateAuthorizationEngineToJSON,
  UpdateBotDetection,
  UpdateBotDetectionFromJSON,
  UpdateBotDetectionToJSON,
  UpdateCertificate,
  UpdateCertificateFromJSON,
  UpdateCertificateToJSON,
  UpdateDeviceIdentifier,
  UpdateDeviceIdentifierFromJSON,
  UpdateDeviceIdentifierToJSON,
  UpdateEmail,
  UpdateEmailFromJSON,
  UpdateEmailToJSON,
  UpdateExtensionGrant,
  UpdateExtensionGrantFromJSON,
  UpdateExtensionGrantToJSON,
  UpdateFactor,
  UpdateFactorFromJSON,
  UpdateFactorToJSON,
  UpdateForm,
  UpdateFormFromJSON,
  UpdateFormToJSON,
  UpdateGroup,
  UpdateGroupFromJSON,
  UpdateGroupToJSON,
  UpdateI18nDictionary,
  UpdateI18nDictionaryFromJSON,
  UpdateI18nDictionaryToJSON,
  UpdateIdentityProvider,
  UpdateIdentityProviderFromJSON,
  UpdateIdentityProviderToJSON,
  UpdatePasswordPolicy,
  UpdatePasswordPolicyFromJSON,
  UpdatePasswordPolicyToJSON,
  UpdateProtectedResource,
  UpdateProtectedResourceFromJSON,
  UpdateProtectedResourceToJSON,
  UpdateReporter,
  UpdateReporterFromJSON,
  UpdateReporterToJSON,
  UpdateRole,
  UpdateRoleFromJSON,
  UpdateRoleToJSON,
  UpdateScope,
  UpdateScopeFromJSON,
  UpdateScopeToJSON,
  UpdateServiceResource,
  UpdateServiceResourceFromJSON,
  UpdateServiceResourceToJSON,
  UpdateUser,
  UpdateUserFromJSON,
  UpdateUserToJSON,
  User,
  UserFromJSON,
  UserToJSON,
  UserEntity,
  UserEntityFromJSON,
  UserEntityToJSON,
  UserIdentityEntity,
  UserIdentityEntityFromJSON,
  UserIdentityEntityToJSON,
  UserPage,
  UserPageFromJSON,
  UserPageToJSON,
  UsernameEntity,
  UsernameEntityFromJSON,
  UsernameEntityToJSON,
} from '../models';

export interface AddGroupMemberRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  group: string;
  member: string;
}

export interface AddOrUpdateMemberRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  newMembership: NewMembership;
}

export interface AddOrUpdateMember1Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  newMembership: NewMembership;
}

export interface AssignPasswordPolicyToIdpRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  identity: string;
  assignPasswordPolicy: AssignPasswordPolicy;
}

export interface AssignRolesRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  group: string;
  requestBody: Array<string>;
}

export interface AssignRolesToUserRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  requestBody: Array<string>;
}

export interface BulkUserOperationRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  domainUserBulkRequest: DomainUserBulkRequest;
}

export interface CreateAlertNotifierRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  newAlertNotifier: NewAlertNotifier;
}

export interface CreateApplicationRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  newApplication: NewApplication;
}

export interface CreateApplicationEmailRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  newEmail: NewEmail;
}

export interface CreateApplicationFormRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  newForm: NewForm;
}

export interface CreateAuthenticationDeviceNotifierRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  newAuthenticationDeviceNotifier: NewAuthenticationDeviceNotifier;
}

export interface CreateAuthorizationEngineRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  newAuthorizationEngine: NewAuthorizationEngine;
}

export interface CreateBotDetectionRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  newBotDetection: NewBotDetection;
}

export interface CreateCertificateRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  newCertificate: NewCertificate;
}

export interface CreateDeviceIdentifierRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  newDeviceIdentifier: NewDeviceIdentifier;
}

export interface CreateDomainRequest {
  organizationId: string;
  environmentId: string;
  newDomain: NewDomain;
}

export interface CreateDomainReporterRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  newReporter?: NewReporter;
}

export interface CreateEmailRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  newEmail: NewEmail;
}

export interface CreateExtensionGrantRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  newExtensionGrant: NewExtensionGrant;
}

export interface CreateFactorRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  newFactor: NewFactor;
}

export interface CreateFormRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  newForm: NewForm;
}

export interface CreateGroupRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  newGroup: NewGroup;
}

export interface CreateI18nDictionaryRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  newDictionary: NewDictionary;
}

export interface CreateIdentityProviderRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  newIdentityProvider: NewIdentityProvider;
}

export interface CreatePasswordPolicyRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  newPasswordPolicy: NewPasswordPolicy;
}

export interface CreateProtectedResourceRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  newProtectedResource: NewProtectedResource;
}

export interface CreateResourceRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  newServiceResource: NewServiceResource;
}

export interface CreateRoleRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  newRole: NewRole;
}

export interface CreateScopeRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  newScope: NewScope;
}

export interface CreateSecretRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  newClientSecret: NewClientSecret;
}

export interface CreateThemeRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  newTheme: NewTheme;
}

export interface CreateUserRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  newUser: NewUser;
}

export interface DefineAppFlowsRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  flow: Array<Flow>;
}

export interface DefineDomainFlowsRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  flow: Array<Flow>;
}

export interface DeleteAlertNotifierRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  notifierId: string;
}

export interface DeleteApplicationRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
}

export interface DeleteApplicationEmailRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  email: string;
}

export interface DeleteApplicationFormRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  form: string;
}

export interface DeleteAuthenticationDeviceNotifierRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  authDeviceNotifier: string;
}

export interface DeleteAuthorizationEngineRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  engineId: string;
}

export interface DeleteBotDetectionRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  botDetection: string;
}

export interface DeleteCertificateRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  certificate: string;
}

export interface DeleteClientSecretRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  secret: string;
}

export interface DeleteDeviceIdentifierRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  deviceIdentifier: string;
}

export interface DeleteDomainRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
}

export interface DeleteDomainEmailRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  email: string;
}

export interface DeleteDomainFormRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  form: string;
}

export interface DeleteDomainReporterRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  reporter: string;
}

export interface DeleteExtensionGrantRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  extensionGrant: string;
}

export interface DeleteFactorRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  factor: string;
}

export interface DeleteGroupRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  group: string;
}

export interface DeleteI18nDictionaryRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  dictionary: string;
}

export interface DeleteIdentityProviderRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  identity: string;
}

export interface DeletePasswordPolicyRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  policy: string;
}

export interface DeleteResourceRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  resource: string;
}

export interface DeleteRoleRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  role: string;
}

export interface DeleteScopeRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  scope: string;
}

export interface DeleteThemeRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  themeId: string;
}

export interface DeleteUserRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
}

export interface DeleteUserDeviceRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  device: string;
}

export interface DeleteUserFactorRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  factor: string;
}

export interface EvaluatePolicyRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  policy: string;
}

export interface FindApplicationRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
}

export interface FindApplicationEmailRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  template: FindApplicationEmailTemplateEnum;
}

export interface FindApplicationFormRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  template: FindApplicationFormTemplateEnum;
}

export interface FindAuthorizationEngineRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  engineId: string;
}

export interface FindCertificateRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  certificate: string;
}

export interface FindDomainRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
}

export interface FindDomainAnalyticsRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  from?: number;
  to?: number;
  interval?: number;
  size?: number;
  type: AnalyticsTypeParam;
  field?: string;
}

export interface FindDomainByHridRequest {
  organizationId: string;
  environmentId: string;
  hrid: string;
}

export interface FindEmailRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  template: FindEmailTemplateEnum;
}

export interface FindFormRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  template: FindFormTemplateEnum;
}

export interface FindGroupRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  group: string;
}

export interface FindGroupRolesRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  group: string;
}

export interface FindIdentityProviderRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  identity: string;
}

export interface FindProtectedResourceRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  protectedResource: string;
  type?: string;
}

export interface FindRoleRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  role: string;
}

export interface FindRolesRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  page?: number;
  size?: number;
  q?: string;
}

export interface FindScopeRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  scope: string;
}

export interface FindUserRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
}

export interface GetAlertNotifierRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  notifierId: string;
}

export interface GetAppFlowRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  flow: string;
}

export interface GetApplicationAnalyticsRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  from?: number;
  to?: number;
  interval?: number;
  size?: number;
  type: AnalyticsTypeParam;
  field?: string;
}

export interface GetApplicationResourceRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  resource: string;
}

export interface GetApplicationResourcePolicyRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  resource: string;
  policy: string;
}

export interface GetAuthenticationDeviceNotifierRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  authDeviceNotifier: string;
}

export interface GetBotDetectionRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  botDetection: string;
}

export interface GetCertificatePublicKeyRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  certificate: string;
}

export interface GetCertificatePublicKeysRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  certificate: string;
}

export interface GetDeviceIdentifierRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  deviceIdentifier: string;
}

export interface GetDomainAuditRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  audit: string;
}

export interface GetDomainEntrypointsRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
}

export interface GetDomainFlowRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  flow: string;
}

export interface GetDomainReporterRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  reporter: string;
}

export interface GetEffectivePasswordPolicyRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  identity?: string;
}

export interface GetExtensionGrantRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  extensionGrant: string;
}

export interface GetFactorRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  factor: string;
}

export interface GetGroupMembersRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  group: string;
  page?: number;
  size?: number;
}

export interface GetI18nDictionaryRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  dictionary: string;
}

export interface GetMembersRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
}

export interface GetPasswordPolicyRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  policy: string;
}

export interface GetPermissionsRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
}

export interface GetPermissions1Request {
  organizationId: string;
  environmentId: string;
  domain: string;
}

export interface GetResourceRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  resource: string;
}

export interface GetThemeRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  themeId: string;
}

export interface GetUserAuditLogRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  audit: string;
}

export interface GetUserConsentRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  consent: string;
}

export interface GetUserCredentialRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  credential: string;
}

export interface ListAlertNotifiersRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
}

export interface ListAlertTriggersRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
}

export interface ListAppFlowsRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
}

export interface ListApplicationPoliciesRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  resource: string;
}

export interface ListApplicationResourcesRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  page?: number;
  size?: number;
}

export interface ListApplicationsRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  page?: number;
  size?: number;
  q?: string;
}

export interface ListAuthenticationDeviceNotifiersRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
}

export interface ListAuthorizationEnginesRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
}

export interface ListBotDetectionsRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
}

export interface ListCertificatesRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  use?: string;
}

export interface ListDeviceIdentifiersRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
}

export interface ListDomainAuditsRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  type?: string;
  status?: string;
  user?: string;
  from?: number;
  to?: number;
  size?: number;
  page?: number;
}

export interface ListDomainFlowsRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
}

export interface ListDomainReportersRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  userProvider?: boolean;
}

export interface ListDomainsRequest {
  organizationId: string;
  environmentId: string;
  page?: number;
  size?: number;
  q?: string;
}

export interface ListExtensionGrantsRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
}

export interface ListFactorsRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
}

export interface ListGroupsRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  page?: number;
  size?: number;
}

export interface ListI18nDictionariesRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
}

export interface ListIdentityProvidersRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  userProvider?: boolean;
}

export interface ListMembersRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
}

export interface ListPasswordPoliciesRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
}

export interface ListProtectedResourcesRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  type?: string;
  page?: number;
  size?: number;
  sort?: string;
}

export interface ListResourcesRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
}

export interface ListScopesRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  page?: number;
  size?: number;
  q?: string;
}

export interface ListSecretsRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
}

export interface ListThemesRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
}

export interface ListUserAuditLogsRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  type?: string;
  status?: string;
  from?: number;
  to?: number;
  size?: number;
  page?: number;
}

export interface ListUserConsentsRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  clientId?: string;
}

export interface ListUserCredentialsRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
}

export interface ListUserDevicesRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
}

export interface ListUserEnrolledFactorsRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
}

export interface ListUserIdentitiesRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
}

export interface ListUserRolesRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  dynamic?: boolean;
}

export interface ListUsersRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  q?: string;
  filter?: string;
  page?: number;
  size?: number;
}

export interface LockUserRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
}

export interface PatchAlertNotifierRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  notifierId: string;
  patchAlertNotifier: PatchAlertNotifier;
}

export interface PatchApplicationRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  patchApplication: PatchApplication;
}

export interface PatchDomainRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  patchDomain: PatchDomain;
}

export interface PatchScopeRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  scope: string;
  patchScope: PatchScope;
}

export interface PutI18nDictionaryRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  dictionary: string;
  updateI18nDictionary: UpdateI18nDictionary;
}

export interface RemoveApplicationMemberRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  member: string;
}

export interface RemoveGroupMemberRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  group: string;
  member: string;
}

export interface RemoveMemberRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  member: string;
}

export interface RenderDomainTemplateRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  previewRequest: PreviewRequest;
}

export interface RenewClientSecretRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  secret: string;
}

export interface ReplaceI18nDictionaryEntriesRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  dictionary: string;
  requestBody: { [key: string]: string };
}

export interface ResetPasswordRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  passwordValue: PasswordValue;
}

export interface RevokeRoleRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  group: string;
  role: string;
}

export interface RevokeUserConsentRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  consent: string;
}

export interface RevokeUserConsentsRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  clientId?: string;
}

export interface RevokeUserCredentialRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  credential: string;
}

export interface RevokeUserRoleRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  role: string;
}

export interface RotateCertificateRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
}

export interface SendRegistrationConfirmationRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
}

export interface SetDefaultPolicyRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  policy: string;
}

export interface UnlinkUserIdentityRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  identity: string;
}

export interface UnlockUserRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
}

export interface UpdateAlertTriggersRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  patchAlertTrigger: Array<PatchAlertTrigger>;
}

export interface UpdateAppFlowRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  flow: string;
  flow2: Flow;
}

export interface UpdateApplicationRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  patchApplication: PatchApplication;
}

export interface UpdateApplicationEmailRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  email: string;
  updateEmail: UpdateEmail;
}

export interface UpdateApplicationFormRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  form: string;
  updateForm: UpdateForm;
}

export interface UpdateApplicationTypeRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  patchApplicationType: PatchApplicationType;
}

export interface UpdateAuthenticationDeviceNotifierRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  authDeviceNotifier: string;
  updateAuthenticationDeviceNotifier: UpdateAuthenticationDeviceNotifier;
}

export interface UpdateAuthorizationEngineRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  engineId: string;
  updateAuthorizationEngine: UpdateAuthorizationEngine;
}

export interface UpdateBotDetectionRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  botDetection: string;
  updateBotDetection: UpdateBotDetection;
}

export interface UpdateCertificateRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  certificate: string;
  updateCertificate: UpdateCertificate;
}

export interface UpdateDeviceIdentifierRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  deviceIdentifier: string;
  updateDeviceIdentifier: UpdateDeviceIdentifier;
}

export interface UpdateDomainRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  patchDomain: PatchDomain;
}

export interface UpdateDomainEmailRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  email: string;
  updateEmail: UpdateEmail;
}

export interface UpdateDomainFlowRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  flow: string;
  flow2: Flow;
}

export interface UpdateDomainFormRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  form: string;
  updateForm: UpdateForm;
}

export interface UpdateDomainReporterRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  reporter: string;
  updateReporter: UpdateReporter;
}

export interface UpdateExtensionGrantRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  extensionGrant: string;
  updateExtensionGrant: UpdateExtensionGrant;
}

export interface UpdateFactorRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  factor: string;
  updateFactor: UpdateFactor;
}

export interface UpdateGroupRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  group: string;
  updateGroup: UpdateGroup;
}

export interface UpdateIdentityProviderRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  identity: string;
  updateIdentityProvider: UpdateIdentityProvider;
}

export interface UpdatePasswordPolicyRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  policy: string;
  updatePasswordPolicy: UpdatePasswordPolicy;
}

export interface UpdateProtectedResourceRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  protectedResource: string;
  updateProtectedResource: UpdateProtectedResource;
}

export interface UpdateResourceRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  resource: string;
  updateServiceResource: UpdateServiceResource;
}

export interface UpdateRoleRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  role: string;
  updateRole: UpdateRole;
}

export interface UpdateScopeRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  scope: string;
  updateScope: UpdateScope;
}

export interface UpdateThemeRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  themeId: string;
  themeEntity: ThemeEntity;
}

export interface UpdateUserRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  updateUser: UpdateUser;
}

export interface UpdateUserStatusRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  statusEntity: StatusEntity;
}

export interface UpdateUsernameRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  usernameEntity: UsernameEntity;
}

/**
 *
 */
export class DomainApi extends runtime.BaseAPI {
  /**
   * User must have the DOMAIN_GROUP[UPDATE] permission on the specified domain or DOMAIN_GROUP[UPDATE] permission on the specified environment or DOMAIN_GROUP[UPDATE] permission on the specified organization
   * Add a group member
   */
  async addGroupMemberRaw(
    requestParameters: AddGroupMemberRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling addGroupMember.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling addGroupMember.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling addGroupMember.',
      );
    }

    if (requestParameters.group === null || requestParameters.group === undefined) {
      throw new runtime.RequiredError(
        'group',
        'Required parameter requestParameters.group was null or undefined when calling addGroupMember.',
      );
    }

    if (requestParameters.member === null || requestParameters.member === undefined) {
      throw new runtime.RequiredError(
        'member',
        'Required parameter requestParameters.member was null or undefined when calling addGroupMember.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/groups/{group}/members/{member}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'group'}}`, encodeURIComponent(String(requestParameters.group)))
          .replace(`{${'member'}}`, encodeURIComponent(String(requestParameters.member))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_GROUP[UPDATE] permission on the specified domain or DOMAIN_GROUP[UPDATE] permission on the specified environment or DOMAIN_GROUP[UPDATE] permission on the specified organization
   * Add a group member
   */
  async addGroupMember(requestParameters: AddGroupMemberRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.addGroupMemberRaw(requestParameters, initOverrides);
  }

  /**
   * User must have APPLICATION_MEMBER[CREATE] permission on the specified application or APPLICATION_MEMBER[CREATE] permission on the specified domain or APPLICATION_MEMBER[CREATE] permission on the specified environment or APPLICATION_MEMBER[CREATE] permission on the specified organization
   * Add or update an application member
   */
  async addOrUpdateMemberRaw(
    requestParameters: AddOrUpdateMemberRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling addOrUpdateMember.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling addOrUpdateMember.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling addOrUpdateMember.',
      );
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling addOrUpdateMember.',
      );
    }

    if (requestParameters.newMembership === null || requestParameters.newMembership === undefined) {
      throw new runtime.RequiredError(
        'newMembership',
        'Required parameter requestParameters.newMembership was null or undefined when calling addOrUpdateMember.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/members`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewMembershipToJSON(requestParameters.newMembership),
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have APPLICATION_MEMBER[CREATE] permission on the specified application or APPLICATION_MEMBER[CREATE] permission on the specified domain or APPLICATION_MEMBER[CREATE] permission on the specified environment or APPLICATION_MEMBER[CREATE] permission on the specified organization
   * Add or update an application member
   */
  async addOrUpdateMember(
    requestParameters: AddOrUpdateMemberRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.addOrUpdateMemberRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_MEMBER[CREATE] permission on the specified domain or DOMAIN_MEMBER[CREATE] permission on the specified environment or DOMAIN_MEMBER[CREATE] permission on the specified organization
   * Add or update an security domain member
   */
  async addOrUpdateMember1Raw(
    requestParameters: AddOrUpdateMember1Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling addOrUpdateMember1.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling addOrUpdateMember1.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling addOrUpdateMember1.',
      );
    }

    if (requestParameters.newMembership === null || requestParameters.newMembership === undefined) {
      throw new runtime.RequiredError(
        'newMembership',
        'Required parameter requestParameters.newMembership was null or undefined when calling addOrUpdateMember1.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/members`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewMembershipToJSON(requestParameters.newMembership),
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_MEMBER[CREATE] permission on the specified domain or DOMAIN_MEMBER[CREATE] permission on the specified environment or DOMAIN_MEMBER[CREATE] permission on the specified organization
   * Add or update an security domain member
   */
  async addOrUpdateMember1(
    requestParameters: AddOrUpdateMember1Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.addOrUpdateMember1Raw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_IDENTITY_PROVIDER[UPDATE] permission on the specified domain or DOMAIN_IDENTITY_PROVIDER[UPDATE] permission on the specified environment or DOMAIN_IDENTITY_PROVIDER[UPDATE] permission on the specified organization
   * Assign password policy to identity provider
   */
  async assignPasswordPolicyToIdpRaw(
    requestParameters: AssignPasswordPolicyToIdpRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<AssignPasswordPolicy>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling assignPasswordPolicyToIdp.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling assignPasswordPolicyToIdp.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling assignPasswordPolicyToIdp.',
      );
    }

    if (requestParameters.identity === null || requestParameters.identity === undefined) {
      throw new runtime.RequiredError(
        'identity',
        'Required parameter requestParameters.identity was null or undefined when calling assignPasswordPolicyToIdp.',
      );
    }

    if (requestParameters.assignPasswordPolicy === null || requestParameters.assignPasswordPolicy === undefined) {
      throw new runtime.RequiredError(
        'assignPasswordPolicy',
        'Required parameter requestParameters.assignPasswordPolicy was null or undefined when calling assignPasswordPolicyToIdp.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/identities/{identity}/password-policy`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'identity'}}`, encodeURIComponent(String(requestParameters.identity))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: AssignPasswordPolicyToJSON(requestParameters.assignPasswordPolicy),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => AssignPasswordPolicyFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_IDENTITY_PROVIDER[UPDATE] permission on the specified domain or DOMAIN_IDENTITY_PROVIDER[UPDATE] permission on the specified environment or DOMAIN_IDENTITY_PROVIDER[UPDATE] permission on the specified organization
   * Assign password policy to identity provider
   */
  async assignPasswordPolicyToIdp(
    requestParameters: AssignPasswordPolicyToIdpRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<AssignPasswordPolicy> {
    const response = await this.assignPasswordPolicyToIdpRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_GROUP[UPDATE] permission on the specified domain or DOMAIN_GROUP[UPDATE] permission on the specified environment or DOMAIN_GROUP[UPDATE] permission on the specified organization
   * Assign roles to a group
   */
  async assignRolesRaw(
    requestParameters: AssignRolesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Group>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling assignRoles.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling assignRoles.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling assignRoles.',
      );
    }

    if (requestParameters.group === null || requestParameters.group === undefined) {
      throw new runtime.RequiredError(
        'group',
        'Required parameter requestParameters.group was null or undefined when calling assignRoles.',
      );
    }

    if (requestParameters.requestBody === null || requestParameters.requestBody === undefined) {
      throw new runtime.RequiredError(
        'requestBody',
        'Required parameter requestParameters.requestBody was null or undefined when calling assignRoles.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/groups/{group}/roles`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'group'}}`, encodeURIComponent(String(requestParameters.group))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.requestBody,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => GroupFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_GROUP[UPDATE] permission on the specified domain or DOMAIN_GROUP[UPDATE] permission on the specified environment or DOMAIN_GROUP[UPDATE] permission on the specified organization
   * Assign roles to a group
   */
  async assignRoles(requestParameters: AssignRolesRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Group> {
    const response = await this.assignRolesRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Assign roles to a user
   */
  async assignRolesToUserRaw(
    requestParameters: AssignRolesToUserRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<User>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling assignRolesToUser.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling assignRolesToUser.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling assignRolesToUser.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling assignRolesToUser.',
      );
    }

    if (requestParameters.requestBody === null || requestParameters.requestBody === undefined) {
      throw new runtime.RequiredError(
        'requestBody',
        'Required parameter requestParameters.requestBody was null or undefined when calling assignRolesToUser.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/roles`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.requestBody,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Assign roles to a user
   */
  async assignRolesToUser(
    requestParameters: AssignRolesToUserRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<User> {
    const response = await this.assignRolesToUserRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[CREATE/UPDATE/DELETE] permission on the specified domain, the environment, or the organization
   * Create/update/delete multiple users on the specified security domain
   */
  async bulkUserOperationRaw(
    requestParameters: BulkUserOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<BulkResponse>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling bulkUserOperation.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling bulkUserOperation.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling bulkUserOperation.',
      );
    }

    if (requestParameters.domainUserBulkRequest === null || requestParameters.domainUserBulkRequest === undefined) {
      throw new runtime.RequiredError(
        'domainUserBulkRequest',
        'Required parameter requestParameters.domainUserBulkRequest was null or undefined when calling bulkUserOperation.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/bulk`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: DomainUserBulkRequestToJSON(requestParameters.domainUserBulkRequest),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => BulkResponseFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_USER[CREATE/UPDATE/DELETE] permission on the specified domain, the environment, or the organization
   * Create/update/delete multiple users on the specified security domain
   */
  async bulkUserOperation(
    requestParameters: BulkUserOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<BulkResponse> {
    const response = await this.bulkUserOperationRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Create a new alert notifierUser must have DOMAIN_ALERT_NOTIFIER[CREATE] permission on the specified domain, environment or organization.
   * Create an alert notifier
   */
  async createAlertNotifierRaw(
    requestParameters: CreateAlertNotifierRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<AlertNotifier>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createAlertNotifier.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createAlertNotifier.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling createAlertNotifier.',
      );
    }

    if (requestParameters.newAlertNotifier === null || requestParameters.newAlertNotifier === undefined) {
      throw new runtime.RequiredError(
        'newAlertNotifier',
        'Required parameter requestParameters.newAlertNotifier was null or undefined when calling createAlertNotifier.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/alerts/notifiers`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewAlertNotifierToJSON(requestParameters.newAlertNotifier),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => AlertNotifierFromJSON(jsonValue));
  }

  /**
   * Create a new alert notifierUser must have DOMAIN_ALERT_NOTIFIER[CREATE] permission on the specified domain, environment or organization.
   * Create an alert notifier
   */
  async createAlertNotifier(
    requestParameters: CreateAlertNotifierRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<AlertNotifier> {
    const response = await this.createAlertNotifierRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have APPLICATION[CREATE] permission on the specified domain or APPLICATION[CREATE] permission on the specified environment or APPLICATION[CREATE] permission on the specified organization
   * Create an application
   */
  async createApplicationRaw(
    requestParameters: CreateApplicationRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Application>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createApplication.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createApplication.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling createApplication.',
      );
    }

    if (requestParameters.newApplication === null || requestParameters.newApplication === undefined) {
      throw new runtime.RequiredError(
        'newApplication',
        'Required parameter requestParameters.newApplication was null or undefined when calling createApplication.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewApplicationToJSON(requestParameters.newApplication),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ApplicationFromJSON(jsonValue));
  }

  /**
   * User must have APPLICATION[CREATE] permission on the specified domain or APPLICATION[CREATE] permission on the specified environment or APPLICATION[CREATE] permission on the specified organization
   * Create an application
   */
  async createApplication(
    requestParameters: CreateApplicationRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Application> {
    const response = await this.createApplicationRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have APPLICATION_EMAIL_TEMPLATE[CREATE] permission on the specified application or APPLICATION_EMAIL_TEMPLATE[CREATE] permission on the specified domain or APPLICATION_EMAIL_TEMPLATE[CREATE] permission on the specified environment or APPLICATION_EMAIL_TEMPLATE[CREATE] permission on the specified organization
   * Create a email for an application
   */
  async createApplicationEmailRaw(
    requestParameters: CreateApplicationEmailRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createApplicationEmail.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createApplicationEmail.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling createApplicationEmail.',
      );
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling createApplicationEmail.',
      );
    }

    if (requestParameters.newEmail === null || requestParameters.newEmail === undefined) {
      throw new runtime.RequiredError(
        'newEmail',
        'Required parameter requestParameters.newEmail was null or undefined when calling createApplicationEmail.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/emails`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewEmailToJSON(requestParameters.newEmail),
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have APPLICATION_EMAIL_TEMPLATE[CREATE] permission on the specified application or APPLICATION_EMAIL_TEMPLATE[CREATE] permission on the specified domain or APPLICATION_EMAIL_TEMPLATE[CREATE] permission on the specified environment or APPLICATION_EMAIL_TEMPLATE[CREATE] permission on the specified organization
   * Create a email for an application
   */
  async createApplicationEmail(
    requestParameters: CreateApplicationEmailRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.createApplicationEmailRaw(requestParameters, initOverrides);
  }

  /**
   * User must have APPLICATION_FORM[CREATE] permission on the specified application or APPLICATION_FORM[CREATE] permission on the specified domain or APPLICATION_FORM[CREATE] permission on the specified environment or APPLICATION_FORM[CREATE] permission on the specified organization
   * Create a form for an application
   */
  async createApplicationFormRaw(
    requestParameters: CreateApplicationFormRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createApplicationForm.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createApplicationForm.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling createApplicationForm.',
      );
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling createApplicationForm.',
      );
    }

    if (requestParameters.newForm === null || requestParameters.newForm === undefined) {
      throw new runtime.RequiredError(
        'newForm',
        'Required parameter requestParameters.newForm was null or undefined when calling createApplicationForm.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/forms`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewFormToJSON(requestParameters.newForm),
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have APPLICATION_FORM[CREATE] permission on the specified application or APPLICATION_FORM[CREATE] permission on the specified domain or APPLICATION_FORM[CREATE] permission on the specified environment or APPLICATION_FORM[CREATE] permission on the specified organization
   * Create a form for an application
   */
  async createApplicationForm(
    requestParameters: CreateApplicationFormRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.createApplicationFormRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_AUTHDEVICE_NOTIFIER[CREATE] permission on the specified domain or DOMAIN_AUTHDEVICE_NOTIFIER[CREATE] permission on the specified environment or DOMAIN_AUTHDEVICE_NOTIFIER[CREATE] permission on the specified organization
   * Create an Authentication Device Notifier
   */
  async createAuthenticationDeviceNotifierRaw(
    requestParameters: CreateAuthenticationDeviceNotifierRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createAuthenticationDeviceNotifier.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createAuthenticationDeviceNotifier.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling createAuthenticationDeviceNotifier.',
      );
    }

    if (requestParameters.newAuthenticationDeviceNotifier === null || requestParameters.newAuthenticationDeviceNotifier === undefined) {
      throw new runtime.RequiredError(
        'newAuthenticationDeviceNotifier',
        'Required parameter requestParameters.newAuthenticationDeviceNotifier was null or undefined when calling createAuthenticationDeviceNotifier.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/auth-device-notifiers`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewAuthenticationDeviceNotifierToJSON(requestParameters.newAuthenticationDeviceNotifier),
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_AUTHDEVICE_NOTIFIER[CREATE] permission on the specified domain or DOMAIN_AUTHDEVICE_NOTIFIER[CREATE] permission on the specified environment or DOMAIN_AUTHDEVICE_NOTIFIER[CREATE] permission on the specified organization
   * Create an Authentication Device Notifier
   */
  async createAuthenticationDeviceNotifier(
    requestParameters: CreateAuthenticationDeviceNotifierRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.createAuthenticationDeviceNotifierRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_AUTHORIZATION_ENGINE[CREATE] permission on the specified domain or DOMAIN_AUTHORIZATION_ENGINE[CREATE] permission on the specified environment or DOMAIN_AUTHORIZATION_ENGINE[CREATE] permission on the specified organization
   * Create an authorization engine
   */
  async createAuthorizationEngineRaw(
    requestParameters: CreateAuthorizationEngineRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<AuthorizationEngine>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createAuthorizationEngine.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createAuthorizationEngine.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling createAuthorizationEngine.',
      );
    }

    if (requestParameters.newAuthorizationEngine === null || requestParameters.newAuthorizationEngine === undefined) {
      throw new runtime.RequiredError(
        'newAuthorizationEngine',
        'Required parameter requestParameters.newAuthorizationEngine was null or undefined when calling createAuthorizationEngine.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/authorization-engines`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewAuthorizationEngineToJSON(requestParameters.newAuthorizationEngine),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => AuthorizationEngineFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_AUTHORIZATION_ENGINE[CREATE] permission on the specified domain or DOMAIN_AUTHORIZATION_ENGINE[CREATE] permission on the specified environment or DOMAIN_AUTHORIZATION_ENGINE[CREATE] permission on the specified organization
   * Create an authorization engine
   */
  async createAuthorizationEngine(
    requestParameters: CreateAuthorizationEngineRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<AuthorizationEngine> {
    const response = await this.createAuthorizationEngineRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_BOT_DETECTION[CREATE] permission on the specified domain or DOMAIN_BOT_DETECTION[CREATE] permission on the specified environment or DOMAIN_BOT_DETECTION[CREATE] permission on the specified organization
   * Create a bot detection
   */
  async createBotDetectionRaw(
    requestParameters: CreateBotDetectionRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<BotDetection>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createBotDetection.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createBotDetection.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling createBotDetection.',
      );
    }

    if (requestParameters.newBotDetection === null || requestParameters.newBotDetection === undefined) {
      throw new runtime.RequiredError(
        'newBotDetection',
        'Required parameter requestParameters.newBotDetection was null or undefined when calling createBotDetection.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/bot-detections`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewBotDetectionToJSON(requestParameters.newBotDetection),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => BotDetectionFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_BOT_DETECTION[CREATE] permission on the specified domain or DOMAIN_BOT_DETECTION[CREATE] permission on the specified environment or DOMAIN_BOT_DETECTION[CREATE] permission on the specified organization
   * Create a bot detection
   */
  async createBotDetection(
    requestParameters: CreateBotDetectionRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<BotDetection> {
    const response = await this.createBotDetectionRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_CERTIFICATE[CREATE] permission on the specified domain or DOMAIN_CERTIFICATE[CREATE] permission on the specified environment or DOMAIN_CERTIFICATE[CREATE] permission on the specified organization
   * Create a certificate
   */
  async createCertificateRaw(
    requestParameters: CreateCertificateRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ModifiedCertificateEntity>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createCertificate.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createCertificate.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling createCertificate.',
      );
    }

    if (requestParameters.newCertificate === null || requestParameters.newCertificate === undefined) {
      throw new runtime.RequiredError(
        'newCertificate',
        'Required parameter requestParameters.newCertificate was null or undefined when calling createCertificate.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/certificates`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewCertificateToJSON(requestParameters.newCertificate),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ModifiedCertificateEntityFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_CERTIFICATE[CREATE] permission on the specified domain or DOMAIN_CERTIFICATE[CREATE] permission on the specified environment or DOMAIN_CERTIFICATE[CREATE] permission on the specified organization
   * Create a certificate
   */
  async createCertificate(
    requestParameters: CreateCertificateRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<ModifiedCertificateEntity> {
    const response = await this.createCertificateRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_DEVICE_IDENTIFIER[CREATE] permission on the specified domain or DOMAIN_DEVICE_IDENTIFIER[CREATE] permission on the specified environment or DOMAIN_DEVICE_IDENTIFIER[CREATE] permission on the specified organization
   * Create a device identifier
   */
  async createDeviceIdentifierRaw(
    requestParameters: CreateDeviceIdentifierRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<DeviceIdentifier>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createDeviceIdentifier.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createDeviceIdentifier.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling createDeviceIdentifier.',
      );
    }

    if (requestParameters.newDeviceIdentifier === null || requestParameters.newDeviceIdentifier === undefined) {
      throw new runtime.RequiredError(
        'newDeviceIdentifier',
        'Required parameter requestParameters.newDeviceIdentifier was null or undefined when calling createDeviceIdentifier.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/device-identifiers`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewDeviceIdentifierToJSON(requestParameters.newDeviceIdentifier),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => DeviceIdentifierFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_DEVICE_IDENTIFIER[CREATE] permission on the specified domain or DOMAIN_DEVICE_IDENTIFIER[CREATE] permission on the specified environment or DOMAIN_DEVICE_IDENTIFIER[CREATE] permission on the specified organization
   * Create a device identifier
   */
  async createDeviceIdentifier(
    requestParameters: CreateDeviceIdentifierRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<DeviceIdentifier> {
    const response = await this.createDeviceIdentifierRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Create a security domain. User must have DOMAIN[CREATE] permission on the specified environment or DOMAIN[CREATE] permission on the specified organization
   * Create a security domain.
   */
  async createDomainRaw(
    requestParameters: CreateDomainRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Domain>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createDomain.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createDomain.',
      );
    }

    if (requestParameters.newDomain === null || requestParameters.newDomain === undefined) {
      throw new runtime.RequiredError(
        'newDomain',
        'Required parameter requestParameters.newDomain was null or undefined when calling createDomain.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewDomainToJSON(requestParameters.newDomain),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => DomainFromJSON(jsonValue));
  }

  /**
   * Create a security domain. User must have DOMAIN[CREATE] permission on the specified environment or DOMAIN[CREATE] permission on the specified organization
   * Create a security domain.
   */
  async createDomain(requestParameters: CreateDomainRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Domain> {
    const response = await this.createDomainRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_REPORTER[CREATE] permission on the specified domain or DOMAIN_REPORTER[CREATE] permission on the specified environment or DOMAIN_REPORTER[CREATE] permission on the specified organization.
   * Create a reporter for a security domain
   */
  async createDomainReporterRaw(
    requestParameters: CreateDomainReporterRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Reporter>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createDomainReporter.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createDomainReporter.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling createDomainReporter.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/reporters`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewReporterToJSON(requestParameters.newReporter),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ReporterFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_REPORTER[CREATE] permission on the specified domain or DOMAIN_REPORTER[CREATE] permission on the specified environment or DOMAIN_REPORTER[CREATE] permission on the specified organization.
   * Create a reporter for a security domain
   */
  async createDomainReporter(
    requestParameters: CreateDomainReporterRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Reporter> {
    const response = await this.createDomainReporterRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_EMAIL_TEMPLATE[CREATE] permission on the specified domain or DOMAIN_EMAIL_TEMPLATE[CREATE] permission on the specified environment or DOMAIN_EMAIL_TEMPLATE[CREATE] permission on the specified organization
   * Create a email
   */
  async createEmailRaw(
    requestParameters: CreateEmailRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createEmail.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createEmail.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling createEmail.',
      );
    }

    if (requestParameters.newEmail === null || requestParameters.newEmail === undefined) {
      throw new runtime.RequiredError(
        'newEmail',
        'Required parameter requestParameters.newEmail was null or undefined when calling createEmail.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/emails`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewEmailToJSON(requestParameters.newEmail),
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_EMAIL_TEMPLATE[CREATE] permission on the specified domain or DOMAIN_EMAIL_TEMPLATE[CREATE] permission on the specified environment or DOMAIN_EMAIL_TEMPLATE[CREATE] permission on the specified organization
   * Create a email
   */
  async createEmail(requestParameters: CreateEmailRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.createEmailRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_EXTENSION_GRANT[CREATE] permission on the specified domain or DOMAIN_EXTENSION_GRANT[CREATE] permission on the specified environment or DOMAIN_EXTENSION_GRANT[CREATE] permission on the specified organization
   * Create a extension grant
   */
  async createExtensionGrantRaw(
    requestParameters: CreateExtensionGrantRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ExtensionGrant>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createExtensionGrant.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createExtensionGrant.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling createExtensionGrant.',
      );
    }

    if (requestParameters.newExtensionGrant === null || requestParameters.newExtensionGrant === undefined) {
      throw new runtime.RequiredError(
        'newExtensionGrant',
        'Required parameter requestParameters.newExtensionGrant was null or undefined when calling createExtensionGrant.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/extensionGrants`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewExtensionGrantToJSON(requestParameters.newExtensionGrant),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ExtensionGrantFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_EXTENSION_GRANT[CREATE] permission on the specified domain or DOMAIN_EXTENSION_GRANT[CREATE] permission on the specified environment or DOMAIN_EXTENSION_GRANT[CREATE] permission on the specified organization
   * Create a extension grant
   */
  async createExtensionGrant(
    requestParameters: CreateExtensionGrantRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<ExtensionGrant> {
    const response = await this.createExtensionGrantRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_FACTOR[CREATE] permission on the specified domain or DOMAIN_FACTOR[CREATE] permission on the specified environment or DOMAIN_FACTOR[CREATE] permission on the specified organization
   * Create a factor
   */
  async createFactorRaw(
    requestParameters: CreateFactorRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Factor>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createFactor.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createFactor.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling createFactor.',
      );
    }

    if (requestParameters.newFactor === null || requestParameters.newFactor === undefined) {
      throw new runtime.RequiredError(
        'newFactor',
        'Required parameter requestParameters.newFactor was null or undefined when calling createFactor.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/factors`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewFactorToJSON(requestParameters.newFactor),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => FactorFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_FACTOR[CREATE] permission on the specified domain or DOMAIN_FACTOR[CREATE] permission on the specified environment or DOMAIN_FACTOR[CREATE] permission on the specified organization
   * Create a factor
   */
  async createFactor(requestParameters: CreateFactorRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Factor> {
    const response = await this.createFactorRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_FORM[CREATE] permission on the specified domain or DOMAIN_FORM[CREATE] permission on the specified environment or DOMAIN_FORM[CREATE] permission on the specified organization
   * Create a form
   */
  async createFormRaw(
    requestParameters: CreateFormRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createForm.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createForm.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling createForm.',
      );
    }

    if (requestParameters.newForm === null || requestParameters.newForm === undefined) {
      throw new runtime.RequiredError(
        'newForm',
        'Required parameter requestParameters.newForm was null or undefined when calling createForm.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/forms`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewFormToJSON(requestParameters.newForm),
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_FORM[CREATE] permission on the specified domain or DOMAIN_FORM[CREATE] permission on the specified environment or DOMAIN_FORM[CREATE] permission on the specified organization
   * Create a form
   */
  async createForm(requestParameters: CreateFormRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.createFormRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_GROUP[CREATE] permission on the specified domain or DOMAIN_GROUP[CREATE] permission on the specified environment or DOMAIN_GROUP[CREATE] permission on the specified organization
   * Create a group
   */
  async createGroupRaw(
    requestParameters: CreateGroupRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Group>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createGroup.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createGroup.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling createGroup.',
      );
    }

    if (requestParameters.newGroup === null || requestParameters.newGroup === undefined) {
      throw new runtime.RequiredError(
        'newGroup',
        'Required parameter requestParameters.newGroup was null or undefined when calling createGroup.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/groups`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewGroupToJSON(requestParameters.newGroup),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => GroupFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_GROUP[CREATE] permission on the specified domain or DOMAIN_GROUP[CREATE] permission on the specified environment or DOMAIN_GROUP[CREATE] permission on the specified organization
   * Create a group
   */
  async createGroup(requestParameters: CreateGroupRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Group> {
    const response = await this.createGroupRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_I18N_DICTIONARY[CREATE] permission on the specified domain or DOMAIN_I18N_DICTIONARY[CREATE] permission on the specified environment or DOMAIN_I18N_DICTIONARY[CREATE] permission on the specified organization.
   * Create a new i18n dictionary for a supported language for a security domain
   */
  async createI18nDictionaryRaw(
    requestParameters: CreateI18nDictionaryRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<I18nDictionary>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createI18nDictionary.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createI18nDictionary.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling createI18nDictionary.',
      );
    }

    if (requestParameters.newDictionary === null || requestParameters.newDictionary === undefined) {
      throw new runtime.RequiredError(
        'newDictionary',
        'Required parameter requestParameters.newDictionary was null or undefined when calling createI18nDictionary.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/i18n/dictionaries`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewDictionaryToJSON(requestParameters.newDictionary),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => I18nDictionaryFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_I18N_DICTIONARY[CREATE] permission on the specified domain or DOMAIN_I18N_DICTIONARY[CREATE] permission on the specified environment or DOMAIN_I18N_DICTIONARY[CREATE] permission on the specified organization.
   * Create a new i18n dictionary for a supported language for a security domain
   */
  async createI18nDictionary(
    requestParameters: CreateI18nDictionaryRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<I18nDictionary> {
    const response = await this.createI18nDictionaryRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_IDENTITY_PROVIDER[CREATE] permission on the specified domain or DOMAIN_IDENTITY_PROVIDER[CREATE] permission on the specified environment or DOMAIN_IDENTITY_PROVIDER[CREATE] permission on the specified organization
   * Create an identity provider
   */
  async createIdentityProviderRaw(
    requestParameters: CreateIdentityProviderRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<IdentityProvider>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createIdentityProvider.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createIdentityProvider.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling createIdentityProvider.',
      );
    }

    if (requestParameters.newIdentityProvider === null || requestParameters.newIdentityProvider === undefined) {
      throw new runtime.RequiredError(
        'newIdentityProvider',
        'Required parameter requestParameters.newIdentityProvider was null or undefined when calling createIdentityProvider.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/identities`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewIdentityProviderToJSON(requestParameters.newIdentityProvider),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => IdentityProviderFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_IDENTITY_PROVIDER[CREATE] permission on the specified domain or DOMAIN_IDENTITY_PROVIDER[CREATE] permission on the specified environment or DOMAIN_IDENTITY_PROVIDER[CREATE] permission on the specified organization
   * Create an identity provider
   */
  async createIdentityProvider(
    requestParameters: CreateIdentityProviderRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<IdentityProvider> {
    const response = await this.createIdentityProviderRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_SETTINGS[UPDATE] permission on the specified domain or DOMAIN_SETTINGS[UPDATE] permission on the specified environment or DOMAIN_SETTINGS[UPDATE] permission on the specified organization
   * Create a password policy
   */
  async createPasswordPolicyRaw(
    requestParameters: CreatePasswordPolicyRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<PasswordPolicy>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createPasswordPolicy.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createPasswordPolicy.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling createPasswordPolicy.',
      );
    }

    if (requestParameters.newPasswordPolicy === null || requestParameters.newPasswordPolicy === undefined) {
      throw new runtime.RequiredError(
        'newPasswordPolicy',
        'Required parameter requestParameters.newPasswordPolicy was null or undefined when calling createPasswordPolicy.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/password-policies`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewPasswordPolicyToJSON(requestParameters.newPasswordPolicy),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => PasswordPolicyFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_SETTINGS[UPDATE] permission on the specified domain or DOMAIN_SETTINGS[UPDATE] permission on the specified environment or DOMAIN_SETTINGS[UPDATE] permission on the specified organization
   * Create a password policy
   */
  async createPasswordPolicy(
    requestParameters: CreatePasswordPolicyRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<PasswordPolicy> {
    const response = await this.createPasswordPolicyRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have PROTECTED_RESOURCE[CREATE] permission on the specified domain or PROTECTED_RESOURCE[CREATE] permission on the specified environment or PROTECTED_RESOURCE[CREATE] permission on the specified organization
   * Create a Protected Resource definition
   */
  async createProtectedResourceRaw(
    requestParameters: CreateProtectedResourceRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ProtectedResourceSecret>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createProtectedResource.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createProtectedResource.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling createProtectedResource.',
      );
    }

    if (requestParameters.newProtectedResource === null || requestParameters.newProtectedResource === undefined) {
      throw new runtime.RequiredError(
        'newProtectedResource',
        'Required parameter requestParameters.newProtectedResource was null or undefined when calling createProtectedResource.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/protected-resources`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewProtectedResourceToJSON(requestParameters.newProtectedResource),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ProtectedResourceSecretFromJSON(jsonValue));
  }

  /**
   * User must have PROTECTED_RESOURCE[CREATE] permission on the specified domain or PROTECTED_RESOURCE[CREATE] permission on the specified environment or PROTECTED_RESOURCE[CREATE] permission on the specified organization
   * Create a Protected Resource definition
   */
  async createProtectedResource(
    requestParameters: CreateProtectedResourceRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<ProtectedResourceSecret> {
    const response = await this.createProtectedResourceRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_RESOURCE[CREATE] permission on the specified domain or DOMAIN_RESOURCE[CREATE] permission on the specified environment or DOMAIN_RESOURCE[CREATE] permission on the specified organization
   * Create a resource
   */
  async createResourceRaw(
    requestParameters: CreateResourceRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ServiceResource>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createResource.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createResource.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling createResource.',
      );
    }

    if (requestParameters.newServiceResource === null || requestParameters.newServiceResource === undefined) {
      throw new runtime.RequiredError(
        'newServiceResource',
        'Required parameter requestParameters.newServiceResource was null or undefined when calling createResource.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/resources`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewServiceResourceToJSON(requestParameters.newServiceResource),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ServiceResourceFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_RESOURCE[CREATE] permission on the specified domain or DOMAIN_RESOURCE[CREATE] permission on the specified environment or DOMAIN_RESOURCE[CREATE] permission on the specified organization
   * Create a resource
   */
  async createResource(
    requestParameters: CreateResourceRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<ServiceResource> {
    const response = await this.createResourceRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_ROLE[CREATE] permission on the specified domain or DOMAIN_ROLE[CREATE] permission on the specified environment or DOMAIN_ROLE[CREATE] permission on the specified organization
   * Create a role
   */
  async createRoleRaw(
    requestParameters: CreateRoleRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Role>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createRole.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createRole.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling createRole.',
      );
    }

    if (requestParameters.newRole === null || requestParameters.newRole === undefined) {
      throw new runtime.RequiredError(
        'newRole',
        'Required parameter requestParameters.newRole was null or undefined when calling createRole.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/roles`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewRoleToJSON(requestParameters.newRole),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => RoleFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_ROLE[CREATE] permission on the specified domain or DOMAIN_ROLE[CREATE] permission on the specified environment or DOMAIN_ROLE[CREATE] permission on the specified organization
   * Create a role
   */
  async createRole(requestParameters: CreateRoleRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Role> {
    const response = await this.createRoleRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_SCOPE[CREATE] permission on the specified domain or DOMAIN_SCOPE[CREATE] permission on the specified environment or DOMAIN_SCOPE[CREATE] permission on the specified organization
   * Create a scope
   */
  async createScopeRaw(
    requestParameters: CreateScopeRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Scope>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createScope.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createScope.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling createScope.',
      );
    }

    if (requestParameters.newScope === null || requestParameters.newScope === undefined) {
      throw new runtime.RequiredError(
        'newScope',
        'Required parameter requestParameters.newScope was null or undefined when calling createScope.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/scopes`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewScopeToJSON(requestParameters.newScope),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ScopeFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_SCOPE[CREATE] permission on the specified domain or DOMAIN_SCOPE[CREATE] permission on the specified environment or DOMAIN_SCOPE[CREATE] permission on the specified organization
   * Create a scope
   */
  async createScope(requestParameters: CreateScopeRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Scope> {
    const response = await this.createScopeRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have APPLICATION_OPENID[CREATE] permission on the specified application or APPLICATION_OPENID[CREATE] permission on the specified domain or APPLICATION_OPENID[CREATE] permission on the specified environment or APPLICATION_OPENID[CREATE] permission on the specified organization
   * Create a secret for an application
   */
  async createSecretRaw(
    requestParameters: CreateSecretRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ClientSecret>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createSecret.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createSecret.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling createSecret.',
      );
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling createSecret.',
      );
    }

    if (requestParameters.newClientSecret === null || requestParameters.newClientSecret === undefined) {
      throw new runtime.RequiredError(
        'newClientSecret',
        'Required parameter requestParameters.newClientSecret was null or undefined when calling createSecret.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/secrets`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewClientSecretToJSON(requestParameters.newClientSecret),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ClientSecretFromJSON(jsonValue));
  }

  /**
   * User must have APPLICATION_OPENID[CREATE] permission on the specified application or APPLICATION_OPENID[CREATE] permission on the specified domain or APPLICATION_OPENID[CREATE] permission on the specified environment or APPLICATION_OPENID[CREATE] permission on the specified organization
   * Create a secret for an application
   */
  async createSecret(
    requestParameters: CreateSecretRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<ClientSecret> {
    const response = await this.createSecretRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_THEME[CREATE] permission on the specified domain or DOMAIN_THEME[CREATE] permission on the specified environment or DOMAIN_THEME[CREATE] permission on the specified organization
   * Create a theme on the specified security domain
   */
  async createThemeRaw(
    requestParameters: CreateThemeRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ThemeEntity>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createTheme.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createTheme.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling createTheme.',
      );
    }

    if (requestParameters.newTheme === null || requestParameters.newTheme === undefined) {
      throw new runtime.RequiredError(
        'newTheme',
        'Required parameter requestParameters.newTheme was null or undefined when calling createTheme.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/themes`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewThemeToJSON(requestParameters.newTheme),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ThemeEntityFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_THEME[CREATE] permission on the specified domain or DOMAIN_THEME[CREATE] permission on the specified environment or DOMAIN_THEME[CREATE] permission on the specified organization
   * Create a theme on the specified security domain
   */
  async createTheme(
    requestParameters: CreateThemeRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<ThemeEntity> {
    const response = await this.createThemeRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[CREATE] permission on the specified domain or DOMAIN_USER[CREATE] permission on the specified environment or DOMAIN_USER[CREATE] permission on the specified organization
   * Create a user on the specified security domain
   */
  async createUserRaw(
    requestParameters: CreateUserRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<User>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createUser.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createUser.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling createUser.',
      );
    }

    if (requestParameters.newUser === null || requestParameters.newUser === undefined) {
      throw new runtime.RequiredError(
        'newUser',
        'Required parameter requestParameters.newUser was null or undefined when calling createUser.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewUserToJSON(requestParameters.newUser),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_USER[CREATE] permission on the specified domain or DOMAIN_USER[CREATE] permission on the specified environment or DOMAIN_USER[CREATE] permission on the specified organization
   * Create a user on the specified security domain
   */
  async createUser(requestParameters: CreateUserRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<User> {
    const response = await this.createUserRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the APPLICATION_FLOW[UPDATE] permission on the specified domain or APPLICATION_FLOW[UPDATE] permission on the specified environment or APPLICATION_FLOW[UPDATE] permission on the specified organization
   * Create or update list of flows
   */
  async defineAppFlowsRaw(
    requestParameters: DefineAppFlowsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<FlowEntity>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling defineAppFlows.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling defineAppFlows.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling defineAppFlows.',
      );
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling defineAppFlows.',
      );
    }

    if (requestParameters.flow === null || requestParameters.flow === undefined) {
      throw new runtime.RequiredError(
        'flow',
        'Required parameter requestParameters.flow was null or undefined when calling defineAppFlows.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/flows`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.flow.map(FlowToJSON),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(FlowEntityFromJSON));
  }

  /**
   * User must have the APPLICATION_FLOW[UPDATE] permission on the specified domain or APPLICATION_FLOW[UPDATE] permission on the specified environment or APPLICATION_FLOW[UPDATE] permission on the specified organization
   * Create or update list of flows
   */
  async defineAppFlows(
    requestParameters: DefineAppFlowsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<FlowEntity>> {
    const response = await this.defineAppFlowsRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_FLOW[UPDATE] permission on the specified domain or DOMAIN_FLOW[UPDATE] permission on the specified environment or DOMAIN_FLOW[UPDATE] permission on the specified organization
   * Create or update list of flows
   */
  async defineDomainFlowsRaw(
    requestParameters: DefineDomainFlowsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<FlowEntity>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling defineDomainFlows.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling defineDomainFlows.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling defineDomainFlows.',
      );
    }

    if (requestParameters.flow === null || requestParameters.flow === undefined) {
      throw new runtime.RequiredError(
        'flow',
        'Required parameter requestParameters.flow was null or undefined when calling defineDomainFlows.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/flows`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.flow.map(FlowToJSON),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(FlowEntityFromJSON));
  }

  /**
   * User must have the DOMAIN_FLOW[UPDATE] permission on the specified domain or DOMAIN_FLOW[UPDATE] permission on the specified environment or DOMAIN_FLOW[UPDATE] permission on the specified organization
   * Create or update list of flows
   */
  async defineDomainFlows(
    requestParameters: DefineDomainFlowsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<FlowEntity>> {
    const response = await this.defineDomainFlowsRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Delete an alert notifier by its id. User must have DOMAIN_ALERT_NOTIFIER[DELETE] permission on the specified domain, environment or organization.
   * Delete an alert notifier
   */
  async deleteAlertNotifierRaw(
    requestParameters: DeleteAlertNotifierRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteAlertNotifier.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteAlertNotifier.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteAlertNotifier.',
      );
    }

    if (requestParameters.notifierId === null || requestParameters.notifierId === undefined) {
      throw new runtime.RequiredError(
        'notifierId',
        'Required parameter requestParameters.notifierId was null or undefined when calling deleteAlertNotifier.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/alerts/notifiers/{notifierId}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'notifierId'}}`, encodeURIComponent(String(requestParameters.notifierId))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Delete an alert notifier by its id. User must have DOMAIN_ALERT_NOTIFIER[DELETE] permission on the specified domain, environment or organization.
   * Delete an alert notifier
   */
  async deleteAlertNotifier(
    requestParameters: DeleteAlertNotifierRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.deleteAlertNotifierRaw(requestParameters, initOverrides);
  }

  /**
   * User must have APPLICATION[DELETE] permission on the specified application or APPLICATION[DELETE] permission on the specified domain or APPLICATION[DELETE] permission on the specified environment or APPLICATION[DELETE] permission on the specified organization
   * Delete an application
   */
  async deleteApplicationRaw(
    requestParameters: DeleteApplicationRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteApplication.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteApplication.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteApplication.',
      );
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling deleteApplication.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have APPLICATION[DELETE] permission on the specified application or APPLICATION[DELETE] permission on the specified domain or APPLICATION[DELETE] permission on the specified environment or APPLICATION[DELETE] permission on the specified organization
   * Delete an application
   */
  async deleteApplication(
    requestParameters: DeleteApplicationRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.deleteApplicationRaw(requestParameters, initOverrides);
  }

  /**
   * User must have APPLICATION_EMAIL_TEMPLATE[DELETE] permission on the specified application or APPLICATION_EMAIL_TEMPLATE[DELETE] permission on the specified domain or APPLICATION_EMAIL_TEMPLATE[DELETE] permission on the specified environment or APPLICATION_EMAIL_TEMPLATE[DELETE] permission on the specified organization
   * Delete an email for an application
   */
  async deleteApplicationEmailRaw(
    requestParameters: DeleteApplicationEmailRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteApplicationEmail.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteApplicationEmail.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteApplicationEmail.',
      );
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling deleteApplicationEmail.',
      );
    }

    if (requestParameters.email === null || requestParameters.email === undefined) {
      throw new runtime.RequiredError(
        'email',
        'Required parameter requestParameters.email was null or undefined when calling deleteApplicationEmail.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/emails/{email}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application)))
          .replace(`{${'email'}}`, encodeURIComponent(String(requestParameters.email))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have APPLICATION_EMAIL_TEMPLATE[DELETE] permission on the specified application or APPLICATION_EMAIL_TEMPLATE[DELETE] permission on the specified domain or APPLICATION_EMAIL_TEMPLATE[DELETE] permission on the specified environment or APPLICATION_EMAIL_TEMPLATE[DELETE] permission on the specified organization
   * Delete an email for an application
   */
  async deleteApplicationEmail(
    requestParameters: DeleteApplicationEmailRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.deleteApplicationEmailRaw(requestParameters, initOverrides);
  }

  /**
   * User must have APPLICATION_FORM[DELETE] permission on the specified application or APPLICATION_FORM[DELETE] permission on the specified domain or APPLICATION_FORM[DELETE] permission on the specified environment or APPLICATION_FORM[DELETE] permission on the specified organization
   * Delete a form for an application
   */
  async deleteApplicationFormRaw(
    requestParameters: DeleteApplicationFormRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteApplicationForm.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteApplicationForm.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteApplicationForm.',
      );
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling deleteApplicationForm.',
      );
    }

    if (requestParameters.form === null || requestParameters.form === undefined) {
      throw new runtime.RequiredError(
        'form',
        'Required parameter requestParameters.form was null or undefined when calling deleteApplicationForm.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/forms/{form}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application)))
          .replace(`{${'form'}}`, encodeURIComponent(String(requestParameters.form))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have APPLICATION_FORM[DELETE] permission on the specified application or APPLICATION_FORM[DELETE] permission on the specified domain or APPLICATION_FORM[DELETE] permission on the specified environment or APPLICATION_FORM[DELETE] permission on the specified organization
   * Delete a form for an application
   */
  async deleteApplicationForm(
    requestParameters: DeleteApplicationFormRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.deleteApplicationFormRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_AUTHDEVICE_NOTIFIER[DELETE] permission on the specified domain or DOMAIN_AUTHDEVICE_NOTIFIER[DELETE] permission on the specified environment or DOMAIN_AUTHDEVICE_NOTIFIER[DELETE] permission on the specified organization
   * Delete an Authentication Device Notifier
   */
  async deleteAuthenticationDeviceNotifierRaw(
    requestParameters: DeleteAuthenticationDeviceNotifierRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteAuthenticationDeviceNotifier.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteAuthenticationDeviceNotifier.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteAuthenticationDeviceNotifier.',
      );
    }

    if (requestParameters.authDeviceNotifier === null || requestParameters.authDeviceNotifier === undefined) {
      throw new runtime.RequiredError(
        'authDeviceNotifier',
        'Required parameter requestParameters.authDeviceNotifier was null or undefined when calling deleteAuthenticationDeviceNotifier.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/auth-device-notifiers/{authDeviceNotifier}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'authDeviceNotifier'}}`, encodeURIComponent(String(requestParameters.authDeviceNotifier))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_AUTHDEVICE_NOTIFIER[DELETE] permission on the specified domain or DOMAIN_AUTHDEVICE_NOTIFIER[DELETE] permission on the specified environment or DOMAIN_AUTHDEVICE_NOTIFIER[DELETE] permission on the specified organization
   * Delete an Authentication Device Notifier
   */
  async deleteAuthenticationDeviceNotifier(
    requestParameters: DeleteAuthenticationDeviceNotifierRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.deleteAuthenticationDeviceNotifierRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_AUTHORIZATION_ENGINE[DELETE] permission on the specified domain or DOMAIN_AUTHORIZATION_ENGINE[DELETE] permission on the specified environment or DOMAIN_AUTHORIZATION_ENGINE[DELETE] permission on the specified organization
   * Delete an authorization engine
   */
  async deleteAuthorizationEngineRaw(
    requestParameters: DeleteAuthorizationEngineRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteAuthorizationEngine.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteAuthorizationEngine.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteAuthorizationEngine.',
      );
    }

    if (requestParameters.engineId === null || requestParameters.engineId === undefined) {
      throw new runtime.RequiredError(
        'engineId',
        'Required parameter requestParameters.engineId was null or undefined when calling deleteAuthorizationEngine.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/authorization-engines/{engineId}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'engineId'}}`, encodeURIComponent(String(requestParameters.engineId))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_AUTHORIZATION_ENGINE[DELETE] permission on the specified domain or DOMAIN_AUTHORIZATION_ENGINE[DELETE] permission on the specified environment or DOMAIN_AUTHORIZATION_ENGINE[DELETE] permission on the specified organization
   * Delete an authorization engine
   */
  async deleteAuthorizationEngine(
    requestParameters: DeleteAuthorizationEngineRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.deleteAuthorizationEngineRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_BOT_DETECTION[DELETE] permission on the specified domain or DOMAIN_BOT_DETECTION[DELETE] permission on the specified environment or DOMAIN_BOT_DETECTION[DELETE] permission on the specified organization
   * Delete a bot detection
   */
  async deleteBotDetectionRaw(
    requestParameters: DeleteBotDetectionRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteBotDetection.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteBotDetection.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteBotDetection.',
      );
    }

    if (requestParameters.botDetection === null || requestParameters.botDetection === undefined) {
      throw new runtime.RequiredError(
        'botDetection',
        'Required parameter requestParameters.botDetection was null or undefined when calling deleteBotDetection.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/bot-detections/{botDetection}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'botDetection'}}`, encodeURIComponent(String(requestParameters.botDetection))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_BOT_DETECTION[DELETE] permission on the specified domain or DOMAIN_BOT_DETECTION[DELETE] permission on the specified environment or DOMAIN_BOT_DETECTION[DELETE] permission on the specified organization
   * Delete a bot detection
   */
  async deleteBotDetection(
    requestParameters: DeleteBotDetectionRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.deleteBotDetectionRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_CERTIFICATE[DELETE] permission on the specified domain or DOMAIN_CERTIFICATE[DELETE] permission on the specified environment or DOMAIN_CERTIFICATE[DELETE] permission on the specified organization
   * Delete a certificate
   */
  async deleteCertificateRaw(
    requestParameters: DeleteCertificateRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteCertificate.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteCertificate.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteCertificate.',
      );
    }

    if (requestParameters.certificate === null || requestParameters.certificate === undefined) {
      throw new runtime.RequiredError(
        'certificate',
        'Required parameter requestParameters.certificate was null or undefined when calling deleteCertificate.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/certificates/{certificate}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'certificate'}}`, encodeURIComponent(String(requestParameters.certificate))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_CERTIFICATE[DELETE] permission on the specified domain or DOMAIN_CERTIFICATE[DELETE] permission on the specified environment or DOMAIN_CERTIFICATE[DELETE] permission on the specified organization
   * Delete a certificate
   */
  async deleteCertificate(
    requestParameters: DeleteCertificateRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.deleteCertificateRaw(requestParameters, initOverrides);
  }

  /**
   * User must have APPLICATION_OPENID[DELETE] permission on the specified application or APPLICATION_OPENID[DELETE] permission on the specified domain or APPLICATION_OPENID[DELETE] permission on the specified environment or APPLICATION_OPENID[DELETE] permission on the specified organization
   * Delete a secret of an application
   */
  async deleteClientSecretRaw(
    requestParameters: DeleteClientSecretRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteClientSecret.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteClientSecret.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteClientSecret.',
      );
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling deleteClientSecret.',
      );
    }

    if (requestParameters.secret === null || requestParameters.secret === undefined) {
      throw new runtime.RequiredError(
        'secret',
        'Required parameter requestParameters.secret was null or undefined when calling deleteClientSecret.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/secrets/{secret}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application)))
          .replace(`{${'secret'}}`, encodeURIComponent(String(requestParameters.secret))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have APPLICATION_OPENID[DELETE] permission on the specified application or APPLICATION_OPENID[DELETE] permission on the specified domain or APPLICATION_OPENID[DELETE] permission on the specified environment or APPLICATION_OPENID[DELETE] permission on the specified organization
   * Delete a secret of an application
   */
  async deleteClientSecret(
    requestParameters: DeleteClientSecretRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.deleteClientSecretRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_DEVICE_IDENTIFIER[DELETE] permission on the specified domain or DOMAIN_DEVICE_IDENTIFIER[DELETE] permission on the specified environment or DOMAIN_DEVICE_IDENTIFIER[DELETE] permission on the specified organization
   * Delete a Device identifier
   */
  async deleteDeviceIdentifierRaw(
    requestParameters: DeleteDeviceIdentifierRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteDeviceIdentifier.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteDeviceIdentifier.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteDeviceIdentifier.',
      );
    }

    if (requestParameters.deviceIdentifier === null || requestParameters.deviceIdentifier === undefined) {
      throw new runtime.RequiredError(
        'deviceIdentifier',
        'Required parameter requestParameters.deviceIdentifier was null or undefined when calling deleteDeviceIdentifier.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/device-identifiers/{deviceIdentifier}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'deviceIdentifier'}}`, encodeURIComponent(String(requestParameters.deviceIdentifier))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_DEVICE_IDENTIFIER[DELETE] permission on the specified domain or DOMAIN_DEVICE_IDENTIFIER[DELETE] permission on the specified environment or DOMAIN_DEVICE_IDENTIFIER[DELETE] permission on the specified organization
   * Delete a Device identifier
   */
  async deleteDeviceIdentifier(
    requestParameters: DeleteDeviceIdentifierRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.deleteDeviceIdentifierRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN[DELETE] permission on the specified domain or DOMAIN[DELETE] permission on the specified environment or DOMAIN[DELETE] permission on the specified organization.
   * Delete the security domain
   */
  async deleteDomainRaw(
    requestParameters: DeleteDomainRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteDomain.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteDomain.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteDomain.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN[DELETE] permission on the specified domain or DOMAIN[DELETE] permission on the specified environment or DOMAIN[DELETE] permission on the specified organization.
   * Delete the security domain
   */
  async deleteDomain(requestParameters: DeleteDomainRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.deleteDomainRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_EMAIL_TEMPLATE[DELETE] permission on the specified domain or DOMAIN_EMAIL_TEMPLATE[DELETE] permission on the specified environment or DOMAIN_EMAIL_TEMPLATE[DELETE] permission on the specified organization
   * Delete an email
   */
  async deleteDomainEmailRaw(
    requestParameters: DeleteDomainEmailRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteDomainEmail.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteDomainEmail.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteDomainEmail.',
      );
    }

    if (requestParameters.email === null || requestParameters.email === undefined) {
      throw new runtime.RequiredError(
        'email',
        'Required parameter requestParameters.email was null or undefined when calling deleteDomainEmail.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/emails/{email}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'email'}}`, encodeURIComponent(String(requestParameters.email))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_EMAIL_TEMPLATE[DELETE] permission on the specified domain or DOMAIN_EMAIL_TEMPLATE[DELETE] permission on the specified environment or DOMAIN_EMAIL_TEMPLATE[DELETE] permission on the specified organization
   * Delete an email
   */
  async deleteDomainEmail(
    requestParameters: DeleteDomainEmailRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.deleteDomainEmailRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_FORM[DELETE] permission on the specified domain or DOMAIN_FORM[DELETE] permission on the specified environment or DOMAIN_FORM[DELETE] permission on the specified organization
   * Delete a form
   */
  async deleteDomainFormRaw(
    requestParameters: DeleteDomainFormRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteDomainForm.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteDomainForm.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteDomainForm.',
      );
    }

    if (requestParameters.form === null || requestParameters.form === undefined) {
      throw new runtime.RequiredError(
        'form',
        'Required parameter requestParameters.form was null or undefined when calling deleteDomainForm.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/forms/{form}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'form'}}`, encodeURIComponent(String(requestParameters.form))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_FORM[DELETE] permission on the specified domain or DOMAIN_FORM[DELETE] permission on the specified environment or DOMAIN_FORM[DELETE] permission on the specified organization
   * Delete a form
   */
  async deleteDomainForm(
    requestParameters: DeleteDomainFormRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.deleteDomainFormRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_REPORTER[DELETE] permission on the specified domain or DOMAIN_REPORTER[DELETE] permission on the specified environment or DOMAIN_REPORTER[DELETE] permission on the specified organization
   * Delete a reporter
   */
  async deleteDomainReporterRaw(
    requestParameters: DeleteDomainReporterRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteDomainReporter.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteDomainReporter.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteDomainReporter.',
      );
    }

    if (requestParameters.reporter === null || requestParameters.reporter === undefined) {
      throw new runtime.RequiredError(
        'reporter',
        'Required parameter requestParameters.reporter was null or undefined when calling deleteDomainReporter.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/reporters/{reporter}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'reporter'}}`, encodeURIComponent(String(requestParameters.reporter))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_REPORTER[DELETE] permission on the specified domain or DOMAIN_REPORTER[DELETE] permission on the specified environment or DOMAIN_REPORTER[DELETE] permission on the specified organization
   * Delete a reporter
   */
  async deleteDomainReporter(
    requestParameters: DeleteDomainReporterRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.deleteDomainReporterRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_EXTENSION_GRANT[DELETE] permission on the specified domain or DOMAIN_EXTENSION_GRANT[DELETE] permission on the specified environment or DOMAIN_EXTENSION_GRANT[DELETE] permission on the specified organization
   * Delete a extension grant
   */
  async deleteExtensionGrantRaw(
    requestParameters: DeleteExtensionGrantRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteExtensionGrant.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteExtensionGrant.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteExtensionGrant.',
      );
    }

    if (requestParameters.extensionGrant === null || requestParameters.extensionGrant === undefined) {
      throw new runtime.RequiredError(
        'extensionGrant',
        'Required parameter requestParameters.extensionGrant was null or undefined when calling deleteExtensionGrant.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/extensionGrants/{extensionGrant}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'extensionGrant'}}`, encodeURIComponent(String(requestParameters.extensionGrant))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_EXTENSION_GRANT[DELETE] permission on the specified domain or DOMAIN_EXTENSION_GRANT[DELETE] permission on the specified environment or DOMAIN_EXTENSION_GRANT[DELETE] permission on the specified organization
   * Delete a extension grant
   */
  async deleteExtensionGrant(
    requestParameters: DeleteExtensionGrantRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.deleteExtensionGrantRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_FACTOR[DELETE] permission on the specified domain or DOMAIN_FACTOR[DELETE] permission on the specified environment or DOMAIN_FACTOR[DELETE] permission on the specified organization
   * Delete a factor
   */
  async deleteFactorRaw(
    requestParameters: DeleteFactorRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteFactor.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteFactor.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteFactor.',
      );
    }

    if (requestParameters.factor === null || requestParameters.factor === undefined) {
      throw new runtime.RequiredError(
        'factor',
        'Required parameter requestParameters.factor was null or undefined when calling deleteFactor.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/factors/{factor}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'factor'}}`, encodeURIComponent(String(requestParameters.factor))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_FACTOR[DELETE] permission on the specified domain or DOMAIN_FACTOR[DELETE] permission on the specified environment or DOMAIN_FACTOR[DELETE] permission on the specified organization
   * Delete a factor
   */
  async deleteFactor(requestParameters: DeleteFactorRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.deleteFactorRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_GROUP[DELETE] permission on the specified domain or DOMAIN_GROUP[DELETE] permission on the specified environment or DOMAIN_GROUP[DELETE] permission on the specified organization
   * Delete a group
   */
  async deleteGroupRaw(
    requestParameters: DeleteGroupRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteGroup.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteGroup.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteGroup.',
      );
    }

    if (requestParameters.group === null || requestParameters.group === undefined) {
      throw new runtime.RequiredError(
        'group',
        'Required parameter requestParameters.group was null or undefined when calling deleteGroup.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/groups/{group}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'group'}}`, encodeURIComponent(String(requestParameters.group))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_GROUP[DELETE] permission on the specified domain or DOMAIN_GROUP[DELETE] permission on the specified environment or DOMAIN_GROUP[DELETE] permission on the specified organization
   * Delete a group
   */
  async deleteGroup(requestParameters: DeleteGroupRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.deleteGroupRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_I18N_DICTIONARY[DELETE] permission on the specified domain or DOMAIN_I18N_DICTIONARY[DELETE] permission on the specified environment or DOMAIN_I18N_DICTIONARY[DELETE] permission on the specified organization.
   * Delete a i18n dictionary
   */
  async deleteI18nDictionaryRaw(
    requestParameters: DeleteI18nDictionaryRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteI18nDictionary.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteI18nDictionary.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteI18nDictionary.',
      );
    }

    if (requestParameters.dictionary === null || requestParameters.dictionary === undefined) {
      throw new runtime.RequiredError(
        'dictionary',
        'Required parameter requestParameters.dictionary was null or undefined when calling deleteI18nDictionary.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/i18n/dictionaries/{dictionary}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'dictionary'}}`, encodeURIComponent(String(requestParameters.dictionary))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_I18N_DICTIONARY[DELETE] permission on the specified domain or DOMAIN_I18N_DICTIONARY[DELETE] permission on the specified environment or DOMAIN_I18N_DICTIONARY[DELETE] permission on the specified organization.
   * Delete a i18n dictionary
   */
  async deleteI18nDictionary(
    requestParameters: DeleteI18nDictionaryRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.deleteI18nDictionaryRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_IDENTITY_PROVIDER[DELETE] permission on the specified domain or DOMAIN_IDENTITY_PROVIDER[DELETE] permission on the specified environment or DOMAIN_IDENTITY_PROVIDER[DELETE] permission on the specified organization
   * Delete an identity provider
   */
  async deleteIdentityProviderRaw(
    requestParameters: DeleteIdentityProviderRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteIdentityProvider.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteIdentityProvider.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteIdentityProvider.',
      );
    }

    if (requestParameters.identity === null || requestParameters.identity === undefined) {
      throw new runtime.RequiredError(
        'identity',
        'Required parameter requestParameters.identity was null or undefined when calling deleteIdentityProvider.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/identities/{identity}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'identity'}}`, encodeURIComponent(String(requestParameters.identity))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_IDENTITY_PROVIDER[DELETE] permission on the specified domain or DOMAIN_IDENTITY_PROVIDER[DELETE] permission on the specified environment or DOMAIN_IDENTITY_PROVIDER[DELETE] permission on the specified organization
   * Delete an identity provider
   */
  async deleteIdentityProvider(
    requestParameters: DeleteIdentityProviderRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.deleteIdentityProviderRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_SETTINGS[UPDATE] permission on the specified domain or DOMAIN_SETTINGS[UPDATE] permission on the specified environment or DOMAIN_SETTINGS[UPDATE] permission on the specified organization
   * Delete a password policy
   */
  async deletePasswordPolicyRaw(
    requestParameters: DeletePasswordPolicyRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deletePasswordPolicy.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deletePasswordPolicy.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deletePasswordPolicy.',
      );
    }

    if (requestParameters.policy === null || requestParameters.policy === undefined) {
      throw new runtime.RequiredError(
        'policy',
        'Required parameter requestParameters.policy was null or undefined when calling deletePasswordPolicy.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/password-policies/{policy}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'policy'}}`, encodeURIComponent(String(requestParameters.policy))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_SETTINGS[UPDATE] permission on the specified domain or DOMAIN_SETTINGS[UPDATE] permission on the specified environment or DOMAIN_SETTINGS[UPDATE] permission on the specified organization
   * Delete a password policy
   */
  async deletePasswordPolicy(
    requestParameters: DeletePasswordPolicyRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.deletePasswordPolicyRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_RESOURCE[DELETE] permission on the specified domain or DOMAIN_RESOURCE[DELETE] permission on the specified environment or DOMAIN_RESOURCE[DELETE] permission on the specified organization
   * Delete a resource
   */
  async deleteResourceRaw(
    requestParameters: DeleteResourceRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteResource.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteResource.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteResource.',
      );
    }

    if (requestParameters.resource === null || requestParameters.resource === undefined) {
      throw new runtime.RequiredError(
        'resource',
        'Required parameter requestParameters.resource was null or undefined when calling deleteResource.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/resources/{resource}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'resource'}}`, encodeURIComponent(String(requestParameters.resource))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_RESOURCE[DELETE] permission on the specified domain or DOMAIN_RESOURCE[DELETE] permission on the specified environment or DOMAIN_RESOURCE[DELETE] permission on the specified organization
   * Delete a resource
   */
  async deleteResource(requestParameters: DeleteResourceRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.deleteResourceRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_ROLE[DELETE] permission on the specified domain or DOMAIN_ROLE[DELETE] permission on the specified environment or DOMAIN_ROLE[DELETE] permission on the specified organization
   * Delete a role
   */
  async deleteRoleRaw(
    requestParameters: DeleteRoleRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteRole.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteRole.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteRole.',
      );
    }

    if (requestParameters.role === null || requestParameters.role === undefined) {
      throw new runtime.RequiredError('role', 'Required parameter requestParameters.role was null or undefined when calling deleteRole.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/roles/{role}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'role'}}`, encodeURIComponent(String(requestParameters.role))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_ROLE[DELETE] permission on the specified domain or DOMAIN_ROLE[DELETE] permission on the specified environment or DOMAIN_ROLE[DELETE] permission on the specified organization
   * Delete a role
   */
  async deleteRole(requestParameters: DeleteRoleRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.deleteRoleRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_SCOPE[DELETE] permission on the specified domain or DOMAIN_SCOPE[DELETE] permission on the specified environment or DOMAIN_SCOPE[DELETE] permission on the specified organization
   * Delete a scope
   */
  async deleteScopeRaw(
    requestParameters: DeleteScopeRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteScope.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteScope.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteScope.',
      );
    }

    if (requestParameters.scope === null || requestParameters.scope === undefined) {
      throw new runtime.RequiredError(
        'scope',
        'Required parameter requestParameters.scope was null or undefined when calling deleteScope.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/scopes/{scope}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'scope'}}`, encodeURIComponent(String(requestParameters.scope))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_SCOPE[DELETE] permission on the specified domain or DOMAIN_SCOPE[DELETE] permission on the specified environment or DOMAIN_SCOPE[DELETE] permission on the specified organization
   * Delete a scope
   */
  async deleteScope(requestParameters: DeleteScopeRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.deleteScopeRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_THEME[DELETE] permission on the specified domain or DOMAIN_THEME[DELETE] permission on the specified environment or DOMAIN_THEME[DELETE] permission on the specified organization
   * Delete a theme on the specified security domain
   */
  async deleteThemeRaw(
    requestParameters: DeleteThemeRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteTheme.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteTheme.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteTheme.',
      );
    }

    if (requestParameters.themeId === null || requestParameters.themeId === undefined) {
      throw new runtime.RequiredError(
        'themeId',
        'Required parameter requestParameters.themeId was null or undefined when calling deleteTheme.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/themes/{themeId}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'themeId'}}`, encodeURIComponent(String(requestParameters.themeId))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_THEME[DELETE] permission on the specified domain or DOMAIN_THEME[DELETE] permission on the specified environment or DOMAIN_THEME[DELETE] permission on the specified organization
   * Delete a theme on the specified security domain
   */
  async deleteTheme(requestParameters: DeleteThemeRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.deleteThemeRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_USER[DELETE] permission on the specified domain or DOMAIN_USER[DELETE] permission on the specified environment or DOMAIN_USER[DELETE] permission on the specified organization
   * Delete a user
   */
  async deleteUserRaw(
    requestParameters: DeleteUserRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteUser.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteUser.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteUser.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError('user', 'Required parameter requestParameters.user was null or undefined when calling deleteUser.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_USER[DELETE] permission on the specified domain or DOMAIN_USER[DELETE] permission on the specified environment or DOMAIN_USER[DELETE] permission on the specified organization
   * Delete a user
   */
  async deleteUser(requestParameters: DeleteUserRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.deleteUserRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_USER_DEVICE[DELETE] permission on the specified domain or DOMAIN_USER_DEVICE[DELETE] permission on the specified environment or DOMAIN_USER_DEVICE[DELETE] permission on the specified organization
   * Delete a device
   */
  async deleteUserDeviceRaw(
    requestParameters: DeleteUserDeviceRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteUserDevice.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteUserDevice.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteUserDevice.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling deleteUserDevice.',
      );
    }

    if (requestParameters.device === null || requestParameters.device === undefined) {
      throw new runtime.RequiredError(
        'device',
        'Required parameter requestParameters.device was null or undefined when calling deleteUserDevice.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/devices/{device}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user)))
          .replace(`{${'device'}}`, encodeURIComponent(String(requestParameters.device))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_USER_DEVICE[DELETE] permission on the specified domain or DOMAIN_USER_DEVICE[DELETE] permission on the specified environment or DOMAIN_USER_DEVICE[DELETE] permission on the specified organization
   * Delete a device
   */
  async deleteUserDevice(
    requestParameters: DeleteUserDeviceRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.deleteUserDeviceRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Revoke user factor
   */
  async deleteUserFactorRaw(
    requestParameters: DeleteUserFactorRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteUserFactor.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteUserFactor.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteUserFactor.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling deleteUserFactor.',
      );
    }

    if (requestParameters.factor === null || requestParameters.factor === undefined) {
      throw new runtime.RequiredError(
        'factor',
        'Required parameter requestParameters.factor was null or undefined when calling deleteUserFactor.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/factors/{factor}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user)))
          .replace(`{${'factor'}}`, encodeURIComponent(String(requestParameters.factor))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Revoke user factor
   */
  async deleteUserFactor(
    requestParameters: DeleteUserFactorRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.deleteUserFactorRaw(requestParameters, initOverrides);
  }

  /**
   */
  async evaluatePolicyRaw(
    requestParameters: EvaluatePolicyRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling evaluatePolicy.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling evaluatePolicy.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling evaluatePolicy.',
      );
    }

    if (requestParameters.policy === null || requestParameters.policy === undefined) {
      throw new runtime.RequiredError(
        'policy',
        'Required parameter requestParameters.policy was null or undefined when calling evaluatePolicy.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/password-policies/{policy}/evaluate`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'policy'}}`, encodeURIComponent(String(requestParameters.policy))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   */
  async evaluatePolicy(requestParameters: EvaluatePolicyRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.evaluatePolicyRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the APPLICATION[READ] permission on the specified application or APPLICATION[READ] permission on the specified domain or APPLICATION[READ] permission on the specified environment or APPLICATION[READ] permission on the specified organization. Application will be filtered according to permissions (READ on APPLICATION_IDENTITY_PROVIDER, APPLICATION_CERTIFICATE, APPLICATION_METADATA, APPLICATION_USER_ACCOUNT, APPLICATION_SETTINGS)
   * Get an application
   */
  async findApplicationRaw(
    requestParameters: FindApplicationRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Application>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling findApplication.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling findApplication.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling findApplication.',
      );
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling findApplication.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ApplicationFromJSON(jsonValue));
  }

  /**
   * User must have the APPLICATION[READ] permission on the specified application or APPLICATION[READ] permission on the specified domain or APPLICATION[READ] permission on the specified environment or APPLICATION[READ] permission on the specified organization. Application will be filtered according to permissions (READ on APPLICATION_IDENTITY_PROVIDER, APPLICATION_CERTIFICATE, APPLICATION_METADATA, APPLICATION_USER_ACCOUNT, APPLICATION_SETTINGS)
   * Get an application
   */
  async findApplication(
    requestParameters: FindApplicationRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Application> {
    const response = await this.findApplicationRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have APPLICATION_EMAIL_TEMPLATE[READ] permission on the specified application or APPLICATION_EMAIL_TEMPLATE[READ] permission on the specified domain or APPLICATION_EMAIL_TEMPLATE[READ] permission on the specified environment or APPLICATION_EMAIL_TEMPLATE[READ] permission on the specified organization
   * Find a email for an application
   */
  async findApplicationEmailRaw(
    requestParameters: FindApplicationEmailRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling findApplicationEmail.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling findApplicationEmail.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling findApplicationEmail.',
      );
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling findApplicationEmail.',
      );
    }

    if (requestParameters.template === null || requestParameters.template === undefined) {
      throw new runtime.RequiredError(
        'template',
        'Required parameter requestParameters.template was null or undefined when calling findApplicationEmail.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.template !== undefined) {
      queryParameters['template'] = requestParameters.template;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/emails`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have APPLICATION_EMAIL_TEMPLATE[READ] permission on the specified application or APPLICATION_EMAIL_TEMPLATE[READ] permission on the specified domain or APPLICATION_EMAIL_TEMPLATE[READ] permission on the specified environment or APPLICATION_EMAIL_TEMPLATE[READ] permission on the specified organization
   * Find a email for an application
   */
  async findApplicationEmail(
    requestParameters: FindApplicationEmailRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.findApplicationEmailRaw(requestParameters, initOverrides);
  }

  /**
   * User must have APPLICATION_FORM[READ] permission on the specified application or APPLICATION_FORM[READ] permission on the specified domain or APPLICATION_FORM[READ] permission on the specified environment or APPLICATION_FORM[READ] permission on the specified organization
   * Find a form for an application
   */
  async findApplicationFormRaw(
    requestParameters: FindApplicationFormRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling findApplicationForm.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling findApplicationForm.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling findApplicationForm.',
      );
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling findApplicationForm.',
      );
    }

    if (requestParameters.template === null || requestParameters.template === undefined) {
      throw new runtime.RequiredError(
        'template',
        'Required parameter requestParameters.template was null or undefined when calling findApplicationForm.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.template !== undefined) {
      queryParameters['template'] = requestParameters.template;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/forms`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have APPLICATION_FORM[READ] permission on the specified application or APPLICATION_FORM[READ] permission on the specified domain or APPLICATION_FORM[READ] permission on the specified environment or APPLICATION_FORM[READ] permission on the specified organization
   * Find a form for an application
   */
  async findApplicationForm(
    requestParameters: FindApplicationFormRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.findApplicationFormRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_AUTHORIZATION_ENGINE[READ] permission on the specified domain or DOMAIN_AUTHORIZATION_ENGINE[READ] permission on the specified environment or DOMAIN_AUTHORIZATION_ENGINE[READ] permission on the specified organization
   * Get an authorization engine
   */
  async findAuthorizationEngineRaw(
    requestParameters: FindAuthorizationEngineRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<AuthorizationEngine>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling findAuthorizationEngine.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling findAuthorizationEngine.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling findAuthorizationEngine.',
      );
    }

    if (requestParameters.engineId === null || requestParameters.engineId === undefined) {
      throw new runtime.RequiredError(
        'engineId',
        'Required parameter requestParameters.engineId was null or undefined when calling findAuthorizationEngine.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/authorization-engines/{engineId}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'engineId'}}`, encodeURIComponent(String(requestParameters.engineId))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => AuthorizationEngineFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_AUTHORIZATION_ENGINE[READ] permission on the specified domain or DOMAIN_AUTHORIZATION_ENGINE[READ] permission on the specified environment or DOMAIN_AUTHORIZATION_ENGINE[READ] permission on the specified organization
   * Get an authorization engine
   */
  async findAuthorizationEngine(
    requestParameters: FindAuthorizationEngineRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<AuthorizationEngine> {
    const response = await this.findAuthorizationEngineRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_CERTIFICATE[READ] permission on the specified domain or DOMAIN_CERTIFICATE[READ] permission on the specified environment or DOMAIN_CERTIFICATE[READ] permission on the specified organization
   * Get a certificate
   */
  async findCertificateRaw(
    requestParameters: FindCertificateRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<CertificateEntity>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling findCertificate.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling findCertificate.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling findCertificate.',
      );
    }

    if (requestParameters.certificate === null || requestParameters.certificate === undefined) {
      throw new runtime.RequiredError(
        'certificate',
        'Required parameter requestParameters.certificate was null or undefined when calling findCertificate.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/certificates/{certificate}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'certificate'}}`, encodeURIComponent(String(requestParameters.certificate))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => CertificateEntityFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_CERTIFICATE[READ] permission on the specified domain or DOMAIN_CERTIFICATE[READ] permission on the specified environment or DOMAIN_CERTIFICATE[READ] permission on the specified organization
   * Get a certificate
   */
  async findCertificate(
    requestParameters: FindCertificateRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<CertificateEntity> {
    const response = await this.findCertificateRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN[READ] permission on the specified domain, environment or organization. Domain will be filtered according to permissions (READ on DOMAIN_USER_ACCOUNT, DOMAIN_IDENTITY_PROVIDER, DOMAIN_FORM, DOMAIN_LOGIN_SETTINGS, DOMAIN_DCR, DOMAIN_SCIM, DOMAIN_SETTINGS)
   * Get a security domain
   */
  async findDomainRaw(
    requestParameters: FindDomainRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Domain>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling findDomain.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling findDomain.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling findDomain.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => DomainFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN[READ] permission on the specified domain, environment or organization. Domain will be filtered according to permissions (READ on DOMAIN_USER_ACCOUNT, DOMAIN_IDENTITY_PROVIDER, DOMAIN_FORM, DOMAIN_LOGIN_SETTINGS, DOMAIN_DCR, DOMAIN_SCIM, DOMAIN_SETTINGS)
   * Get a security domain
   */
  async findDomain(requestParameters: FindDomainRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Domain> {
    const response = await this.findDomainRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have DOMAIN_ANALYTICS[READ] permission on the specified domain or DOMAIN_ANALYTICS[READ] permission on the specified environment or DOMAIN_ANALYTICS[READ] permission on the specified organization
   * Find domain analytics
   */
  async findDomainAnalyticsRaw(
    requestParameters: FindDomainAnalyticsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling findDomainAnalytics.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling findDomainAnalytics.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling findDomainAnalytics.',
      );
    }

    if (requestParameters.type === null || requestParameters.type === undefined) {
      throw new runtime.RequiredError(
        'type',
        'Required parameter requestParameters.type was null or undefined when calling findDomainAnalytics.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.from !== undefined) {
      queryParameters['from'] = requestParameters.from;
    }

    if (requestParameters.to !== undefined) {
      queryParameters['to'] = requestParameters.to;
    }

    if (requestParameters.interval !== undefined) {
      queryParameters['interval'] = requestParameters.interval;
    }

    if (requestParameters.size !== undefined) {
      queryParameters['size'] = requestParameters.size;
    }

    if (requestParameters.type !== undefined) {
      queryParameters['type'] = requestParameters.type;
    }

    if (requestParameters.field !== undefined) {
      queryParameters['field'] = requestParameters.field;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/analytics`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have DOMAIN_ANALYTICS[READ] permission on the specified domain or DOMAIN_ANALYTICS[READ] permission on the specified environment or DOMAIN_ANALYTICS[READ] permission on the specified organization
   * Find domain analytics
   */
  async findDomainAnalytics(
    requestParameters: FindDomainAnalyticsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.findDomainAnalyticsRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN[READ] permission on the specified domain, environment or organization. Domain will be filtered according to permissions (READ on DOMAIN_USER_ACCOUNT, DOMAIN_IDENTITY_PROVIDER, DOMAIN_FORM, DOMAIN_LOGIN_SETTINGS, DOMAIN_DCR, DOMAIN_SCIM, DOMAIN_SETTINGS)
   * Get a security domain by hrid
   */
  async findDomainByHridRaw(
    requestParameters: FindDomainByHridRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Domain>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling findDomainByHrid.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling findDomainByHrid.',
      );
    }

    if (requestParameters.hrid === null || requestParameters.hrid === undefined) {
      throw new runtime.RequiredError(
        'hrid',
        'Required parameter requestParameters.hrid was null or undefined when calling findDomainByHrid.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/_hrid/{hrid}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'hrid'}}`, encodeURIComponent(String(requestParameters.hrid))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => DomainFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN[READ] permission on the specified domain, environment or organization. Domain will be filtered according to permissions (READ on DOMAIN_USER_ACCOUNT, DOMAIN_IDENTITY_PROVIDER, DOMAIN_FORM, DOMAIN_LOGIN_SETTINGS, DOMAIN_DCR, DOMAIN_SCIM, DOMAIN_SETTINGS)
   * Get a security domain by hrid
   */
  async findDomainByHrid(
    requestParameters: FindDomainByHridRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Domain> {
    const response = await this.findDomainByHridRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_EMAIL_TEMPLATE[READ] permission on the specified domain or DOMAIN_EMAIL_TEMPLATE[READ] permission on the specified environment or DOMAIN_EMAIL_TEMPLATE[READ] permission on the specified organization
   * Find a email
   */
  async findEmailRaw(
    requestParameters: FindEmailRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling findEmail.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling findEmail.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling findEmail.',
      );
    }

    if (requestParameters.template === null || requestParameters.template === undefined) {
      throw new runtime.RequiredError(
        'template',
        'Required parameter requestParameters.template was null or undefined when calling findEmail.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.template !== undefined) {
      queryParameters['template'] = requestParameters.template;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/emails`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_EMAIL_TEMPLATE[READ] permission on the specified domain or DOMAIN_EMAIL_TEMPLATE[READ] permission on the specified environment or DOMAIN_EMAIL_TEMPLATE[READ] permission on the specified organization
   * Find a email
   */
  async findEmail(requestParameters: FindEmailRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.findEmailRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_FORM[READ] permission on the specified domain or DOMAIN_FORM[READ] permission on the specified environment or DOMAIN_FORM[READ] permission on the specified organization
   * Find a form
   */
  async findFormRaw(
    requestParameters: FindFormRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling findForm.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling findForm.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling findForm.');
    }

    if (requestParameters.template === null || requestParameters.template === undefined) {
      throw new runtime.RequiredError(
        'template',
        'Required parameter requestParameters.template was null or undefined when calling findForm.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.template !== undefined) {
      queryParameters['template'] = requestParameters.template;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/forms`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_FORM[READ] permission on the specified domain or DOMAIN_FORM[READ] permission on the specified environment or DOMAIN_FORM[READ] permission on the specified organization
   * Find a form
   */
  async findForm(requestParameters: FindFormRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.findFormRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_GROUP[READ] permission on the specified domain or DOMAIN_GROUP[READ] permission on the specified environment or DOMAIN_GROUP[READ] permission on the specified organization
   * Get a group
   */
  async findGroupRaw(
    requestParameters: FindGroupRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Group>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling findGroup.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling findGroup.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling findGroup.',
      );
    }

    if (requestParameters.group === null || requestParameters.group === undefined) {
      throw new runtime.RequiredError('group', 'Required parameter requestParameters.group was null or undefined when calling findGroup.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/groups/{group}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'group'}}`, encodeURIComponent(String(requestParameters.group))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => GroupFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_GROUP[READ] permission on the specified domain or DOMAIN_GROUP[READ] permission on the specified environment or DOMAIN_GROUP[READ] permission on the specified organization
   * Get a group
   */
  async findGroup(requestParameters: FindGroupRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Group> {
    const response = await this.findGroupRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_GROUP[READ] permission on the specified domain or DOMAIN_GROUP[READ] permission on the specified environment or DOMAIN_GROUP[READ] permission on the specified organization
   * Get a group roles
   */
  async findGroupRolesRaw(
    requestParameters: FindGroupRolesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<Role>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling findGroupRoles.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling findGroupRoles.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling findGroupRoles.',
      );
    }

    if (requestParameters.group === null || requestParameters.group === undefined) {
      throw new runtime.RequiredError(
        'group',
        'Required parameter requestParameters.group was null or undefined when calling findGroupRoles.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/groups/{group}/roles`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'group'}}`, encodeURIComponent(String(requestParameters.group))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(RoleFromJSON));
  }

  /**
   * User must have the DOMAIN_GROUP[READ] permission on the specified domain or DOMAIN_GROUP[READ] permission on the specified environment or DOMAIN_GROUP[READ] permission on the specified organization
   * Get a group roles
   */
  async findGroupRoles(
    requestParameters: FindGroupRolesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<Role>> {
    const response = await this.findGroupRolesRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_IDENTITY_PROVIDER[READ] permission on the specified domain or DOMAIN_IDENTITY_PROVIDER[READ] permission on the specified environment or DOMAIN_IDENTITY_PROVIDER[READ] permission on the specified organization
   * Get an identity provider
   */
  async findIdentityProviderRaw(
    requestParameters: FindIdentityProviderRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<IdentityProvider>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling findIdentityProvider.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling findIdentityProvider.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling findIdentityProvider.',
      );
    }

    if (requestParameters.identity === null || requestParameters.identity === undefined) {
      throw new runtime.RequiredError(
        'identity',
        'Required parameter requestParameters.identity was null or undefined when calling findIdentityProvider.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/identities/{identity}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'identity'}}`, encodeURIComponent(String(requestParameters.identity))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => IdentityProviderFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_IDENTITY_PROVIDER[READ] permission on the specified domain or DOMAIN_IDENTITY_PROVIDER[READ] permission on the specified environment or DOMAIN_IDENTITY_PROVIDER[READ] permission on the specified organization
   * Get an identity provider
   */
  async findIdentityProvider(
    requestParameters: FindIdentityProviderRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<IdentityProvider> {
    const response = await this.findIdentityProviderRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the PROTECTED_RESOURCE[READ] permission on the specified resource or PROTECTED_RESOURCE[READ] permission on the specified domain or PROTECTED_RESOURCE[READ] permission on the specified environment or PROTECTED_RESOURCE[READ] permission on the specified organization.
   * Get a Protected Resource
   */
  async findProtectedResourceRaw(
    requestParameters: FindProtectedResourceRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ProtectedResourcePrimaryData>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling findProtectedResource.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling findProtectedResource.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling findProtectedResource.',
      );
    }

    if (requestParameters.protectedResource === null || requestParameters.protectedResource === undefined) {
      throw new runtime.RequiredError(
        'protectedResource',
        'Required parameter requestParameters.protectedResource was null or undefined when calling findProtectedResource.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.type !== undefined) {
      queryParameters['type'] = requestParameters.type;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/protected-resources/{protected-resource}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'protected-resource'}}`, encodeURIComponent(String(requestParameters.protectedResource))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ProtectedResourcePrimaryDataFromJSON(jsonValue));
  }

  /**
   * User must have the PROTECTED_RESOURCE[READ] permission on the specified resource or PROTECTED_RESOURCE[READ] permission on the specified domain or PROTECTED_RESOURCE[READ] permission on the specified environment or PROTECTED_RESOURCE[READ] permission on the specified organization.
   * Get a Protected Resource
   */
  async findProtectedResource(
    requestParameters: FindProtectedResourceRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<ProtectedResourcePrimaryData> {
    const response = await this.findProtectedResourceRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_ROLE[READ] permission on the specified domain or DOMAIN_ROLE[READ] permission on the specified environment or DOMAIN_ROLE[READ] permission on the specified organization
   * Get a role
   */
  async findRoleRaw(
    requestParameters: FindRoleRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<RoleEntity>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling findRole.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling findRole.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling findRole.');
    }

    if (requestParameters.role === null || requestParameters.role === undefined) {
      throw new runtime.RequiredError('role', 'Required parameter requestParameters.role was null or undefined when calling findRole.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/roles/{role}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'role'}}`, encodeURIComponent(String(requestParameters.role))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => RoleEntityFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_ROLE[READ] permission on the specified domain or DOMAIN_ROLE[READ] permission on the specified environment or DOMAIN_ROLE[READ] permission on the specified organization
   * Get a role
   */
  async findRole(requestParameters: FindRoleRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<RoleEntity> {
    const response = await this.findRoleRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_ROLE[LIST] permission on the specified domain or DOMAIN_ROLE[LIST] permission on the specified environment or DOMAIN_ROLE[LIST] permission on the specified organization. Each returned role is filtered and contains only basic information such as id and name.
   * List registered roles for a security domain
   */
  async findRolesRaw(
    requestParameters: FindRolesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<RolePage>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling findRoles.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling findRoles.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling findRoles.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.page !== undefined) {
      queryParameters['page'] = requestParameters.page;
    }

    if (requestParameters.size !== undefined) {
      queryParameters['size'] = requestParameters.size;
    }

    if (requestParameters.q !== undefined) {
      queryParameters['q'] = requestParameters.q;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/roles`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => RolePageFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_ROLE[LIST] permission on the specified domain or DOMAIN_ROLE[LIST] permission on the specified environment or DOMAIN_ROLE[LIST] permission on the specified organization. Each returned role is filtered and contains only basic information such as id and name.
   * List registered roles for a security domain
   */
  async findRoles(requestParameters: FindRolesRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<RolePage> {
    const response = await this.findRolesRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_SCOPE[READ] permission on the specified domain or DOMAIN_SCOPE[READ] permission on the specified environment or DOMAIN_SCOPE[READ] permission on the specified organization
   * Get a scope
   */
  async findScopeRaw(
    requestParameters: FindScopeRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Scope>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling findScope.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling findScope.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling findScope.',
      );
    }

    if (requestParameters.scope === null || requestParameters.scope === undefined) {
      throw new runtime.RequiredError('scope', 'Required parameter requestParameters.scope was null or undefined when calling findScope.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/scopes/{scope}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'scope'}}`, encodeURIComponent(String(requestParameters.scope))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ScopeFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_SCOPE[READ] permission on the specified domain or DOMAIN_SCOPE[READ] permission on the specified environment or DOMAIN_SCOPE[READ] permission on the specified organization
   * Get a scope
   */
  async findScope(requestParameters: FindScopeRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Scope> {
    const response = await this.findScopeRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user
   */
  async findUserRaw(
    requestParameters: FindUserRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<UserEntity>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling findUser.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling findUser.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling findUser.');
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError('user', 'Required parameter requestParameters.user was null or undefined when calling findUser.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => UserEntityFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user
   */
  async findUser(requestParameters: FindUserRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<UserEntity> {
    const response = await this.findUserRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Get an alert notifier by its id. User must have DOMAIN_ALERT_NOTIFIER[LIST] permission on the specified domain, environment or organization.
   * Get an alert notifier
   */
  async getAlertNotifierRaw(
    requestParameters: GetAlertNotifierRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<AlertNotifier>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getAlertNotifier.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getAlertNotifier.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getAlertNotifier.',
      );
    }

    if (requestParameters.notifierId === null || requestParameters.notifierId === undefined) {
      throw new runtime.RequiredError(
        'notifierId',
        'Required parameter requestParameters.notifierId was null or undefined when calling getAlertNotifier.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/alerts/notifiers/{notifierId}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'notifierId'}}`, encodeURIComponent(String(requestParameters.notifierId))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => AlertNotifierFromJSON(jsonValue));
  }

  /**
   * Get an alert notifier by its id. User must have DOMAIN_ALERT_NOTIFIER[LIST] permission on the specified domain, environment or organization.
   * Get an alert notifier
   */
  async getAlertNotifier(
    requestParameters: GetAlertNotifierRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<AlertNotifier> {
    const response = await this.getAlertNotifierRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the APPLICATION_FLOW[READ] permission on the specified domain or APPLICATION_FLOW[READ] permission on the specified environment or APPLICATION_FLOW[READ] permission on the specified organization
   * Get a flow
   */
  async getAppFlowRaw(
    requestParameters: GetAppFlowRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<FlowEntity>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getAppFlow.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getAppFlow.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getAppFlow.',
      );
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling getAppFlow.',
      );
    }

    if (requestParameters.flow === null || requestParameters.flow === undefined) {
      throw new runtime.RequiredError('flow', 'Required parameter requestParameters.flow was null or undefined when calling getAppFlow.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/flows/{flow}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application)))
          .replace(`{${'flow'}}`, encodeURIComponent(String(requestParameters.flow))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => FlowEntityFromJSON(jsonValue));
  }

  /**
   * User must have the APPLICATION_FLOW[READ] permission on the specified domain or APPLICATION_FLOW[READ] permission on the specified environment or APPLICATION_FLOW[READ] permission on the specified organization
   * Get a flow
   */
  async getAppFlow(requestParameters: GetAppFlowRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<FlowEntity> {
    const response = await this.getAppFlowRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have APPLICATION_ANALYTICS[READ] permission on the specified application or APPLICATION_ANALYTICS[READ] permission on the specified domain or APPLICATION_ANALYTICS[READ] permission on the specified environment or APPLICATION_ANALYTICS[READ] permission on the specified organization
   * Find application analytics
   */
  async getApplicationAnalyticsRaw(
    requestParameters: GetApplicationAnalyticsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getApplicationAnalytics.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getApplicationAnalytics.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getApplicationAnalytics.',
      );
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling getApplicationAnalytics.',
      );
    }

    if (requestParameters.type === null || requestParameters.type === undefined) {
      throw new runtime.RequiredError(
        'type',
        'Required parameter requestParameters.type was null or undefined when calling getApplicationAnalytics.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.from !== undefined) {
      queryParameters['from'] = requestParameters.from;
    }

    if (requestParameters.to !== undefined) {
      queryParameters['to'] = requestParameters.to;
    }

    if (requestParameters.interval !== undefined) {
      queryParameters['interval'] = requestParameters.interval;
    }

    if (requestParameters.size !== undefined) {
      queryParameters['size'] = requestParameters.size;
    }

    if (requestParameters.type !== undefined) {
      queryParameters['type'] = requestParameters.type;
    }

    if (requestParameters.field !== undefined) {
      queryParameters['field'] = requestParameters.field;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/analytics`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have APPLICATION_ANALYTICS[READ] permission on the specified application or APPLICATION_ANALYTICS[READ] permission on the specified domain or APPLICATION_ANALYTICS[READ] permission on the specified environment or APPLICATION_ANALYTICS[READ] permission on the specified organization
   * Find application analytics
   */
  async getApplicationAnalytics(
    requestParameters: GetApplicationAnalyticsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.getApplicationAnalyticsRaw(requestParameters, initOverrides);
  }

  /**
   * User must have APPLICATION_RESOURCE[READ] permission on the specified application or APPLICATION_RESOURCE[READ] permission on the specified domain or APPLICATION_RESOURCE[READ] permission on the specified environment or APPLICATION_RESOURCE[READ] permission on the specified organization
   * Get a resource for an application
   */
  async getApplicationResourceRaw(
    requestParameters: GetApplicationResourceRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Resource>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getApplicationResource.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getApplicationResource.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getApplicationResource.',
      );
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling getApplicationResource.',
      );
    }

    if (requestParameters.resource === null || requestParameters.resource === undefined) {
      throw new runtime.RequiredError(
        'resource',
        'Required parameter requestParameters.resource was null or undefined when calling getApplicationResource.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/resources/{resource}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application)))
          .replace(`{${'resource'}}`, encodeURIComponent(String(requestParameters.resource))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ResourceFromJSON(jsonValue));
  }

  /**
   * User must have APPLICATION_RESOURCE[READ] permission on the specified application or APPLICATION_RESOURCE[READ] permission on the specified domain or APPLICATION_RESOURCE[READ] permission on the specified environment or APPLICATION_RESOURCE[READ] permission on the specified organization
   * Get a resource for an application
   */
  async getApplicationResource(
    requestParameters: GetApplicationResourceRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Resource> {
    const response = await this.getApplicationResourceRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have APPLICATION_RESOURCE[READ] permission on the specified application or APPLICATION_RESOURCE[READ] permission on the specified domain or APPLICATION_RESOURCE[READ] permission on the specified environment or APPLICATION_RESOURCE[READ] permission on the specified organization
   * Get resource access policy
   */
  async getApplicationResourcePolicyRaw(
    requestParameters: GetApplicationResourcePolicyRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<AccessPolicy>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getApplicationResourcePolicy.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getApplicationResourcePolicy.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getApplicationResourcePolicy.',
      );
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling getApplicationResourcePolicy.',
      );
    }

    if (requestParameters.resource === null || requestParameters.resource === undefined) {
      throw new runtime.RequiredError(
        'resource',
        'Required parameter requestParameters.resource was null or undefined when calling getApplicationResourcePolicy.',
      );
    }

    if (requestParameters.policy === null || requestParameters.policy === undefined) {
      throw new runtime.RequiredError(
        'policy',
        'Required parameter requestParameters.policy was null or undefined when calling getApplicationResourcePolicy.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/resources/{resource}/policies/{policy}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application)))
          .replace(`{${'resource'}}`, encodeURIComponent(String(requestParameters.resource)))
          .replace(`{${'policy'}}`, encodeURIComponent(String(requestParameters.policy))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => AccessPolicyFromJSON(jsonValue));
  }

  /**
   * User must have APPLICATION_RESOURCE[READ] permission on the specified application or APPLICATION_RESOURCE[READ] permission on the specified domain or APPLICATION_RESOURCE[READ] permission on the specified environment or APPLICATION_RESOURCE[READ] permission on the specified organization
   * Get resource access policy
   */
  async getApplicationResourcePolicy(
    requestParameters: GetApplicationResourcePolicyRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<AccessPolicy> {
    const response = await this.getApplicationResourcePolicyRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_AUTHDEVICE_NOTIFIER[READ] permission on the specified domain or DOMAIN_AUTHDEVICE_NOTIFIER[READ] permission on the specified environment or DOMAIN_AUTHDEVICE_NOTIFIER[READ] permission on the specified organization
   * Get an Authentication Device Notifier
   */
  async getAuthenticationDeviceNotifierRaw(
    requestParameters: GetAuthenticationDeviceNotifierRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<AuthenticationDeviceNotifier>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getAuthenticationDeviceNotifier.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getAuthenticationDeviceNotifier.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getAuthenticationDeviceNotifier.',
      );
    }

    if (requestParameters.authDeviceNotifier === null || requestParameters.authDeviceNotifier === undefined) {
      throw new runtime.RequiredError(
        'authDeviceNotifier',
        'Required parameter requestParameters.authDeviceNotifier was null or undefined when calling getAuthenticationDeviceNotifier.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/auth-device-notifiers/{authDeviceNotifier}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'authDeviceNotifier'}}`, encodeURIComponent(String(requestParameters.authDeviceNotifier))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => AuthenticationDeviceNotifierFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_AUTHDEVICE_NOTIFIER[READ] permission on the specified domain or DOMAIN_AUTHDEVICE_NOTIFIER[READ] permission on the specified environment or DOMAIN_AUTHDEVICE_NOTIFIER[READ] permission on the specified organization
   * Get an Authentication Device Notifier
   */
  async getAuthenticationDeviceNotifier(
    requestParameters: GetAuthenticationDeviceNotifierRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<AuthenticationDeviceNotifier> {
    const response = await this.getAuthenticationDeviceNotifierRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_BOT_DETECTION[READ] permission on the specified domain or DOMAIN_BOT_DETECTION[READ] permission on the specified environment or DOMAIN_BOT_DETECTION[READ] permission on the specified organization
   * Get a bot detection
   */
  async getBotDetectionRaw(
    requestParameters: GetBotDetectionRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<BotDetection>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getBotDetection.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getBotDetection.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getBotDetection.',
      );
    }

    if (requestParameters.botDetection === null || requestParameters.botDetection === undefined) {
      throw new runtime.RequiredError(
        'botDetection',
        'Required parameter requestParameters.botDetection was null or undefined when calling getBotDetection.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/bot-detections/{botDetection}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'botDetection'}}`, encodeURIComponent(String(requestParameters.botDetection))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => BotDetectionFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_BOT_DETECTION[READ] permission on the specified domain or DOMAIN_BOT_DETECTION[READ] permission on the specified environment or DOMAIN_BOT_DETECTION[READ] permission on the specified organization
   * Get a bot detection
   */
  async getBotDetection(
    requestParameters: GetBotDetectionRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<BotDetection> {
    const response = await this.getBotDetectionRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN[READ] permission on the specified domain or DOMAIN[READ] permission on the specified environment or DOMAIN[READ] permission on the specified organization
   * Get the certificate public key
   */
  async getCertificatePublicKeyRaw(
    requestParameters: GetCertificatePublicKeyRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getCertificatePublicKey.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getCertificatePublicKey.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getCertificatePublicKey.',
      );
    }

    if (requestParameters.certificate === null || requestParameters.certificate === undefined) {
      throw new runtime.RequiredError(
        'certificate',
        'Required parameter requestParameters.certificate was null or undefined when calling getCertificatePublicKey.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/certificates/{certificate}/key`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'certificate'}}`, encodeURIComponent(String(requestParameters.certificate))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.TextApiResponse(response) as any;
  }

  /**
   * User must have the DOMAIN[READ] permission on the specified domain or DOMAIN[READ] permission on the specified environment or DOMAIN[READ] permission on the specified organization
   * Get the certificate public key
   */
  async getCertificatePublicKey(
    requestParameters: GetCertificatePublicKeyRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<string> {
    const response = await this.getCertificatePublicKeyRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN[READ] permission on the specified domain or DOMAIN[READ] permission on the specified environment or DOMAIN[READ] permission on the specified organization
   * Get the certificate public keys
   */
  async getCertificatePublicKeysRaw(
    requestParameters: GetCertificatePublicKeysRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<CertificateKey>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getCertificatePublicKeys.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getCertificatePublicKeys.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getCertificatePublicKeys.',
      );
    }

    if (requestParameters.certificate === null || requestParameters.certificate === undefined) {
      throw new runtime.RequiredError(
        'certificate',
        'Required parameter requestParameters.certificate was null or undefined when calling getCertificatePublicKeys.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/certificates/{certificate}/keys`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'certificate'}}`, encodeURIComponent(String(requestParameters.certificate))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CertificateKeyFromJSON));
  }

  /**
   * User must have the DOMAIN[READ] permission on the specified domain or DOMAIN[READ] permission on the specified environment or DOMAIN[READ] permission on the specified organization
   * Get the certificate public keys
   */
  async getCertificatePublicKeys(
    requestParameters: GetCertificatePublicKeysRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<CertificateKey>> {
    const response = await this.getCertificatePublicKeysRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_DEVICE_IDENTIFIER[READ] permission on the specified domain or DOMAIN_DEVICE_IDENTIFIER[READ] permission on the specified environment or DOMAIN_DEVICE_IDENTIFIER[READ] permission on the specified organization
   * Get a Device identifier
   */
  async getDeviceIdentifierRaw(
    requestParameters: GetDeviceIdentifierRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<DeviceIdentifier>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getDeviceIdentifier.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getDeviceIdentifier.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getDeviceIdentifier.',
      );
    }

    if (requestParameters.deviceIdentifier === null || requestParameters.deviceIdentifier === undefined) {
      throw new runtime.RequiredError(
        'deviceIdentifier',
        'Required parameter requestParameters.deviceIdentifier was null or undefined when calling getDeviceIdentifier.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/device-identifiers/{deviceIdentifier}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'deviceIdentifier'}}`, encodeURIComponent(String(requestParameters.deviceIdentifier))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => DeviceIdentifierFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_DEVICE_IDENTIFIER[READ] permission on the specified domain or DOMAIN_DEVICE_IDENTIFIER[READ] permission on the specified environment or DOMAIN_DEVICE_IDENTIFIER[READ] permission on the specified organization
   * Get a Device identifier
   */
  async getDeviceIdentifier(
    requestParameters: GetDeviceIdentifierRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<DeviceIdentifier> {
    const response = await this.getDeviceIdentifierRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_AUDIT[READ] permission on the specified domain or DOMAIN_AUDIT[READ] permission on the specified environment or DOMAIN_AUDIT[READ] permission on the specified organization
   * Get an audit log
   */
  async getDomainAuditRaw(
    requestParameters: GetDomainAuditRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Audit>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getDomainAudit.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getDomainAudit.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getDomainAudit.',
      );
    }

    if (requestParameters.audit === null || requestParameters.audit === undefined) {
      throw new runtime.RequiredError(
        'audit',
        'Required parameter requestParameters.audit was null or undefined when calling getDomainAudit.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/audits/{audit}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'audit'}}`, encodeURIComponent(String(requestParameters.audit))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => AuditFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_AUDIT[READ] permission on the specified domain or DOMAIN_AUDIT[READ] permission on the specified environment or DOMAIN_AUDIT[READ] permission on the specified organization
   * Get an audit log
   */
  async getDomainAudit(
    requestParameters: GetDomainAuditRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Audit> {
    const response = await this.getDomainAuditRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN[READ] permission on the specified domain, environment or organization. Domain will be filtered according to permissions (READ on DOMAIN_USER_ACCOUNT, DOMAIN_IDENTITY_PROVIDER, DOMAIN_FORM, DOMAIN_LOGIN_SETTINGS, DOMAIN_DCR, DOMAIN_SCIM, DOMAIN_SETTINGS)
   * Get the matching gateway entrypoint of the domain
   */
  async getDomainEntrypointsRaw(
    requestParameters: GetDomainEntrypointsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<Entrypoint>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getDomainEntrypoints.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getDomainEntrypoints.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getDomainEntrypoints.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/entrypoints`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(EntrypointFromJSON));
  }

  /**
   * User must have the DOMAIN[READ] permission on the specified domain, environment or organization. Domain will be filtered according to permissions (READ on DOMAIN_USER_ACCOUNT, DOMAIN_IDENTITY_PROVIDER, DOMAIN_FORM, DOMAIN_LOGIN_SETTINGS, DOMAIN_DCR, DOMAIN_SCIM, DOMAIN_SETTINGS)
   * Get the matching gateway entrypoint of the domain
   */
  async getDomainEntrypoints(
    requestParameters: GetDomainEntrypointsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<Entrypoint>> {
    const response = await this.getDomainEntrypointsRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_FLOW[READ] permission on the specified domain or DOMAIN_FLOW[READ] permission on the specified environment or DOMAIN_FLOW[READ] permission on the specified organization
   * Get a flow
   */
  async getDomainFlowRaw(
    requestParameters: GetDomainFlowRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<FlowEntity>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getDomainFlow.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getDomainFlow.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getDomainFlow.',
      );
    }

    if (requestParameters.flow === null || requestParameters.flow === undefined) {
      throw new runtime.RequiredError(
        'flow',
        'Required parameter requestParameters.flow was null or undefined when calling getDomainFlow.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/flows/{flow}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'flow'}}`, encodeURIComponent(String(requestParameters.flow))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => FlowEntityFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_FLOW[READ] permission on the specified domain or DOMAIN_FLOW[READ] permission on the specified environment or DOMAIN_FLOW[READ] permission on the specified organization
   * Get a flow
   */
  async getDomainFlow(
    requestParameters: GetDomainFlowRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<FlowEntity> {
    const response = await this.getDomainFlowRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_REPORTER[READ] permission on the specified domain or DOMAIN_REPORTER[READ] permission on the specified environment or DOMAIN_REPORTER[READ] permission on the specified organization
   * Get a reporter
   */
  async getDomainReporterRaw(
    requestParameters: GetDomainReporterRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Reporter>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getDomainReporter.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getDomainReporter.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getDomainReporter.',
      );
    }

    if (requestParameters.reporter === null || requestParameters.reporter === undefined) {
      throw new runtime.RequiredError(
        'reporter',
        'Required parameter requestParameters.reporter was null or undefined when calling getDomainReporter.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/reporters/{reporter}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'reporter'}}`, encodeURIComponent(String(requestParameters.reporter))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ReporterFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_REPORTER[READ] permission on the specified domain or DOMAIN_REPORTER[READ] permission on the specified environment or DOMAIN_REPORTER[READ] permission on the specified organization
   * Get a reporter
   */
  async getDomainReporter(
    requestParameters: GetDomainReporterRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Reporter> {
    const response = await this.getDomainReporterRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   */
  async getEffectivePasswordPolicyRaw(
    requestParameters: GetEffectivePasswordPolicyRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getEffectivePasswordPolicy.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getEffectivePasswordPolicy.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getEffectivePasswordPolicy.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.identity !== undefined) {
      queryParameters['identity'] = requestParameters.identity;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/password-policies/activePolicy`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   */
  async getEffectivePasswordPolicy(
    requestParameters: GetEffectivePasswordPolicyRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.getEffectivePasswordPolicyRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_EXTENSION_GRANT[READ] permission on the specified domain or DOMAIN_EXTENSION_GRANT[READ] permission on the specified environment or DOMAIN_EXTENSION_GRANT[READ] permission on the specified organization
   * Get a extension grant
   */
  async getExtensionGrantRaw(
    requestParameters: GetExtensionGrantRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ExtensionGrant>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getExtensionGrant.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getExtensionGrant.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getExtensionGrant.',
      );
    }

    if (requestParameters.extensionGrant === null || requestParameters.extensionGrant === undefined) {
      throw new runtime.RequiredError(
        'extensionGrant',
        'Required parameter requestParameters.extensionGrant was null or undefined when calling getExtensionGrant.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/extensionGrants/{extensionGrant}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'extensionGrant'}}`, encodeURIComponent(String(requestParameters.extensionGrant))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ExtensionGrantFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_EXTENSION_GRANT[READ] permission on the specified domain or DOMAIN_EXTENSION_GRANT[READ] permission on the specified environment or DOMAIN_EXTENSION_GRANT[READ] permission on the specified organization
   * Get a extension grant
   */
  async getExtensionGrant(
    requestParameters: GetExtensionGrantRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<ExtensionGrant> {
    const response = await this.getExtensionGrantRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_FACTOR[READ] permission on the specified domain or DOMAIN_FACTOR[READ] permission on the specified environment or DOMAIN_FACTOR[READ] permission on the specified organization
   * Get a factor
   */
  async getFactorRaw(
    requestParameters: GetFactorRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Factor>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getFactor.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getFactor.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getFactor.',
      );
    }

    if (requestParameters.factor === null || requestParameters.factor === undefined) {
      throw new runtime.RequiredError(
        'factor',
        'Required parameter requestParameters.factor was null or undefined when calling getFactor.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/factors/{factor}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'factor'}}`, encodeURIComponent(String(requestParameters.factor))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => FactorFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_FACTOR[READ] permission on the specified domain or DOMAIN_FACTOR[READ] permission on the specified environment or DOMAIN_FACTOR[READ] permission on the specified organization
   * Get a factor
   */
  async getFactor(requestParameters: GetFactorRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Factor> {
    const response = await this.getFactorRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_GROUP[READ] permission on the specified domain or DOMAIN_GROUP[READ] permission on the specified environment or DOMAIN_GROUP[READ] permission on the specified organization
   * List group members
   */
  async getGroupMembersRaw(
    requestParameters: GetGroupMembersRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<User>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getGroupMembers.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getGroupMembers.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getGroupMembers.',
      );
    }

    if (requestParameters.group === null || requestParameters.group === undefined) {
      throw new runtime.RequiredError(
        'group',
        'Required parameter requestParameters.group was null or undefined when calling getGroupMembers.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.page !== undefined) {
      queryParameters['page'] = requestParameters.page;
    }

    if (requestParameters.size !== undefined) {
      queryParameters['size'] = requestParameters.size;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/groups/{group}/members`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'group'}}`, encodeURIComponent(String(requestParameters.group))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_GROUP[READ] permission on the specified domain or DOMAIN_GROUP[READ] permission on the specified environment or DOMAIN_GROUP[READ] permission on the specified organization
   * List group members
   */
  async getGroupMembers(
    requestParameters: GetGroupMembersRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<User> {
    const response = await this.getGroupMembersRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_I18N_DICTIONARY[READ] permission on the specified domain or DOMAIN_I18N_DICTIONARY[READ] permission on the specified environment or DOMAIN_I18N_DICTIONARY[READ] permission on the specified organization.
   * Get a i18n dictionary
   */
  async getI18nDictionaryRaw(
    requestParameters: GetI18nDictionaryRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<I18nDictionary>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getI18nDictionary.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getI18nDictionary.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getI18nDictionary.',
      );
    }

    if (requestParameters.dictionary === null || requestParameters.dictionary === undefined) {
      throw new runtime.RequiredError(
        'dictionary',
        'Required parameter requestParameters.dictionary was null or undefined when calling getI18nDictionary.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/i18n/dictionaries/{dictionary}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'dictionary'}}`, encodeURIComponent(String(requestParameters.dictionary))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => I18nDictionaryFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_I18N_DICTIONARY[READ] permission on the specified domain or DOMAIN_I18N_DICTIONARY[READ] permission on the specified environment or DOMAIN_I18N_DICTIONARY[READ] permission on the specified organization.
   * Get a i18n dictionary
   */
  async getI18nDictionary(
    requestParameters: GetI18nDictionaryRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<I18nDictionary> {
    const response = await this.getI18nDictionaryRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have APPLICATION_MEMBER[LIST] permission on the specified application or APPLICATION_MEMBER[LIST] permission on the specified domain or APPLICATION_MEMBER[LIST] permission on the specified environment or APPLICATION_MEMBER[LIST] permission on the specified organization
   * List members for an application
   */
  async getMembersRaw(
    requestParameters: GetMembersRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<MembershipListItem>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getMembers.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getMembers.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getMembers.',
      );
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling getMembers.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/members`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => MembershipListItemFromJSON(jsonValue));
  }

  /**
   * User must have APPLICATION_MEMBER[LIST] permission on the specified application or APPLICATION_MEMBER[LIST] permission on the specified domain or APPLICATION_MEMBER[LIST] permission on the specified environment or APPLICATION_MEMBER[LIST] permission on the specified organization
   * List members for an application
   */
  async getMembers(
    requestParameters: GetMembersRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<MembershipListItem> {
    const response = await this.getMembersRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_SETTINGS[READ] permission on the specified domain or DOMAIN_SETTINGS[READ] permission on the specified environment or DOMAIN_SETTINGS[READ] permission on the specified organization
   * Read a password policy
   */
  async getPasswordPolicyRaw(
    requestParameters: GetPasswordPolicyRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<PasswordPolicy>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getPasswordPolicy.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getPasswordPolicy.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getPasswordPolicy.',
      );
    }

    if (requestParameters.policy === null || requestParameters.policy === undefined) {
      throw new runtime.RequiredError(
        'policy',
        'Required parameter requestParameters.policy was null or undefined when calling getPasswordPolicy.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/password-policies/{policy}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'policy'}}`, encodeURIComponent(String(requestParameters.policy))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => PasswordPolicyFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_SETTINGS[READ] permission on the specified domain or DOMAIN_SETTINGS[READ] permission on the specified environment or DOMAIN_SETTINGS[READ] permission on the specified organization
   * Read a password policy
   */
  async getPasswordPolicy(
    requestParameters: GetPasswordPolicyRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<PasswordPolicy> {
    const response = await this.getPasswordPolicyRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have APPLICATION[READ] permission on the specified application or APPLICATION[READ] permission on the specified domain or APPLICATION[READ] permission on the specified environment or APPLICATION[READ] permission on the specified organization
   * List application member\'s permissions
   */
  async getPermissionsRaw(
    requestParameters: GetPermissionsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getPermissions.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getPermissions.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getPermissions.',
      );
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling getPermissions.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/members/permissions`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.TextApiResponse(response) as any;
  }

  /**
   * User must have APPLICATION[READ] permission on the specified application or APPLICATION[READ] permission on the specified domain or APPLICATION[READ] permission on the specified environment or APPLICATION[READ] permission on the specified organization
   * List application member\'s permissions
   */
  async getPermissions(
    requestParameters: GetPermissionsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<string> {
    const response = await this.getPermissionsRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have DOMAIN[READ] permission on the specified domain or DOMAIN[READ] permission on the specified environment or DOMAIN[READ] permission on the specified organization
   * List domain member\'s permissions
   */
  async getPermissions1Raw(
    requestParameters: GetPermissions1Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getPermissions1.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getPermissions1.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getPermissions1.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/members/permissions`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.TextApiResponse(response) as any;
  }

  /**
   * User must have DOMAIN[READ] permission on the specified domain or DOMAIN[READ] permission on the specified environment or DOMAIN[READ] permission on the specified organization
   * List domain member\'s permissions
   */
  async getPermissions1(
    requestParameters: GetPermissions1Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<string> {
    const response = await this.getPermissions1Raw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_RESOURCE[READ] permission on the specified domain or DOMAIN_RESOURCE[READ] permission on the specified environment or DOMAIN_RESOURCE[READ] permission on the specified organization
   * Get a resource
   */
  async getResourceRaw(
    requestParameters: GetResourceRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ServiceResource>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getResource.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getResource.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getResource.',
      );
    }

    if (requestParameters.resource === null || requestParameters.resource === undefined) {
      throw new runtime.RequiredError(
        'resource',
        'Required parameter requestParameters.resource was null or undefined when calling getResource.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/resources/{resource}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'resource'}}`, encodeURIComponent(String(requestParameters.resource))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ServiceResourceFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_RESOURCE[READ] permission on the specified domain or DOMAIN_RESOURCE[READ] permission on the specified environment or DOMAIN_RESOURCE[READ] permission on the specified organization
   * Get a resource
   */
  async getResource(
    requestParameters: GetResourceRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<ServiceResource> {
    const response = await this.getResourceRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_THEME[READ] permission on the specified domain or DOMAIN_THEME[READ] permission on the specified environment or DOMAIN_THEME[READ] permission on the specified organization
   * Get the theme linked to the specified security domain
   */
  async getThemeRaw(
    requestParameters: GetThemeRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ThemeEntity>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getTheme.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getTheme.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling getTheme.');
    }

    if (requestParameters.themeId === null || requestParameters.themeId === undefined) {
      throw new runtime.RequiredError(
        'themeId',
        'Required parameter requestParameters.themeId was null or undefined when calling getTheme.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/themes/{themeId}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'themeId'}}`, encodeURIComponent(String(requestParameters.themeId))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ThemeEntityFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_THEME[READ] permission on the specified domain or DOMAIN_THEME[READ] permission on the specified environment or DOMAIN_THEME[READ] permission on the specified organization
   * Get the theme linked to the specified security domain
   */
  async getTheme(requestParameters: GetThemeRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<ThemeEntity> {
    const response = await this.getThemeRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user audit log
   */
  async getUserAuditLogRaw(
    requestParameters: GetUserAuditLogRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Audit>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getUserAuditLog.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getUserAuditLog.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getUserAuditLog.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling getUserAuditLog.',
      );
    }

    if (requestParameters.audit === null || requestParameters.audit === undefined) {
      throw new runtime.RequiredError(
        'audit',
        'Required parameter requestParameters.audit was null or undefined when calling getUserAuditLog.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/audits/{audit}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user)))
          .replace(`{${'audit'}}`, encodeURIComponent(String(requestParameters.audit))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => AuditFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user audit log
   */
  async getUserAuditLog(
    requestParameters: GetUserAuditLogRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Audit> {
    const response = await this.getUserAuditLogRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user consent
   */
  async getUserConsentRaw(
    requestParameters: GetUserConsentRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ScopeApprovalEntity>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getUserConsent.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getUserConsent.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getUserConsent.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling getUserConsent.',
      );
    }

    if (requestParameters.consent === null || requestParameters.consent === undefined) {
      throw new runtime.RequiredError(
        'consent',
        'Required parameter requestParameters.consent was null or undefined when calling getUserConsent.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/consents/{consent}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user)))
          .replace(`{${'consent'}}`, encodeURIComponent(String(requestParameters.consent))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ScopeApprovalEntityFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user consent
   */
  async getUserConsent(
    requestParameters: GetUserConsentRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<ScopeApprovalEntity> {
    const response = await this.getUserConsentRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user credential
   */
  async getUserCredentialRaw(
    requestParameters: GetUserCredentialRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Credential>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getUserCredential.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getUserCredential.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getUserCredential.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling getUserCredential.',
      );
    }

    if (requestParameters.credential === null || requestParameters.credential === undefined) {
      throw new runtime.RequiredError(
        'credential',
        'Required parameter requestParameters.credential was null or undefined when calling getUserCredential.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/credentials/{credential}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user)))
          .replace(`{${'credential'}}`, encodeURIComponent(String(requestParameters.credential))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => CredentialFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user credential
   */
  async getUserCredential(
    requestParameters: GetUserCredentialRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Credential> {
    const response = await this.getUserCredentialRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * List all the alert notifiers of the domain. User must have DOMAIN_ALERT_NOTIFIER[LIST] permission on the specified domain, environment or organization.
   * List alert notifiers
   */
  async listAlertNotifiersRaw(
    requestParameters: ListAlertNotifiersRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<AlertNotifier>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listAlertNotifiers.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listAlertNotifiers.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listAlertNotifiers.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/alerts/notifiers`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AlertNotifierFromJSON));
  }

  /**
   * List all the alert notifiers of the domain. User must have DOMAIN_ALERT_NOTIFIER[LIST] permission on the specified domain, environment or organization.
   * List alert notifiers
   */
  async listAlertNotifiers(
    requestParameters: ListAlertNotifiersRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<AlertNotifier>> {
    const response = await this.listAlertNotifiersRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * List all the alert triggers of the domain accessible to the current user. User must have DOMAIN_ALERT[LIST] permission on the specified domain, environment or organization.
   * List alert triggers
   */
  async listAlertTriggersRaw(
    requestParameters: ListAlertTriggersRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<AlertTrigger>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listAlertTriggers.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listAlertTriggers.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listAlertTriggers.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/alerts/triggers`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AlertTriggerFromJSON));
  }

  /**
   * List all the alert triggers of the domain accessible to the current user. User must have DOMAIN_ALERT[LIST] permission on the specified domain, environment or organization.
   * List alert triggers
   */
  async listAlertTriggers(
    requestParameters: ListAlertTriggersRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<AlertTrigger>> {
    const response = await this.listAlertTriggersRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the APPLICATION_FLOW[LIST] permission on the specified domain or APPLICATION_FLOW[LIST] permission on the specified environment or APPLICATION_FLOW[LIST] permission on the specified organization. Except if user has APPLICATION_FLOW[READ] permission on the domain, environment or organization, each returned flow is filtered and contains only basic information such as id and name and isEnabled.
   * List registered flows for an application
   */
  async listAppFlowsRaw(
    requestParameters: ListAppFlowsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<FlowEntity>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listAppFlows.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listAppFlows.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listAppFlows.',
      );
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling listAppFlows.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/flows`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(FlowEntityFromJSON));
  }

  /**
   * User must have the APPLICATION_FLOW[LIST] permission on the specified domain or APPLICATION_FLOW[LIST] permission on the specified environment or APPLICATION_FLOW[LIST] permission on the specified organization. Except if user has APPLICATION_FLOW[READ] permission on the domain, environment or organization, each returned flow is filtered and contains only basic information such as id and name and isEnabled.
   * List registered flows for an application
   */
  async listAppFlows(
    requestParameters: ListAppFlowsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<FlowEntity>> {
    const response = await this.listAppFlowsRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have APPLICATION_RESOURCE[READ] permission on the specified application or APPLICATION_RESOURCE[READ] permission on the specified domain or APPLICATION_RESOURCE[READ] permission on the specified environment or APPLICATION_RESOURCE[READ] permission on the specified organization
   * Get resource access policies
   */
  async listApplicationPoliciesRaw(
    requestParameters: ListApplicationPoliciesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<AccessPolicyListItem>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listApplicationPolicies.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listApplicationPolicies.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listApplicationPolicies.',
      );
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling listApplicationPolicies.',
      );
    }

    if (requestParameters.resource === null || requestParameters.resource === undefined) {
      throw new runtime.RequiredError(
        'resource',
        'Required parameter requestParameters.resource was null or undefined when calling listApplicationPolicies.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/resources/{resource}/policies`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application)))
          .replace(`{${'resource'}}`, encodeURIComponent(String(requestParameters.resource))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AccessPolicyListItemFromJSON));
  }

  /**
   * User must have APPLICATION_RESOURCE[READ] permission on the specified application or APPLICATION_RESOURCE[READ] permission on the specified domain or APPLICATION_RESOURCE[READ] permission on the specified environment or APPLICATION_RESOURCE[READ] permission on the specified organization
   * Get resource access policies
   */
  async listApplicationPolicies(
    requestParameters: ListApplicationPoliciesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<AccessPolicyListItem>> {
    const response = await this.listApplicationPoliciesRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have APPLICATION_RESOURCE[LIST] permission on the specified application or APPLICATION_RESOURCE[LIST] permission on the specified domain or APPLICATION_RESOURCE[LIST] permission on the specified environment or APPLICATION_RESOURCE[LIST] permission on the specified organization
   * List resources for an application
   */
  async listApplicationResourcesRaw(
    requestParameters: ListApplicationResourcesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ResourceListItem>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listApplicationResources.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listApplicationResources.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listApplicationResources.',
      );
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling listApplicationResources.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.page !== undefined) {
      queryParameters['page'] = requestParameters.page;
    }

    if (requestParameters.size !== undefined) {
      queryParameters['size'] = requestParameters.size;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/resources`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ResourceListItemFromJSON(jsonValue));
  }

  /**
   * User must have APPLICATION_RESOURCE[LIST] permission on the specified application or APPLICATION_RESOURCE[LIST] permission on the specified domain or APPLICATION_RESOURCE[LIST] permission on the specified environment or APPLICATION_RESOURCE[LIST] permission on the specified organization
   * List resources for an application
   */
  async listApplicationResources(
    requestParameters: ListApplicationResourcesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<ResourceListItem> {
    const response = await this.listApplicationResourcesRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the APPLICATION[LIST] permission on the specified domain, environment or organization AND either APPLICATION[READ] permission on each domain\'s application or APPLICATION[READ] permission on the specified domain or APPLICATION[READ] permission on the specified environment or APPLICATION[READ] permission on the specified organization. Each returned application is filtered and contains only basic information such as id, name, description and isEnabled.
   * List registered applications for a security domain
   */
  async listApplicationsRaw(
    requestParameters: ListApplicationsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ApplicationPage>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listApplications.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listApplications.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listApplications.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.page !== undefined) {
      queryParameters['page'] = requestParameters.page;
    }

    if (requestParameters.size !== undefined) {
      queryParameters['size'] = requestParameters.size;
    }

    if (requestParameters.q !== undefined) {
      queryParameters['q'] = requestParameters.q;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ApplicationPageFromJSON(jsonValue));
  }

  /**
   * User must have the APPLICATION[LIST] permission on the specified domain, environment or organization AND either APPLICATION[READ] permission on each domain\'s application or APPLICATION[READ] permission on the specified domain or APPLICATION[READ] permission on the specified environment or APPLICATION[READ] permission on the specified organization. Each returned application is filtered and contains only basic information such as id, name, description and isEnabled.
   * List registered applications for a security domain
   */
  async listApplications(
    requestParameters: ListApplicationsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<ApplicationPage> {
    const response = await this.listApplicationsRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_AUTHDEVICE_NOTIFIER[LIST] permission on the specified domain or DOMAIN_AUTHDEVICE_NOTIFIER[LIST] permission on the specified environment or DOMAIN_AUTHDEVICE_NOTIFIER[LIST] permission on the specified organization Each returned Authentication Device Notifier is filtered and contains only basic information such as id, name.
   * List registered Authentication Device Notifiers for a security domain
   */
  async listAuthenticationDeviceNotifiersRaw(
    requestParameters: ListAuthenticationDeviceNotifiersRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<AuthenticationDeviceNotifier>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listAuthenticationDeviceNotifiers.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listAuthenticationDeviceNotifiers.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listAuthenticationDeviceNotifiers.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/auth-device-notifiers`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AuthenticationDeviceNotifierFromJSON));
  }

  /**
   * User must have the DOMAIN_AUTHDEVICE_NOTIFIER[LIST] permission on the specified domain or DOMAIN_AUTHDEVICE_NOTIFIER[LIST] permission on the specified environment or DOMAIN_AUTHDEVICE_NOTIFIER[LIST] permission on the specified organization Each returned Authentication Device Notifier is filtered and contains only basic information such as id, name.
   * List registered Authentication Device Notifiers for a security domain
   */
  async listAuthenticationDeviceNotifiers(
    requestParameters: ListAuthenticationDeviceNotifiersRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<AuthenticationDeviceNotifier>> {
    const response = await this.listAuthenticationDeviceNotifiersRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_AUTHORIZATION_ENGINE[LIST] permission on the specified domain or DOMAIN_AUTHORIZATION_ENGINE[LIST] permission on the specified environment or DOMAIN_AUTHORIZATION_ENGINE[LIST] permission on the specified organization.
   * List registered authorization engines for a security domain
   */
  async listAuthorizationEnginesRaw(
    requestParameters: ListAuthorizationEnginesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<AuthorizationEngine>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listAuthorizationEngines.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listAuthorizationEngines.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listAuthorizationEngines.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/authorization-engines`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AuthorizationEngineFromJSON));
  }

  /**
   * User must have the DOMAIN_AUTHORIZATION_ENGINE[LIST] permission on the specified domain or DOMAIN_AUTHORIZATION_ENGINE[LIST] permission on the specified environment or DOMAIN_AUTHORIZATION_ENGINE[LIST] permission on the specified organization.
   * List registered authorization engines for a security domain
   */
  async listAuthorizationEngines(
    requestParameters: ListAuthorizationEnginesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<AuthorizationEngine>> {
    const response = await this.listAuthorizationEnginesRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_BOT_DETECTION[LIST] permission on the specified domain or DOMAIN_BOT_DETECTION[LIST] permission on the specified environment or DOMAIN_BOT_DETECTION[LIST] permission on the specified organization Each returned bot detections is filtered and contains only basic information such as id, name.
   * List registered bot detections for a security domain
   */
  async listBotDetectionsRaw(
    requestParameters: ListBotDetectionsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<BotDetection>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listBotDetections.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listBotDetections.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listBotDetections.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/bot-detections`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(BotDetectionFromJSON));
  }

  /**
   * User must have the DOMAIN_BOT_DETECTION[LIST] permission on the specified domain or DOMAIN_BOT_DETECTION[LIST] permission on the specified environment or DOMAIN_BOT_DETECTION[LIST] permission on the specified organization Each returned bot detections is filtered and contains only basic information such as id, name.
   * List registered bot detections for a security domain
   */
  async listBotDetections(
    requestParameters: ListBotDetectionsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<BotDetection>> {
    const response = await this.listBotDetectionsRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_CERTIFICATE[LIST] permission on the specified domain or DOMAIN_CERTIFICATE[LIST] permission on the specified environment or DOMAIN_CERTIFICATE[LIST] permission on the specified organization. Each returned certificate is filtered and contains only basic information such as id, name and type.
   * List registered certificates for a security domain
   */
  async listCertificatesRaw(
    requestParameters: ListCertificatesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<CertificateEntity>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listCertificates.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listCertificates.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listCertificates.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.use !== undefined) {
      queryParameters['use'] = requestParameters.use;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/certificates`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CertificateEntityFromJSON));
  }

  /**
   * User must have the DOMAIN_CERTIFICATE[LIST] permission on the specified domain or DOMAIN_CERTIFICATE[LIST] permission on the specified environment or DOMAIN_CERTIFICATE[LIST] permission on the specified organization. Each returned certificate is filtered and contains only basic information such as id, name and type.
   * List registered certificates for a security domain
   */
  async listCertificates(
    requestParameters: ListCertificatesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<CertificateEntity>> {
    const response = await this.listCertificatesRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_DEVICE_IDENTIFIERS[LIST] permission on the specified domain or DOMAIN_DEVICE_IDENTIFIERS[LIST] permission on the specified environment or DOMAIN_DEVICE_IDENTIFIERS[LIST] permission on the specified organization Each returned bot detections is filtered and contains only basic information such as id, name.
   * List registered device identifiers for a security domain
   */
  async listDeviceIdentifiersRaw(
    requestParameters: ListDeviceIdentifiersRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<DeviceIdentifier>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listDeviceIdentifiers.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listDeviceIdentifiers.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listDeviceIdentifiers.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/device-identifiers`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(DeviceIdentifierFromJSON));
  }

  /**
   * User must have the DOMAIN_DEVICE_IDENTIFIERS[LIST] permission on the specified domain or DOMAIN_DEVICE_IDENTIFIERS[LIST] permission on the specified environment or DOMAIN_DEVICE_IDENTIFIERS[LIST] permission on the specified organization Each returned bot detections is filtered and contains only basic information such as id, name.
   * List registered device identifiers for a security domain
   */
  async listDeviceIdentifiers(
    requestParameters: ListDeviceIdentifiersRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<DeviceIdentifier>> {
    const response = await this.listDeviceIdentifiersRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_AUDIT[LIST] permission on the specified domain, environment or organization. Except if user has ORGANIZATION_AUDIT[READ] permission on the domain, environment or organization, each returned audit is filtered and contains only basic information such as id, date, event, actor, target and status.
   * List audit logs for a security domain
   */
  async listDomainAuditsRaw(
    requestParameters: ListDomainAuditsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<Audit>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listDomainAudits.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listDomainAudits.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listDomainAudits.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.type !== undefined) {
      queryParameters['type'] = requestParameters.type;
    }

    if (requestParameters.status !== undefined) {
      queryParameters['status'] = requestParameters.status;
    }

    if (requestParameters.user !== undefined) {
      queryParameters['user'] = requestParameters.user;
    }

    if (requestParameters.from !== undefined) {
      queryParameters['from'] = requestParameters.from;
    }

    if (requestParameters.to !== undefined) {
      queryParameters['to'] = requestParameters.to;
    }

    if (requestParameters.size !== undefined) {
      queryParameters['size'] = requestParameters.size;
    }

    if (requestParameters.page !== undefined) {
      queryParameters['page'] = requestParameters.page;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/audits`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AuditFromJSON));
  }

  /**
   * User must have the DOMAIN_AUDIT[LIST] permission on the specified domain, environment or organization. Except if user has ORGANIZATION_AUDIT[READ] permission on the domain, environment or organization, each returned audit is filtered and contains only basic information such as id, date, event, actor, target and status.
   * List audit logs for a security domain
   */
  async listDomainAudits(
    requestParameters: ListDomainAuditsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<Audit>> {
    const response = await this.listDomainAuditsRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_FLOW[LIST] permission on the specified domain or DOMAIN_FLOW[LIST] permission on the specified environment or DOMAIN_FLOW[LIST] permission on the specified organization. Except if user has DOMAIN_FLOW[READ] permission on the domain, environment or organization, each returned flow is filtered and contains only basic information such as id and name and isEnabled.
   * List registered flows for a security domain
   */
  async listDomainFlowsRaw(
    requestParameters: ListDomainFlowsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<FlowEntity>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listDomainFlows.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listDomainFlows.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listDomainFlows.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/flows`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(FlowEntityFromJSON));
  }

  /**
   * User must have the DOMAIN_FLOW[LIST] permission on the specified domain or DOMAIN_FLOW[LIST] permission on the specified environment or DOMAIN_FLOW[LIST] permission on the specified organization. Except if user has DOMAIN_FLOW[READ] permission on the domain, environment or organization, each returned flow is filtered and contains only basic information such as id and name and isEnabled.
   * List registered flows for a security domain
   */
  async listDomainFlows(
    requestParameters: ListDomainFlowsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<FlowEntity>> {
    const response = await this.listDomainFlowsRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_REPORTER[LIST] permission on the specified domain or DOMAIN_REPORTER[LIST] permission on the specified environment or DOMAIN_REPORTER[LIST] permission on the specified organization. Except if user has DOMAIN_REPORTER[READ] permission on the domain, environment or organization, each returned reporter is filtered and contains only basic information such as id and name and type.
   * List registered reporters for a security domain
   */
  async listDomainReportersRaw(
    requestParameters: ListDomainReportersRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<Reporter>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listDomainReporters.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listDomainReporters.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listDomainReporters.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.userProvider !== undefined) {
      queryParameters['userProvider'] = requestParameters.userProvider;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/reporters`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ReporterFromJSON));
  }

  /**
   * User must have the DOMAIN_REPORTER[LIST] permission on the specified domain or DOMAIN_REPORTER[LIST] permission on the specified environment or DOMAIN_REPORTER[LIST] permission on the specified organization. Except if user has DOMAIN_REPORTER[READ] permission on the domain, environment or organization, each returned reporter is filtered and contains only basic information such as id and name and type.
   * List registered reporters for a security domain
   */
  async listDomainReporters(
    requestParameters: ListDomainReportersRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<Reporter>> {
    const response = await this.listDomainReportersRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * List all the security domains accessible to the current user. User must have DOMAIN[LIST] permission on the specified environment or organization AND either DOMAIN[READ] permission on each security domain or DOMAIN[READ] permission on the specified environment or DOMAIN[READ] permission on the specified organization.Each returned domain is filtered and contains only basic information such as id, name and description and isEnabled.
   * List security domains for an environment
   */
  async listDomainsRaw(
    requestParameters: ListDomainsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<DomainPage>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listDomains.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listDomains.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.page !== undefined) {
      queryParameters['page'] = requestParameters.page;
    }

    if (requestParameters.size !== undefined) {
      queryParameters['size'] = requestParameters.size;
    }

    if (requestParameters.q !== undefined) {
      queryParameters['q'] = requestParameters.q;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(DomainPageFromJSON));
  }

  /**
   * List all the security domains accessible to the current user. User must have DOMAIN[LIST] permission on the specified environment or organization AND either DOMAIN[READ] permission on each security domain or DOMAIN[READ] permission on the specified environment or DOMAIN[READ] permission on the specified organization.Each returned domain is filtered and contains only basic information such as id, name and description and isEnabled.
   * List security domains for an environment
   */
  async listDomains(
    requestParameters: ListDomainsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<DomainPage>> {
    const response = await this.listDomainsRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_EXTENSION_GRANT[LIST] permission on the specified domain or DOMAIN_EXTENSION_GRANT[LIST] permission on the specified environment or DOMAIN_EXTENSION_GRANT[LIST] permission on the specified organization. Each returned extension grant is filtered and contains only basic information such as id, name and type.
   * List registered extension grants for a security domain
   */
  async listExtensionGrantsRaw(
    requestParameters: ListExtensionGrantsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<ExtensionGrant>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listExtensionGrants.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listExtensionGrants.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listExtensionGrants.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/extensionGrants`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ExtensionGrantFromJSON));
  }

  /**
   * User must have the DOMAIN_EXTENSION_GRANT[LIST] permission on the specified domain or DOMAIN_EXTENSION_GRANT[LIST] permission on the specified environment or DOMAIN_EXTENSION_GRANT[LIST] permission on the specified organization. Each returned extension grant is filtered and contains only basic information such as id, name and type.
   * List registered extension grants for a security domain
   */
  async listExtensionGrants(
    requestParameters: ListExtensionGrantsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<ExtensionGrant>> {
    const response = await this.listExtensionGrantsRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_FACTOR[LIST] permission on the specified domain or DOMAIN_FACTOR[LIST] permission on the specified environment or DOMAIN_FACTOR[LIST] permission on the specified organization Each returned factor is filtered and contains only basic information such as id, name and factor type.
   * List registered factors for a security domain
   */
  async listFactorsRaw(
    requestParameters: ListFactorsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<Factor>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listFactors.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listFactors.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listFactors.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/factors`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(FactorFromJSON));
  }

  /**
   * User must have the DOMAIN_FACTOR[LIST] permission on the specified domain or DOMAIN_FACTOR[LIST] permission on the specified environment or DOMAIN_FACTOR[LIST] permission on the specified organization Each returned factor is filtered and contains only basic information such as id, name and factor type.
   * List registered factors for a security domain
   */
  async listFactors(
    requestParameters: ListFactorsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<Factor>> {
    const response = await this.listFactorsRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_GROUP[LIST] permission on the specified domain or DOMAIN_GROUP[LIST] permission on the specified environment or DOMAIN_GROUP[LIST] permission on the specified organization. Each returned group is filtered and contains only basic information such as id and name.
   * List groups for a security domain
   */
  async listGroupsRaw(
    requestParameters: ListGroupsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<GroupPage>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listGroups.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listGroups.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listGroups.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.page !== undefined) {
      queryParameters['page'] = requestParameters.page;
    }

    if (requestParameters.size !== undefined) {
      queryParameters['size'] = requestParameters.size;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/groups`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => GroupPageFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_GROUP[LIST] permission on the specified domain or DOMAIN_GROUP[LIST] permission on the specified environment or DOMAIN_GROUP[LIST] permission on the specified organization. Each returned group is filtered and contains only basic information such as id and name.
   * List groups for a security domain
   */
  async listGroups(requestParameters: ListGroupsRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<GroupPage> {
    const response = await this.listGroupsRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_I18N_DICTIONARY[LIST] permission on the specified domain or DOMAIN_I18N_DICTIONARY[LIST] permission on the specified environment or DOMAIN_I18N_DICTIONARY[LIST] permission on the specified organization.
   * List all i18n dictionaries supported for a security domain
   */
  async listI18nDictionariesRaw(
    requestParameters: ListI18nDictionariesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<I18nDictionary>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listI18nDictionaries.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listI18nDictionaries.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listI18nDictionaries.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/i18n/dictionaries`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(I18nDictionaryFromJSON));
  }

  /**
   * User must have the DOMAIN_I18N_DICTIONARY[LIST] permission on the specified domain or DOMAIN_I18N_DICTIONARY[LIST] permission on the specified environment or DOMAIN_I18N_DICTIONARY[LIST] permission on the specified organization.
   * List all i18n dictionaries supported for a security domain
   */
  async listI18nDictionaries(
    requestParameters: ListI18nDictionariesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<I18nDictionary>> {
    const response = await this.listI18nDictionariesRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_IDENTITY_PROVIDER[LIST] permission on the specified domain or DOMAIN_IDENTITY_PROVIDER[LIST] permission on the specified environment or DOMAIN_IDENTITY_PROVIDER[LIST] permission on the specified organization. Each returned identity provider is filtered and contains only basic information such as id, name and type.
   * List registered identity providers for a security domain
   */
  async listIdentityProvidersRaw(
    requestParameters: ListIdentityProvidersRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<FilteredIdentityProviderInfo>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listIdentityProviders.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listIdentityProviders.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listIdentityProviders.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.userProvider !== undefined) {
      queryParameters['userProvider'] = requestParameters.userProvider;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/identities`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(FilteredIdentityProviderInfoFromJSON));
  }

  /**
   * User must have the DOMAIN_IDENTITY_PROVIDER[LIST] permission on the specified domain or DOMAIN_IDENTITY_PROVIDER[LIST] permission on the specified environment or DOMAIN_IDENTITY_PROVIDER[LIST] permission on the specified organization. Each returned identity provider is filtered and contains only basic information such as id, name and type.
   * List registered identity providers for a security domain
   */
  async listIdentityProviders(
    requestParameters: ListIdentityProvidersRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<FilteredIdentityProviderInfo>> {
    const response = await this.listIdentityProvidersRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_MEMBER[LIST] permission on the specified domain or DOMAIN_MEMBER[LIST] permission on the specified environment or DOMAIN_MEMBER[LIST] permission on the specified organization
   * List members for a security domain
   */
  async listMembersRaw(
    requestParameters: ListMembersRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<MembershipListItem>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listMembers.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listMembers.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listMembers.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/members`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => MembershipListItemFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_MEMBER[LIST] permission on the specified domain or DOMAIN_MEMBER[LIST] permission on the specified environment or DOMAIN_MEMBER[LIST] permission on the specified organization
   * List members for a security domain
   */
  async listMembers(
    requestParameters: ListMembersRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<MembershipListItem> {
    const response = await this.listMembersRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_SETTINGS[READ] permission on the specified domain or DOMAIN_SETTINGS[READ] permission on the specified environment or DOMAIN_SETTINGS[READ] permission on the specified organization.
   * List registered password policies for a security domain
   */
  async listPasswordPoliciesRaw(
    requestParameters: ListPasswordPoliciesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<PasswordPolicyEntity>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listPasswordPolicies.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listPasswordPolicies.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listPasswordPolicies.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/password-policies`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PasswordPolicyEntityFromJSON));
  }

  /**
   * User must have the DOMAIN_SETTINGS[READ] permission on the specified domain or DOMAIN_SETTINGS[READ] permission on the specified environment or DOMAIN_SETTINGS[READ] permission on the specified organization.
   * List registered password policies for a security domain
   */
  async listPasswordPolicies(
    requestParameters: ListPasswordPoliciesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<PasswordPolicyEntity>> {
    const response = await this.listPasswordPoliciesRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the PROTECTED_RESOURCE[LIST] permission on the specified domain, environment or organization AND either PROTECTED_RESOURCE[READ] permission on each domain\'s protected resource or PROTECTED_RESOURCE[READ] permission on the specified domain or PROTECTED_RESOURCE[READ] permission on the specified environment or PROTECTED_RESOURCE[READ] permission on the specified organization. Each returned protected resource is filtered and contains only basic information such as id, name, description and isEnabled.
   * List registered protected resources for a security domain
   */
  async listProtectedResourcesRaw(
    requestParameters: ListProtectedResourcesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ProtectedResourcePage>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listProtectedResources.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listProtectedResources.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listProtectedResources.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.type !== undefined) {
      queryParameters['type'] = requestParameters.type;
    }

    if (requestParameters.page !== undefined) {
      queryParameters['page'] = requestParameters.page;
    }

    if (requestParameters.size !== undefined) {
      queryParameters['size'] = requestParameters.size;
    }

    if (requestParameters.sort !== undefined) {
      queryParameters['sort'] = requestParameters.sort;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/protected-resources`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ProtectedResourcePageFromJSON(jsonValue));
  }

  /**
   * User must have the PROTECTED_RESOURCE[LIST] permission on the specified domain, environment or organization AND either PROTECTED_RESOURCE[READ] permission on each domain\'s protected resource or PROTECTED_RESOURCE[READ] permission on the specified domain or PROTECTED_RESOURCE[READ] permission on the specified environment or PROTECTED_RESOURCE[READ] permission on the specified organization. Each returned protected resource is filtered and contains only basic information such as id, name, description and isEnabled.
   * List registered protected resources for a security domain
   */
  async listProtectedResources(
    requestParameters: ListProtectedResourcesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<ProtectedResourcePage> {
    const response = await this.listProtectedResourcesRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_RESOURCE[LIST] permission on the specified domain or DOMAIN_RESOURCE[LIST] permission on the specified environment or DOMAIN_RESOURCE[LIST] permission on the specified organization Each returned resource is filtered and contains only basic information such as id, name and resource type.
   * List registered resources for a security domain
   */
  async listResourcesRaw(
    requestParameters: ListResourcesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<ServiceResource>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listResources.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listResources.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listResources.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/resources`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ServiceResourceFromJSON));
  }

  /**
   * User must have the DOMAIN_RESOURCE[LIST] permission on the specified domain or DOMAIN_RESOURCE[LIST] permission on the specified environment or DOMAIN_RESOURCE[LIST] permission on the specified organization Each returned resource is filtered and contains only basic information such as id, name and resource type.
   * List registered resources for a security domain
   */
  async listResources(
    requestParameters: ListResourcesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<ServiceResource>> {
    const response = await this.listResourcesRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_SCOPE[LIST] permission on the specified domain or DOMAIN_SCOPE[LIST] permission on the specified environment or DOMAIN_SCOPE[LIST] permission on the specified organization Each returned scope is filtered and contains only basic information such as id, key, name, description, isSystem and isDiscovery.
   * List scopes for a security domain
   */
  async listScopesRaw(
    requestParameters: ListScopesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ScopePage>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listScopes.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listScopes.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listScopes.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.page !== undefined) {
      queryParameters['page'] = requestParameters.page;
    }

    if (requestParameters.size !== undefined) {
      queryParameters['size'] = requestParameters.size;
    }

    if (requestParameters.q !== undefined) {
      queryParameters['q'] = requestParameters.q;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/scopes`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ScopePageFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_SCOPE[LIST] permission on the specified domain or DOMAIN_SCOPE[LIST] permission on the specified environment or DOMAIN_SCOPE[LIST] permission on the specified organization Each returned scope is filtered and contains only basic information such as id, key, name, description, isSystem and isDiscovery.
   * List scopes for a security domain
   */
  async listScopes(requestParameters: ListScopesRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<ScopePage> {
    const response = await this.listScopesRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have APPLICATION_OPENID[LIST] permission on the specified application or APPLICATION_OPENID[LIST] permission on the specified domain or APPLICATION_OPENID[LIST] permission on the specified environment or APPLICATION_OPENID[LIST] permission on the specified organization
   * List secrets of an application
   */
  async listSecretsRaw(
    requestParameters: ListSecretsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<ClientSecret>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listSecrets.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listSecrets.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listSecrets.',
      );
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling listSecrets.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/secrets`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ClientSecretFromJSON));
  }

  /**
   * User must have APPLICATION_OPENID[LIST] permission on the specified application or APPLICATION_OPENID[LIST] permission on the specified domain or APPLICATION_OPENID[LIST] permission on the specified environment or APPLICATION_OPENID[LIST] permission on the specified organization
   * List secrets of an application
   */
  async listSecrets(
    requestParameters: ListSecretsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<ClientSecret>> {
    const response = await this.listSecretsRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_THEME[LIST] permission on the specified domain or DOMAIN_THEME[LIST] permission on the specified environment or DOMAIN_THEME[LIST] permission on the specified organization
   * List themes on the specified security domain
   */
  async listThemesRaw(
    requestParameters: ListThemesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<ThemeEntity>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listThemes.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listThemes.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listThemes.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/themes`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ThemeEntityFromJSON));
  }

  /**
   * User must have the DOMAIN_THEME[LIST] permission on the specified domain or DOMAIN_THEME[LIST] permission on the specified environment or DOMAIN_THEME[LIST] permission on the specified organization
   * List themes on the specified security domain
   */
  async listThemes(
    requestParameters: ListThemesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<ThemeEntity>> {
    const response = await this.listThemesRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user audit logs
   */
  async listUserAuditLogsRaw(
    requestParameters: ListUserAuditLogsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<Audit>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listUserAuditLogs.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listUserAuditLogs.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listUserAuditLogs.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling listUserAuditLogs.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.type !== undefined) {
      queryParameters['type'] = requestParameters.type;
    }

    if (requestParameters.status !== undefined) {
      queryParameters['status'] = requestParameters.status;
    }

    if (requestParameters.from !== undefined) {
      queryParameters['from'] = requestParameters.from;
    }

    if (requestParameters.to !== undefined) {
      queryParameters['to'] = requestParameters.to;
    }

    if (requestParameters.size !== undefined) {
      queryParameters['size'] = requestParameters.size;
    }

    if (requestParameters.page !== undefined) {
      queryParameters['page'] = requestParameters.page;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/audits`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AuditFromJSON));
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user audit logs
   */
  async listUserAuditLogs(
    requestParameters: ListUserAuditLogsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<Audit>> {
    const response = await this.listUserAuditLogsRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user consents
   */
  async listUserConsentsRaw(
    requestParameters: ListUserConsentsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ScopeApprovalEntity>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listUserConsents.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listUserConsents.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listUserConsents.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling listUserConsents.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.clientId !== undefined) {
      queryParameters['clientId'] = requestParameters.clientId;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/consents`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ScopeApprovalEntityFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user consents
   */
  async listUserConsents(
    requestParameters: ListUserConsentsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<ScopeApprovalEntity> {
    const response = await this.listUserConsentsRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user credentials
   */
  async listUserCredentialsRaw(
    requestParameters: ListUserCredentialsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Credential>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listUserCredentials.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listUserCredentials.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listUserCredentials.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling listUserCredentials.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/credentials`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => CredentialFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user credentials
   */
  async listUserCredentials(
    requestParameters: ListUserCredentialsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Credential> {
    const response = await this.listUserCredentialsRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER_DEVICES[LIST] permission on the specified domain or DOMAIN_USER_DEVICES[LIST] permission on the specified environment or DOMAIN_USER_DEVICES[LIST] permission on the specified organization.
   * List users for a security domain
   */
  async listUserDevicesRaw(
    requestParameters: ListUserDevicesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<User>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listUserDevices.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listUserDevices.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listUserDevices.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling listUserDevices.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/devices`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UserFromJSON));
  }

  /**
   * User must have the DOMAIN_USER_DEVICES[LIST] permission on the specified domain or DOMAIN_USER_DEVICES[LIST] permission on the specified environment or DOMAIN_USER_DEVICES[LIST] permission on the specified organization.
   * List users for a security domain
   */
  async listUserDevices(
    requestParameters: ListUserDevicesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<User>> {
    const response = await this.listUserDevicesRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user enrolled factors
   */
  async listUserEnrolledFactorsRaw(
    requestParameters: ListUserEnrolledFactorsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<EnrolledFactorEntity>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listUserEnrolledFactors.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listUserEnrolledFactors.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listUserEnrolledFactors.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling listUserEnrolledFactors.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/factors`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(EnrolledFactorEntityFromJSON));
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user enrolled factors
   */
  async listUserEnrolledFactors(
    requestParameters: ListUserEnrolledFactorsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<EnrolledFactorEntity>> {
    const response = await this.listUserEnrolledFactorsRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user linked identities
   */
  async listUserIdentitiesRaw(
    requestParameters: ListUserIdentitiesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<UserIdentityEntity>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listUserIdentities.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listUserIdentities.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listUserIdentities.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling listUserIdentities.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/identities`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UserIdentityEntityFromJSON));
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user linked identities
   */
  async listUserIdentities(
    requestParameters: ListUserIdentitiesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<UserIdentityEntity>> {
    const response = await this.listUserIdentitiesRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user roles
   */
  async listUserRolesRaw(
    requestParameters: ListUserRolesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<Role>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listUserRoles.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listUserRoles.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listUserRoles.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling listUserRoles.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.dynamic !== undefined) {
      queryParameters['dynamic'] = requestParameters.dynamic;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/roles`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(RoleFromJSON));
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user roles
   */
  async listUserRoles(
    requestParameters: ListUserRolesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<Role>> {
    const response = await this.listUserRolesRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[LIST] permission on the specified domain or DOMAIN_USER[LIST] permission on the specified environment or DOMAIN_USER[LIST] permission on the specified organization. Each returned user is filtered and contains only basic information such as id and username and displayname. Last login and identity provider name will be also returned if current user has DOMAIN_USER[READ] permission on the domain, environment or organization.
   * List users for a security domain
   */
  async listUsersRaw(
    requestParameters: ListUsersRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<UserPage>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listUsers.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listUsers.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listUsers.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.q !== undefined) {
      queryParameters['q'] = requestParameters.q;
    }

    if (requestParameters.filter !== undefined) {
      queryParameters['filter'] = requestParameters.filter;
    }

    if (requestParameters.page !== undefined) {
      queryParameters['page'] = requestParameters.page;
    }

    if (requestParameters.size !== undefined) {
      queryParameters['size'] = requestParameters.size;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => UserPageFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_USER[LIST] permission on the specified domain or DOMAIN_USER[LIST] permission on the specified environment or DOMAIN_USER[LIST] permission on the specified organization. Each returned user is filtered and contains only basic information such as id and username and displayname. Last login and identity provider name will be also returned if current user has DOMAIN_USER[READ] permission on the domain, environment or organization.
   * List users for a security domain
   */
  async listUsers(requestParameters: ListUsersRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<UserPage> {
    const response = await this.listUsersRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Lock a user
   */
  async lockUserRaw(
    requestParameters: LockUserRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling lockUser.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling lockUser.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling lockUser.');
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError('user', 'Required parameter requestParameters.user was null or undefined when calling lockUser.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/lock`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Lock a user
   */
  async lockUser(requestParameters: LockUserRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.lockUserRaw(requestParameters, initOverrides);
  }

  /**
   * Update an alert notifierUser must have DOMAIN_ALERT_NOTIFIER[UPDATE] permission on the specified domain, environment or organization.
   * Update an alert notifier
   */
  async patchAlertNotifierRaw(
    requestParameters: PatchAlertNotifierRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<AlertNotifier>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling patchAlertNotifier.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling patchAlertNotifier.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling patchAlertNotifier.',
      );
    }

    if (requestParameters.notifierId === null || requestParameters.notifierId === undefined) {
      throw new runtime.RequiredError(
        'notifierId',
        'Required parameter requestParameters.notifierId was null or undefined when calling patchAlertNotifier.',
      );
    }

    if (requestParameters.patchAlertNotifier === null || requestParameters.patchAlertNotifier === undefined) {
      throw new runtime.RequiredError(
        'patchAlertNotifier',
        'Required parameter requestParameters.patchAlertNotifier was null or undefined when calling patchAlertNotifier.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/alerts/notifiers/{notifierId}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'notifierId'}}`, encodeURIComponent(String(requestParameters.notifierId))),
        method: 'PATCH',
        headers: headerParameters,
        query: queryParameters,
        body: PatchAlertNotifierToJSON(requestParameters.patchAlertNotifier),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => AlertNotifierFromJSON(jsonValue));
  }

  /**
   * Update an alert notifierUser must have DOMAIN_ALERT_NOTIFIER[UPDATE] permission on the specified domain, environment or organization.
   * Update an alert notifier
   */
  async patchAlertNotifier(
    requestParameters: PatchAlertNotifierRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<AlertNotifier> {
    const response = await this.patchAlertNotifierRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have APPLICATION[UPDATE] permission on the specified application or APPLICATION[UPDATE] permission on the specified domain or APPLICATION[UPDATE] permission on the specified environment or APPLICATION[UPDATE] permission on the specified organization
   * Patch an application
   */
  async patchApplicationRaw(
    requestParameters: PatchApplicationRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Application>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling patchApplication.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling patchApplication.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling patchApplication.',
      );
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling patchApplication.',
      );
    }

    if (requestParameters.patchApplication === null || requestParameters.patchApplication === undefined) {
      throw new runtime.RequiredError(
        'patchApplication',
        'Required parameter requestParameters.patchApplication was null or undefined when calling patchApplication.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application))),
        method: 'PATCH',
        headers: headerParameters,
        query: queryParameters,
        body: PatchApplicationToJSON(requestParameters.patchApplication),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ApplicationFromJSON(jsonValue));
  }

  /**
   * User must have APPLICATION[UPDATE] permission on the specified application or APPLICATION[UPDATE] permission on the specified domain or APPLICATION[UPDATE] permission on the specified environment or APPLICATION[UPDATE] permission on the specified organization
   * Patch an application
   */
  async patchApplication(
    requestParameters: PatchApplicationRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Application> {
    const response = await this.patchApplicationRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_SETTINGS[UPDATE] permission on the specified domain or DOMAIN_SETTINGS[UPDATE] permission on the specified environment or DOMAIN_SETTINGS[UPDATE] permission on the specified organization.
   * Patch the security domain
   */
  async patchDomainRaw(
    requestParameters: PatchDomainRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Domain>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling patchDomain.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling patchDomain.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling patchDomain.',
      );
    }

    if (requestParameters.patchDomain === null || requestParameters.patchDomain === undefined) {
      throw new runtime.RequiredError(
        'patchDomain',
        'Required parameter requestParameters.patchDomain was null or undefined when calling patchDomain.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'PATCH',
        headers: headerParameters,
        query: queryParameters,
        body: PatchDomainToJSON(requestParameters.patchDomain),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => DomainFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_SETTINGS[UPDATE] permission on the specified domain or DOMAIN_SETTINGS[UPDATE] permission on the specified environment or DOMAIN_SETTINGS[UPDATE] permission on the specified organization.
   * Patch the security domain
   */
  async patchDomain(requestParameters: PatchDomainRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Domain> {
    const response = await this.patchDomainRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_SCOPE[UPDATE] permission on the specified domain or DOMAIN_SCOPE[UPDATE] permission on the specified environment or DOMAIN_SCOPE[UPDATE] permission on the specified organization
   * Patch a scope
   */
  async patchScopeRaw(
    requestParameters: PatchScopeRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Scope>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling patchScope.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling patchScope.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling patchScope.',
      );
    }

    if (requestParameters.scope === null || requestParameters.scope === undefined) {
      throw new runtime.RequiredError('scope', 'Required parameter requestParameters.scope was null or undefined when calling patchScope.');
    }

    if (requestParameters.patchScope === null || requestParameters.patchScope === undefined) {
      throw new runtime.RequiredError(
        'patchScope',
        'Required parameter requestParameters.patchScope was null or undefined when calling patchScope.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/scopes/{scope}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'scope'}}`, encodeURIComponent(String(requestParameters.scope))),
        method: 'PATCH',
        headers: headerParameters,
        query: queryParameters,
        body: PatchScopeToJSON(requestParameters.patchScope),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ScopeFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_SCOPE[UPDATE] permission on the specified domain or DOMAIN_SCOPE[UPDATE] permission on the specified environment or DOMAIN_SCOPE[UPDATE] permission on the specified organization
   * Patch a scope
   */
  async patchScope(requestParameters: PatchScopeRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Scope> {
    const response = await this.patchScopeRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_I18N_DICTIONARY[UPDATE] permission on the specified domain or DOMAIN_I18N_DICTIONARY[UPDATE] permission on the specified environment or DOMAIN_I18N_DICTIONARY[UPDATE] permission on the specified organization.
   * Update a i18n dictionary description
   */
  async putI18nDictionaryRaw(
    requestParameters: PutI18nDictionaryRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<I18nDictionary>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling putI18nDictionary.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling putI18nDictionary.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling putI18nDictionary.',
      );
    }

    if (requestParameters.dictionary === null || requestParameters.dictionary === undefined) {
      throw new runtime.RequiredError(
        'dictionary',
        'Required parameter requestParameters.dictionary was null or undefined when calling putI18nDictionary.',
      );
    }

    if (requestParameters.updateI18nDictionary === null || requestParameters.updateI18nDictionary === undefined) {
      throw new runtime.RequiredError(
        'updateI18nDictionary',
        'Required parameter requestParameters.updateI18nDictionary was null or undefined when calling putI18nDictionary.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/i18n/dictionaries/{dictionary}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'dictionary'}}`, encodeURIComponent(String(requestParameters.dictionary))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: UpdateI18nDictionaryToJSON(requestParameters.updateI18nDictionary),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => I18nDictionaryFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_I18N_DICTIONARY[UPDATE] permission on the specified domain or DOMAIN_I18N_DICTIONARY[UPDATE] permission on the specified environment or DOMAIN_I18N_DICTIONARY[UPDATE] permission on the specified organization.
   * Update a i18n dictionary description
   */
  async putI18nDictionary(
    requestParameters: PutI18nDictionaryRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<I18nDictionary> {
    const response = await this.putI18nDictionaryRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have APPLICATION_MEMBER[DELETE] permission on the specified application or APPLICATION_MEMBER[DELETE] permission on the specified domain or APPLICATION_MEMBER[DELETE] permission on the specified environment or APPLICATION_MEMBER[DELETE] permission on the specified organization
   * Remove a membership
   */
  async removeApplicationMemberRaw(
    requestParameters: RemoveApplicationMemberRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling removeApplicationMember.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling removeApplicationMember.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling removeApplicationMember.',
      );
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling removeApplicationMember.',
      );
    }

    if (requestParameters.member === null || requestParameters.member === undefined) {
      throw new runtime.RequiredError(
        'member',
        'Required parameter requestParameters.member was null or undefined when calling removeApplicationMember.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/members/{member}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application)))
          .replace(`{${'member'}}`, encodeURIComponent(String(requestParameters.member))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have APPLICATION_MEMBER[DELETE] permission on the specified application or APPLICATION_MEMBER[DELETE] permission on the specified domain or APPLICATION_MEMBER[DELETE] permission on the specified environment or APPLICATION_MEMBER[DELETE] permission on the specified organization
   * Remove a membership
   */
  async removeApplicationMember(
    requestParameters: RemoveApplicationMemberRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.removeApplicationMemberRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_GROUP[UPDATE] permission on the specified domain or DOMAIN_GROUP[UPDATE] permission on the specified environment or DOMAIN_GROUP[UPDATE] permission on the specified organization
   * Remove a group member
   */
  async removeGroupMemberRaw(
    requestParameters: RemoveGroupMemberRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling removeGroupMember.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling removeGroupMember.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling removeGroupMember.',
      );
    }

    if (requestParameters.group === null || requestParameters.group === undefined) {
      throw new runtime.RequiredError(
        'group',
        'Required parameter requestParameters.group was null or undefined when calling removeGroupMember.',
      );
    }

    if (requestParameters.member === null || requestParameters.member === undefined) {
      throw new runtime.RequiredError(
        'member',
        'Required parameter requestParameters.member was null or undefined when calling removeGroupMember.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/groups/{group}/members/{member}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'group'}}`, encodeURIComponent(String(requestParameters.group)))
          .replace(`{${'member'}}`, encodeURIComponent(String(requestParameters.member))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_GROUP[UPDATE] permission on the specified domain or DOMAIN_GROUP[UPDATE] permission on the specified environment or DOMAIN_GROUP[UPDATE] permission on the specified organization
   * Remove a group member
   */
  async removeGroupMember(
    requestParameters: RemoveGroupMemberRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.removeGroupMemberRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_MEMBER[DELETE] permission on the specified domain or DOMAIN_MEMBER[DELETE] permission on the specified environment or DOMAIN_MEMBER[DELETE] permission on the specified organization
   * Remove a membership
   */
  async removeMemberRaw(
    requestParameters: RemoveMemberRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling removeMember.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling removeMember.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling removeMember.',
      );
    }

    if (requestParameters.member === null || requestParameters.member === undefined) {
      throw new runtime.RequiredError(
        'member',
        'Required parameter requestParameters.member was null or undefined when calling removeMember.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/members/{member}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'member'}}`, encodeURIComponent(String(requestParameters.member))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_MEMBER[DELETE] permission on the specified domain or DOMAIN_MEMBER[DELETE] permission on the specified environment or DOMAIN_MEMBER[DELETE] permission on the specified organization
   * Remove a membership
   */
  async removeMember(requestParameters: RemoveMemberRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.removeMemberRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_THEME[READ] permission on the specified domain or DOMAIN_THEME[READ] permission on the specified environment or DOMAIN_THEME[READ] permission on the specified organization
   * Render the provided template
   */
  async renderDomainTemplateRaw(
    requestParameters: RenderDomainTemplateRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<PreviewResponse>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling renderDomainTemplate.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling renderDomainTemplate.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling renderDomainTemplate.',
      );
    }

    if (requestParameters.previewRequest === null || requestParameters.previewRequest === undefined) {
      throw new runtime.RequiredError(
        'previewRequest',
        'Required parameter requestParameters.previewRequest was null or undefined when calling renderDomainTemplate.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/forms/preview`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: PreviewRequestToJSON(requestParameters.previewRequest),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => PreviewResponseFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_THEME[READ] permission on the specified domain or DOMAIN_THEME[READ] permission on the specified environment or DOMAIN_THEME[READ] permission on the specified organization
   * Render the provided template
   */
  async renderDomainTemplate(
    requestParameters: RenderDomainTemplateRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<PreviewResponse> {
    const response = await this.renderDomainTemplateRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have APPLICATION_OPENID[UPDATE] permission on the specified application or APPLICATION_OPENID[UPDATE] permission on the specified domain or APPLICATION_OPENID[UPDATE] permission on the specified environment or APPLICATION_OPENID[UPDATE] permission on the specified organization
   * Renew application secret
   */
  async renewClientSecretRaw(
    requestParameters: RenewClientSecretRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ClientSecret>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling renewClientSecret.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling renewClientSecret.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling renewClientSecret.',
      );
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling renewClientSecret.',
      );
    }

    if (requestParameters.secret === null || requestParameters.secret === undefined) {
      throw new runtime.RequiredError(
        'secret',
        'Required parameter requestParameters.secret was null or undefined when calling renewClientSecret.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/secrets/{secret}/_renew`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application)))
          .replace(`{${'secret'}}`, encodeURIComponent(String(requestParameters.secret))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ClientSecretFromJSON(jsonValue));
  }

  /**
   * User must have APPLICATION_OPENID[UPDATE] permission on the specified application or APPLICATION_OPENID[UPDATE] permission on the specified domain or APPLICATION_OPENID[UPDATE] permission on the specified environment or APPLICATION_OPENID[UPDATE] permission on the specified organization
   * Renew application secret
   */
  async renewClientSecret(
    requestParameters: RenewClientSecretRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<ClientSecret> {
    const response = await this.renewClientSecretRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_I18N_DICTIONARY[UPDATE] permission on the specified domain or DOMAIN_I18N_DICTIONARY[UPDATE] permission on the specified environment or DOMAIN_I18N_DICTIONARY[UPDATE] permission on the specified organization.
   * Update all the entries for a i18n dictionary description
   */
  async replaceI18nDictionaryEntriesRaw(
    requestParameters: ReplaceI18nDictionaryEntriesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<I18nDictionary>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling replaceI18nDictionaryEntries.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling replaceI18nDictionaryEntries.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling replaceI18nDictionaryEntries.',
      );
    }

    if (requestParameters.dictionary === null || requestParameters.dictionary === undefined) {
      throw new runtime.RequiredError(
        'dictionary',
        'Required parameter requestParameters.dictionary was null or undefined when calling replaceI18nDictionaryEntries.',
      );
    }

    if (requestParameters.requestBody === null || requestParameters.requestBody === undefined) {
      throw new runtime.RequiredError(
        'requestBody',
        'Required parameter requestParameters.requestBody was null or undefined when calling replaceI18nDictionaryEntries.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/i18n/dictionaries/{dictionary}/entries`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'dictionary'}}`, encodeURIComponent(String(requestParameters.dictionary))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.requestBody,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => I18nDictionaryFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_I18N_DICTIONARY[UPDATE] permission on the specified domain or DOMAIN_I18N_DICTIONARY[UPDATE] permission on the specified environment or DOMAIN_I18N_DICTIONARY[UPDATE] permission on the specified organization.
   * Update all the entries for a i18n dictionary description
   */
  async replaceI18nDictionaryEntries(
    requestParameters: ReplaceI18nDictionaryEntriesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<I18nDictionary> {
    const response = await this.replaceI18nDictionaryEntriesRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Reset password
   */
  async resetPasswordRaw(
    requestParameters: ResetPasswordRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling resetPassword.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling resetPassword.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling resetPassword.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling resetPassword.',
      );
    }

    if (requestParameters.passwordValue === null || requestParameters.passwordValue === undefined) {
      throw new runtime.RequiredError(
        'passwordValue',
        'Required parameter requestParameters.passwordValue was null or undefined when calling resetPassword.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/resetPassword`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: PasswordValueToJSON(requestParameters.passwordValue),
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Reset password
   */
  async resetPassword(requestParameters: ResetPasswordRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.resetPasswordRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_GROUP[UPDATE] permission on the specified domain or DOMAIN_GROUP[UPDATE] permission on the specified environment or DOMAIN_GROUP[UPDATE] permission on the specified organization
   * Revoke role to a group
   */
  async revokeRoleRaw(
    requestParameters: RevokeRoleRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Group>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling revokeRole.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling revokeRole.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling revokeRole.',
      );
    }

    if (requestParameters.group === null || requestParameters.group === undefined) {
      throw new runtime.RequiredError('group', 'Required parameter requestParameters.group was null or undefined when calling revokeRole.');
    }

    if (requestParameters.role === null || requestParameters.role === undefined) {
      throw new runtime.RequiredError('role', 'Required parameter requestParameters.role was null or undefined when calling revokeRole.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/groups/{group}/roles/{role}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'group'}}`, encodeURIComponent(String(requestParameters.group)))
          .replace(`{${'role'}}`, encodeURIComponent(String(requestParameters.role))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => GroupFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_GROUP[UPDATE] permission on the specified domain or DOMAIN_GROUP[UPDATE] permission on the specified environment or DOMAIN_GROUP[UPDATE] permission on the specified organization
   * Revoke role to a group
   */
  async revokeRole(requestParameters: RevokeRoleRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Group> {
    const response = await this.revokeRoleRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Revoke a user consent
   */
  async revokeUserConsentRaw(
    requestParameters: RevokeUserConsentRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling revokeUserConsent.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling revokeUserConsent.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling revokeUserConsent.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling revokeUserConsent.',
      );
    }

    if (requestParameters.consent === null || requestParameters.consent === undefined) {
      throw new runtime.RequiredError(
        'consent',
        'Required parameter requestParameters.consent was null or undefined when calling revokeUserConsent.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/consents/{consent}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user)))
          .replace(`{${'consent'}}`, encodeURIComponent(String(requestParameters.consent))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Revoke a user consent
   */
  async revokeUserConsent(
    requestParameters: RevokeUserConsentRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.revokeUserConsentRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Revoke user consents
   */
  async revokeUserConsentsRaw(
    requestParameters: RevokeUserConsentsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling revokeUserConsents.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling revokeUserConsents.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling revokeUserConsents.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling revokeUserConsents.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.clientId !== undefined) {
      queryParameters['clientId'] = requestParameters.clientId;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/consents`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Revoke user consents
   */
  async revokeUserConsents(
    requestParameters: RevokeUserConsentsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.revokeUserConsentsRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Revoke a user credential
   */
  async revokeUserCredentialRaw(
    requestParameters: RevokeUserCredentialRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling revokeUserCredential.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling revokeUserCredential.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling revokeUserCredential.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling revokeUserCredential.',
      );
    }

    if (requestParameters.credential === null || requestParameters.credential === undefined) {
      throw new runtime.RequiredError(
        'credential',
        'Required parameter requestParameters.credential was null or undefined when calling revokeUserCredential.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/credentials/{credential}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user)))
          .replace(`{${'credential'}}`, encodeURIComponent(String(requestParameters.credential))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Revoke a user credential
   */
  async revokeUserCredential(
    requestParameters: RevokeUserCredentialRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.revokeUserCredentialRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Revoke role to a user
   */
  async revokeUserRoleRaw(
    requestParameters: RevokeUserRoleRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<User>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling revokeUserRole.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling revokeUserRole.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling revokeUserRole.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling revokeUserRole.',
      );
    }

    if (requestParameters.role === null || requestParameters.role === undefined) {
      throw new runtime.RequiredError(
        'role',
        'Required parameter requestParameters.role was null or undefined when calling revokeUserRole.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/roles/{role}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user)))
          .replace(`{${'role'}}`, encodeURIComponent(String(requestParameters.role))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Revoke role to a user
   */
  async revokeUserRole(requestParameters: RevokeUserRoleRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<User> {
    const response = await this.revokeUserRoleRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_CERTIFICATE[CREATE] permission on the specified domain or DOMAIN_CERTIFICATE[CREATE] permission on the specified environment or DOMAIN_CERTIFICATE[CREATE] permission on the specified organization
   * Generate a new System a certificate
   */
  async rotateCertificateRaw(
    requestParameters: RotateCertificateRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<CertificateEntity>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling rotateCertificate.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling rotateCertificate.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling rotateCertificate.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/certificates/rotate`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => CertificateEntityFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_CERTIFICATE[CREATE] permission on the specified domain or DOMAIN_CERTIFICATE[CREATE] permission on the specified environment or DOMAIN_CERTIFICATE[CREATE] permission on the specified organization
   * Generate a new System a certificate
   */
  async rotateCertificate(
    requestParameters: RotateCertificateRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<CertificateEntity> {
    const response = await this.rotateCertificateRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Send registration confirmation email
   */
  async sendRegistrationConfirmationRaw(
    requestParameters: SendRegistrationConfirmationRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling sendRegistrationConfirmation.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling sendRegistrationConfirmation.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling sendRegistrationConfirmation.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling sendRegistrationConfirmation.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/sendRegistrationConfirmation`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Send registration confirmation email
   */
  async sendRegistrationConfirmation(
    requestParameters: SendRegistrationConfirmationRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.sendRegistrationConfirmationRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_SETTINGS[UPDATE] permission on the specified domain or DOMAIN_SETTINGS[UPDATE] permission on the specified environment or DOMAIN_SETTINGS[UPDATE] permission on the specified organization
   * Set default policy
   */
  async setDefaultPolicyRaw(
    requestParameters: SetDefaultPolicyRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<PasswordPolicy>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling setDefaultPolicy.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling setDefaultPolicy.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling setDefaultPolicy.',
      );
    }

    if (requestParameters.policy === null || requestParameters.policy === undefined) {
      throw new runtime.RequiredError(
        'policy',
        'Required parameter requestParameters.policy was null or undefined when calling setDefaultPolicy.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/password-policies/{policy}/default`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'policy'}}`, encodeURIComponent(String(requestParameters.policy))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => PasswordPolicyFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_SETTINGS[UPDATE] permission on the specified domain or DOMAIN_SETTINGS[UPDATE] permission on the specified environment or DOMAIN_SETTINGS[UPDATE] permission on the specified organization
   * Set default policy
   */
  async setDefaultPolicy(
    requestParameters: SetDefaultPolicyRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<PasswordPolicy> {
    const response = await this.setDefaultPolicyRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Unlink user identity
   */
  async unlinkUserIdentityRaw(
    requestParameters: UnlinkUserIdentityRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling unlinkUserIdentity.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling unlinkUserIdentity.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling unlinkUserIdentity.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling unlinkUserIdentity.',
      );
    }

    if (requestParameters.identity === null || requestParameters.identity === undefined) {
      throw new runtime.RequiredError(
        'identity',
        'Required parameter requestParameters.identity was null or undefined when calling unlinkUserIdentity.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/identities/{identity}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user)))
          .replace(`{${'identity'}}`, encodeURIComponent(String(requestParameters.identity))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Unlink user identity
   */
  async unlinkUserIdentity(
    requestParameters: UnlinkUserIdentityRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.unlinkUserIdentityRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Unlock a user
   */
  async unlockUserRaw(
    requestParameters: UnlockUserRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling unlockUser.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling unlockUser.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling unlockUser.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError('user', 'Required parameter requestParameters.user was null or undefined when calling unlockUser.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/unlock`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Unlock a user
   */
  async unlockUser(requestParameters: UnlockUserRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.unlockUserRaw(requestParameters, initOverrides);
  }

  /**
   * Update multiple alert triggers in the same timeUser must have DOMAIN_ALERT[UPDATE] permission on the specified domain, environment or organization.
   * Update multiple alert triggers
   */
  async updateAlertTriggersRaw(
    requestParameters: UpdateAlertTriggersRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<AlertTrigger>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateAlertTriggers.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateAlertTriggers.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateAlertTriggers.',
      );
    }

    if (requestParameters.patchAlertTrigger === null || requestParameters.patchAlertTrigger === undefined) {
      throw new runtime.RequiredError(
        'patchAlertTrigger',
        'Required parameter requestParameters.patchAlertTrigger was null or undefined when calling updateAlertTriggers.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/alerts/triggers`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'PATCH',
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.patchAlertTrigger.map(PatchAlertTriggerToJSON),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AlertTriggerFromJSON));
  }

  /**
   * Update multiple alert triggers in the same timeUser must have DOMAIN_ALERT[UPDATE] permission on the specified domain, environment or organization.
   * Update multiple alert triggers
   */
  async updateAlertTriggers(
    requestParameters: UpdateAlertTriggersRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<AlertTrigger>> {
    const response = await this.updateAlertTriggersRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the APPLICATION_FLOW[UPDATE] permission on the specified domain or APPLICATION_FLOW[UPDATE] permission on the specified environment or APPLICATION_FLOW[UPDATE] permission on the specified organization
   * Update a flow
   */
  async updateAppFlowRaw(
    requestParameters: UpdateAppFlowRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<FlowEntity>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateAppFlow.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateAppFlow.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateAppFlow.',
      );
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling updateAppFlow.',
      );
    }

    if (requestParameters.flow === null || requestParameters.flow === undefined) {
      throw new runtime.RequiredError(
        'flow',
        'Required parameter requestParameters.flow was null or undefined when calling updateAppFlow.',
      );
    }

    if (requestParameters.flow2 === null || requestParameters.flow2 === undefined) {
      throw new runtime.RequiredError(
        'flow2',
        'Required parameter requestParameters.flow2 was null or undefined when calling updateAppFlow.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/flows/{flow}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application)))
          .replace(`{${'flow'}}`, encodeURIComponent(String(requestParameters.flow))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: FlowToJSON(requestParameters.flow2),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => FlowEntityFromJSON(jsonValue));
  }

  /**
   * User must have the APPLICATION_FLOW[UPDATE] permission on the specified domain or APPLICATION_FLOW[UPDATE] permission on the specified environment or APPLICATION_FLOW[UPDATE] permission on the specified organization
   * Update a flow
   */
  async updateAppFlow(
    requestParameters: UpdateAppFlowRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<FlowEntity> {
    const response = await this.updateAppFlowRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have APPLICATION[UPDATE] permission on the specified application or APPLICATION[UPDATE] permission on the specified domain or APPLICATION[UPDATE] permission on the specified environment or APPLICATION[UPDATE] permission on the specified organization
   * Update an application
   */
  async updateApplicationRaw(
    requestParameters: UpdateApplicationRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Application>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateApplication.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateApplication.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateApplication.',
      );
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling updateApplication.',
      );
    }

    if (requestParameters.patchApplication === null || requestParameters.patchApplication === undefined) {
      throw new runtime.RequiredError(
        'patchApplication',
        'Required parameter requestParameters.patchApplication was null or undefined when calling updateApplication.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: PatchApplicationToJSON(requestParameters.patchApplication),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ApplicationFromJSON(jsonValue));
  }

  /**
   * User must have APPLICATION[UPDATE] permission on the specified application or APPLICATION[UPDATE] permission on the specified domain or APPLICATION[UPDATE] permission on the specified environment or APPLICATION[UPDATE] permission on the specified organization
   * Update an application
   */
  async updateApplication(
    requestParameters: UpdateApplicationRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Application> {
    const response = await this.updateApplicationRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have APPLICATION_EMAIL_TEMPLATE[UPDATE] permission on the specified application or APPLICATION_EMAIL_TEMPLATE[UPDATE] permission on the specified domain or APPLICATION_EMAIL_TEMPLATE[UPDATE] permission on the specified environment or APPLICATION_EMAIL_TEMPLATE[UPDATE] permission on the specified organization
   * Update an email for an application
   */
  async updateApplicationEmailRaw(
    requestParameters: UpdateApplicationEmailRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Email>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateApplicationEmail.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateApplicationEmail.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateApplicationEmail.',
      );
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling updateApplicationEmail.',
      );
    }

    if (requestParameters.email === null || requestParameters.email === undefined) {
      throw new runtime.RequiredError(
        'email',
        'Required parameter requestParameters.email was null or undefined when calling updateApplicationEmail.',
      );
    }

    if (requestParameters.updateEmail === null || requestParameters.updateEmail === undefined) {
      throw new runtime.RequiredError(
        'updateEmail',
        'Required parameter requestParameters.updateEmail was null or undefined when calling updateApplicationEmail.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/emails/{email}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application)))
          .replace(`{${'email'}}`, encodeURIComponent(String(requestParameters.email))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: UpdateEmailToJSON(requestParameters.updateEmail),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => EmailFromJSON(jsonValue));
  }

  /**
   * User must have APPLICATION_EMAIL_TEMPLATE[UPDATE] permission on the specified application or APPLICATION_EMAIL_TEMPLATE[UPDATE] permission on the specified domain or APPLICATION_EMAIL_TEMPLATE[UPDATE] permission on the specified environment or APPLICATION_EMAIL_TEMPLATE[UPDATE] permission on the specified organization
   * Update an email for an application
   */
  async updateApplicationEmail(
    requestParameters: UpdateApplicationEmailRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Email> {
    const response = await this.updateApplicationEmailRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have APPLICATION_FORM[UPDATE] permission on the specified application or APPLICATION_FORM[UPDATE] permission on the specified domain or APPLICATION_FORM[UPDATE] permission on the specified environment or APPLICATION_FORM[UPDATE] permission on the specified organization
   * Update a form for an application
   */
  async updateApplicationFormRaw(
    requestParameters: UpdateApplicationFormRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Form>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateApplicationForm.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateApplicationForm.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateApplicationForm.',
      );
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling updateApplicationForm.',
      );
    }

    if (requestParameters.form === null || requestParameters.form === undefined) {
      throw new runtime.RequiredError(
        'form',
        'Required parameter requestParameters.form was null or undefined when calling updateApplicationForm.',
      );
    }

    if (requestParameters.updateForm === null || requestParameters.updateForm === undefined) {
      throw new runtime.RequiredError(
        'updateForm',
        'Required parameter requestParameters.updateForm was null or undefined when calling updateApplicationForm.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/forms/{form}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application)))
          .replace(`{${'form'}}`, encodeURIComponent(String(requestParameters.form))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: UpdateFormToJSON(requestParameters.updateForm),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => FormFromJSON(jsonValue));
  }

  /**
   * User must have APPLICATION_FORM[UPDATE] permission on the specified application or APPLICATION_FORM[UPDATE] permission on the specified domain or APPLICATION_FORM[UPDATE] permission on the specified environment or APPLICATION_FORM[UPDATE] permission on the specified organization
   * Update a form for an application
   */
  async updateApplicationForm(
    requestParameters: UpdateApplicationFormRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Form> {
    const response = await this.updateApplicationFormRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have APPLICATION[UPDATE] permission on the specified application or APPLICATION[UPDATE] permission on the specified domain or APPLICATION[UPDATE] permission on the specified environment or APPLICATION[UPDATE] permission on the specified organization
   * Update an application type
   */
  async updateApplicationTypeRaw(
    requestParameters: UpdateApplicationTypeRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Application>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateApplicationType.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateApplicationType.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateApplicationType.',
      );
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling updateApplicationType.',
      );
    }

    if (requestParameters.patchApplicationType === null || requestParameters.patchApplicationType === undefined) {
      throw new runtime.RequiredError(
        'patchApplicationType',
        'Required parameter requestParameters.patchApplicationType was null or undefined when calling updateApplicationType.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/type`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: PatchApplicationTypeToJSON(requestParameters.patchApplicationType),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ApplicationFromJSON(jsonValue));
  }

  /**
   * User must have APPLICATION[UPDATE] permission on the specified application or APPLICATION[UPDATE] permission on the specified domain or APPLICATION[UPDATE] permission on the specified environment or APPLICATION[UPDATE] permission on the specified organization
   * Update an application type
   */
  async updateApplicationType(
    requestParameters: UpdateApplicationTypeRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Application> {
    const response = await this.updateApplicationTypeRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_AUTHDEVICE_NOTIFIER[UPDATE] permission on the specified domain or DOMAIN_AUTHDEVICE_NOTIFIER[UPDATE] permission on the specified environment or DOMAIN_AUTHDEVICE_NOTIFIER[UPDATE] permission on the specified organization
   * Update an Authentication Device Notifier
   */
  async updateAuthenticationDeviceNotifierRaw(
    requestParameters: UpdateAuthenticationDeviceNotifierRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<AuthenticationDeviceNotifier>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateAuthenticationDeviceNotifier.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateAuthenticationDeviceNotifier.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateAuthenticationDeviceNotifier.',
      );
    }

    if (requestParameters.authDeviceNotifier === null || requestParameters.authDeviceNotifier === undefined) {
      throw new runtime.RequiredError(
        'authDeviceNotifier',
        'Required parameter requestParameters.authDeviceNotifier was null or undefined when calling updateAuthenticationDeviceNotifier.',
      );
    }

    if (
      requestParameters.updateAuthenticationDeviceNotifier === null ||
      requestParameters.updateAuthenticationDeviceNotifier === undefined
    ) {
      throw new runtime.RequiredError(
        'updateAuthenticationDeviceNotifier',
        'Required parameter requestParameters.updateAuthenticationDeviceNotifier was null or undefined when calling updateAuthenticationDeviceNotifier.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/auth-device-notifiers/{authDeviceNotifier}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'authDeviceNotifier'}}`, encodeURIComponent(String(requestParameters.authDeviceNotifier))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: UpdateAuthenticationDeviceNotifierToJSON(requestParameters.updateAuthenticationDeviceNotifier),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => AuthenticationDeviceNotifierFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_AUTHDEVICE_NOTIFIER[UPDATE] permission on the specified domain or DOMAIN_AUTHDEVICE_NOTIFIER[UPDATE] permission on the specified environment or DOMAIN_AUTHDEVICE_NOTIFIER[UPDATE] permission on the specified organization
   * Update an Authentication Device Notifier
   */
  async updateAuthenticationDeviceNotifier(
    requestParameters: UpdateAuthenticationDeviceNotifierRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<AuthenticationDeviceNotifier> {
    const response = await this.updateAuthenticationDeviceNotifierRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_AUTHORIZATION_ENGINE[UPDATE] permission on the specified domain or DOMAIN_AUTHORIZATION_ENGINE[UPDATE] permission on the specified environment or DOMAIN_AUTHORIZATION_ENGINE[UPDATE] permission on the specified organization
   * Update an authorization engine
   */
  async updateAuthorizationEngineRaw(
    requestParameters: UpdateAuthorizationEngineRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<AuthorizationEngine>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateAuthorizationEngine.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateAuthorizationEngine.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateAuthorizationEngine.',
      );
    }

    if (requestParameters.engineId === null || requestParameters.engineId === undefined) {
      throw new runtime.RequiredError(
        'engineId',
        'Required parameter requestParameters.engineId was null or undefined when calling updateAuthorizationEngine.',
      );
    }

    if (requestParameters.updateAuthorizationEngine === null || requestParameters.updateAuthorizationEngine === undefined) {
      throw new runtime.RequiredError(
        'updateAuthorizationEngine',
        'Required parameter requestParameters.updateAuthorizationEngine was null or undefined when calling updateAuthorizationEngine.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/authorization-engines/{engineId}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'engineId'}}`, encodeURIComponent(String(requestParameters.engineId))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: UpdateAuthorizationEngineToJSON(requestParameters.updateAuthorizationEngine),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => AuthorizationEngineFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_AUTHORIZATION_ENGINE[UPDATE] permission on the specified domain or DOMAIN_AUTHORIZATION_ENGINE[UPDATE] permission on the specified environment or DOMAIN_AUTHORIZATION_ENGINE[UPDATE] permission on the specified organization
   * Update an authorization engine
   */
  async updateAuthorizationEngine(
    requestParameters: UpdateAuthorizationEngineRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<AuthorizationEngine> {
    const response = await this.updateAuthorizationEngineRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_BOT_DETECTION[UPDATE] permission on the specified domain or DOMAIN_BOT_DETECTION[UPDATE] permission on the specified environment or DOMAIN_BOT_DETECTION[UPDATE] permission on the specified organization
   * Update a bot detection
   */
  async updateBotDetectionRaw(
    requestParameters: UpdateBotDetectionRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<BotDetection>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateBotDetection.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateBotDetection.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateBotDetection.',
      );
    }

    if (requestParameters.botDetection === null || requestParameters.botDetection === undefined) {
      throw new runtime.RequiredError(
        'botDetection',
        'Required parameter requestParameters.botDetection was null or undefined when calling updateBotDetection.',
      );
    }

    if (requestParameters.updateBotDetection === null || requestParameters.updateBotDetection === undefined) {
      throw new runtime.RequiredError(
        'updateBotDetection',
        'Required parameter requestParameters.updateBotDetection was null or undefined when calling updateBotDetection.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/bot-detections/{botDetection}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'botDetection'}}`, encodeURIComponent(String(requestParameters.botDetection))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: UpdateBotDetectionToJSON(requestParameters.updateBotDetection),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => BotDetectionFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_BOT_DETECTION[UPDATE] permission on the specified domain or DOMAIN_BOT_DETECTION[UPDATE] permission on the specified environment or DOMAIN_BOT_DETECTION[UPDATE] permission on the specified organization
   * Update a bot detection
   */
  async updateBotDetection(
    requestParameters: UpdateBotDetectionRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<BotDetection> {
    const response = await this.updateBotDetectionRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_CERTIFICATE[UPDATE] permission on the specified domain or DOMAIN_CERTIFICATE[UPDATE] permission on the specified environment or DOMAIN_CERTIFICATE[UPDATE] permission on the specified organization
   * Update a certificate
   */
  async updateCertificateRaw(
    requestParameters: UpdateCertificateRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ModifiedCertificateEntity>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateCertificate.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateCertificate.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateCertificate.',
      );
    }

    if (requestParameters.certificate === null || requestParameters.certificate === undefined) {
      throw new runtime.RequiredError(
        'certificate',
        'Required parameter requestParameters.certificate was null or undefined when calling updateCertificate.',
      );
    }

    if (requestParameters.updateCertificate === null || requestParameters.updateCertificate === undefined) {
      throw new runtime.RequiredError(
        'updateCertificate',
        'Required parameter requestParameters.updateCertificate was null or undefined when calling updateCertificate.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/certificates/{certificate}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'certificate'}}`, encodeURIComponent(String(requestParameters.certificate))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: UpdateCertificateToJSON(requestParameters.updateCertificate),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ModifiedCertificateEntityFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_CERTIFICATE[UPDATE] permission on the specified domain or DOMAIN_CERTIFICATE[UPDATE] permission on the specified environment or DOMAIN_CERTIFICATE[UPDATE] permission on the specified organization
   * Update a certificate
   */
  async updateCertificate(
    requestParameters: UpdateCertificateRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<ModifiedCertificateEntity> {
    const response = await this.updateCertificateRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_DEVICE_IDENTIFIER[UPDATE] permission on the specified domain or DOMAIN_DEVICE_IDENTIFIER[UPDATE] permission on the specified environment or DOMAIN_DEVICE_IDENTIFIER[UPDATE] permission on the specified organization
   * Update a Device identifier
   */
  async updateDeviceIdentifierRaw(
    requestParameters: UpdateDeviceIdentifierRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<DeviceIdentifier>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateDeviceIdentifier.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateDeviceIdentifier.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateDeviceIdentifier.',
      );
    }

    if (requestParameters.deviceIdentifier === null || requestParameters.deviceIdentifier === undefined) {
      throw new runtime.RequiredError(
        'deviceIdentifier',
        'Required parameter requestParameters.deviceIdentifier was null or undefined when calling updateDeviceIdentifier.',
      );
    }

    if (requestParameters.updateDeviceIdentifier === null || requestParameters.updateDeviceIdentifier === undefined) {
      throw new runtime.RequiredError(
        'updateDeviceIdentifier',
        'Required parameter requestParameters.updateDeviceIdentifier was null or undefined when calling updateDeviceIdentifier.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/device-identifiers/{deviceIdentifier}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'deviceIdentifier'}}`, encodeURIComponent(String(requestParameters.deviceIdentifier))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: UpdateDeviceIdentifierToJSON(requestParameters.updateDeviceIdentifier),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => DeviceIdentifierFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_DEVICE_IDENTIFIER[UPDATE] permission on the specified domain or DOMAIN_DEVICE_IDENTIFIER[UPDATE] permission on the specified environment or DOMAIN_DEVICE_IDENTIFIER[UPDATE] permission on the specified organization
   * Update a Device identifier
   */
  async updateDeviceIdentifier(
    requestParameters: UpdateDeviceIdentifierRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<DeviceIdentifier> {
    const response = await this.updateDeviceIdentifierRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_SETTINGS[UPDATE] permission on the specified domain or DOMAIN_SETTINGS[UPDATE] permission on the specified environment or DOMAIN_SETTINGS[UPDATE] permission on the specified organization.
   * Update the security domain
   */
  async updateDomainRaw(
    requestParameters: UpdateDomainRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Domain>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateDomain.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateDomain.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateDomain.',
      );
    }

    if (requestParameters.patchDomain === null || requestParameters.patchDomain === undefined) {
      throw new runtime.RequiredError(
        'patchDomain',
        'Required parameter requestParameters.patchDomain was null or undefined when calling updateDomain.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: PatchDomainToJSON(requestParameters.patchDomain),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => DomainFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_SETTINGS[UPDATE] permission on the specified domain or DOMAIN_SETTINGS[UPDATE] permission on the specified environment or DOMAIN_SETTINGS[UPDATE] permission on the specified organization.
   * Update the security domain
   */
  async updateDomain(requestParameters: UpdateDomainRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Domain> {
    const response = await this.updateDomainRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_EMAIL_TEMPLATE[UPDATE] permission on the specified domain or DOMAIN_EMAIL_TEMPLATE[UPDATE] permission on the specified environment or DOMAIN_EMAIL_TEMPLATE[UPDATE] permission on the specified organization
   * Update an email
   */
  async updateDomainEmailRaw(
    requestParameters: UpdateDomainEmailRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Email>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateDomainEmail.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateDomainEmail.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateDomainEmail.',
      );
    }

    if (requestParameters.email === null || requestParameters.email === undefined) {
      throw new runtime.RequiredError(
        'email',
        'Required parameter requestParameters.email was null or undefined when calling updateDomainEmail.',
      );
    }

    if (requestParameters.updateEmail === null || requestParameters.updateEmail === undefined) {
      throw new runtime.RequiredError(
        'updateEmail',
        'Required parameter requestParameters.updateEmail was null or undefined when calling updateDomainEmail.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/emails/{email}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'email'}}`, encodeURIComponent(String(requestParameters.email))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: UpdateEmailToJSON(requestParameters.updateEmail),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => EmailFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_EMAIL_TEMPLATE[UPDATE] permission on the specified domain or DOMAIN_EMAIL_TEMPLATE[UPDATE] permission on the specified environment or DOMAIN_EMAIL_TEMPLATE[UPDATE] permission on the specified organization
   * Update an email
   */
  async updateDomainEmail(
    requestParameters: UpdateDomainEmailRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Email> {
    const response = await this.updateDomainEmailRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_FLOW[UPDATE] permission on the specified domain or DOMAIN_FLOW[UPDATE] permission on the specified environment or DOMAIN_FLOW[UPDATE] permission on the specified organization
   * Update a flow
   */
  async updateDomainFlowRaw(
    requestParameters: UpdateDomainFlowRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<FlowEntity>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateDomainFlow.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateDomainFlow.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateDomainFlow.',
      );
    }

    if (requestParameters.flow === null || requestParameters.flow === undefined) {
      throw new runtime.RequiredError(
        'flow',
        'Required parameter requestParameters.flow was null or undefined when calling updateDomainFlow.',
      );
    }

    if (requestParameters.flow2 === null || requestParameters.flow2 === undefined) {
      throw new runtime.RequiredError(
        'flow2',
        'Required parameter requestParameters.flow2 was null or undefined when calling updateDomainFlow.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/flows/{flow}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'flow'}}`, encodeURIComponent(String(requestParameters.flow))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: FlowToJSON(requestParameters.flow2),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => FlowEntityFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_FLOW[UPDATE] permission on the specified domain or DOMAIN_FLOW[UPDATE] permission on the specified environment or DOMAIN_FLOW[UPDATE] permission on the specified organization
   * Update a flow
   */
  async updateDomainFlow(
    requestParameters: UpdateDomainFlowRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<FlowEntity> {
    const response = await this.updateDomainFlowRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_FORM[UPDATE] permission on the specified domain or DOMAIN_FORM[UPDATE] permission on the specified environment or DOMAIN_FORM[UPDATE] permission on the specified organization
   * Update a form
   */
  async updateDomainFormRaw(
    requestParameters: UpdateDomainFormRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Form>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateDomainForm.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateDomainForm.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateDomainForm.',
      );
    }

    if (requestParameters.form === null || requestParameters.form === undefined) {
      throw new runtime.RequiredError(
        'form',
        'Required parameter requestParameters.form was null or undefined when calling updateDomainForm.',
      );
    }

    if (requestParameters.updateForm === null || requestParameters.updateForm === undefined) {
      throw new runtime.RequiredError(
        'updateForm',
        'Required parameter requestParameters.updateForm was null or undefined when calling updateDomainForm.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/forms/{form}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'form'}}`, encodeURIComponent(String(requestParameters.form))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: UpdateFormToJSON(requestParameters.updateForm),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => FormFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_FORM[UPDATE] permission on the specified domain or DOMAIN_FORM[UPDATE] permission on the specified environment or DOMAIN_FORM[UPDATE] permission on the specified organization
   * Update a form
   */
  async updateDomainForm(
    requestParameters: UpdateDomainFormRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Form> {
    const response = await this.updateDomainFormRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_REPORTER[UPDATE] permission on the specified domain or DOMAIN_REPORTER[UPDATE] permission on the specified environment or DOMAIN_REPORTER[UPDATE] permission on the specified organization
   * Update a reporter
   */
  async updateDomainReporterRaw(
    requestParameters: UpdateDomainReporterRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Reporter>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateDomainReporter.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateDomainReporter.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateDomainReporter.',
      );
    }

    if (requestParameters.reporter === null || requestParameters.reporter === undefined) {
      throw new runtime.RequiredError(
        'reporter',
        'Required parameter requestParameters.reporter was null or undefined when calling updateDomainReporter.',
      );
    }

    if (requestParameters.updateReporter === null || requestParameters.updateReporter === undefined) {
      throw new runtime.RequiredError(
        'updateReporter',
        'Required parameter requestParameters.updateReporter was null or undefined when calling updateDomainReporter.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/reporters/{reporter}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'reporter'}}`, encodeURIComponent(String(requestParameters.reporter))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: UpdateReporterToJSON(requestParameters.updateReporter),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ReporterFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_REPORTER[UPDATE] permission on the specified domain or DOMAIN_REPORTER[UPDATE] permission on the specified environment or DOMAIN_REPORTER[UPDATE] permission on the specified organization
   * Update a reporter
   */
  async updateDomainReporter(
    requestParameters: UpdateDomainReporterRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Reporter> {
    const response = await this.updateDomainReporterRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_EXTENSION_GRANT[UPDATE] permission on the specified domain or DOMAIN_EXTENSION_GRANT[UPDATE] permission on the specified environment or DOMAIN_EXTENSION_GRANT[UPDATE] permission on the specified organization
   * Update an extension grant
   */
  async updateExtensionGrantRaw(
    requestParameters: UpdateExtensionGrantRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ExtensionGrant>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateExtensionGrant.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateExtensionGrant.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateExtensionGrant.',
      );
    }

    if (requestParameters.extensionGrant === null || requestParameters.extensionGrant === undefined) {
      throw new runtime.RequiredError(
        'extensionGrant',
        'Required parameter requestParameters.extensionGrant was null or undefined when calling updateExtensionGrant.',
      );
    }

    if (requestParameters.updateExtensionGrant === null || requestParameters.updateExtensionGrant === undefined) {
      throw new runtime.RequiredError(
        'updateExtensionGrant',
        'Required parameter requestParameters.updateExtensionGrant was null or undefined when calling updateExtensionGrant.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/extensionGrants/{extensionGrant}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'extensionGrant'}}`, encodeURIComponent(String(requestParameters.extensionGrant))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: UpdateExtensionGrantToJSON(requestParameters.updateExtensionGrant),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ExtensionGrantFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_EXTENSION_GRANT[UPDATE] permission on the specified domain or DOMAIN_EXTENSION_GRANT[UPDATE] permission on the specified environment or DOMAIN_EXTENSION_GRANT[UPDATE] permission on the specified organization
   * Update an extension grant
   */
  async updateExtensionGrant(
    requestParameters: UpdateExtensionGrantRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<ExtensionGrant> {
    const response = await this.updateExtensionGrantRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_FACTOR[UPDATE] permission on the specified domain or DOMAIN_FACTOR[UPDATE] permission on the specified environment or DOMAIN_FACTOR[UPDATE] permission on the specified organization
   * Update a factor
   */
  async updateFactorRaw(
    requestParameters: UpdateFactorRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Factor>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateFactor.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateFactor.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateFactor.',
      );
    }

    if (requestParameters.factor === null || requestParameters.factor === undefined) {
      throw new runtime.RequiredError(
        'factor',
        'Required parameter requestParameters.factor was null or undefined when calling updateFactor.',
      );
    }

    if (requestParameters.updateFactor === null || requestParameters.updateFactor === undefined) {
      throw new runtime.RequiredError(
        'updateFactor',
        'Required parameter requestParameters.updateFactor was null or undefined when calling updateFactor.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/factors/{factor}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'factor'}}`, encodeURIComponent(String(requestParameters.factor))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: UpdateFactorToJSON(requestParameters.updateFactor),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => FactorFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_FACTOR[UPDATE] permission on the specified domain or DOMAIN_FACTOR[UPDATE] permission on the specified environment or DOMAIN_FACTOR[UPDATE] permission on the specified organization
   * Update a factor
   */
  async updateFactor(requestParameters: UpdateFactorRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Factor> {
    const response = await this.updateFactorRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_GROUP[UPDATE] permission on the specified domain or DOMAIN_GROUP[UPDATE] permission on the specified environment or DOMAIN_GROUP[UPDATE] permission on the specified organization
   * Update a group
   */
  async updateGroupRaw(
    requestParameters: UpdateGroupRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Group>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateGroup.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateGroup.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateGroup.',
      );
    }

    if (requestParameters.group === null || requestParameters.group === undefined) {
      throw new runtime.RequiredError(
        'group',
        'Required parameter requestParameters.group was null or undefined when calling updateGroup.',
      );
    }

    if (requestParameters.updateGroup === null || requestParameters.updateGroup === undefined) {
      throw new runtime.RequiredError(
        'updateGroup',
        'Required parameter requestParameters.updateGroup was null or undefined when calling updateGroup.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/groups/{group}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'group'}}`, encodeURIComponent(String(requestParameters.group))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: UpdateGroupToJSON(requestParameters.updateGroup),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => GroupFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_GROUP[UPDATE] permission on the specified domain or DOMAIN_GROUP[UPDATE] permission on the specified environment or DOMAIN_GROUP[UPDATE] permission on the specified organization
   * Update a group
   */
  async updateGroup(requestParameters: UpdateGroupRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Group> {
    const response = await this.updateGroupRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_IDENTITY_PROVIDER[UPDATE] permission on the specified domain or DOMAIN_IDENTITY_PROVIDER[UPDATE] permission on the specified environment or DOMAIN_IDENTITY_PROVIDER[UPDATE] permission on the specified organization
   * Update an identity provider
   */
  async updateIdentityProviderRaw(
    requestParameters: UpdateIdentityProviderRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<IdentityProvider>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateIdentityProvider.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateIdentityProvider.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateIdentityProvider.',
      );
    }

    if (requestParameters.identity === null || requestParameters.identity === undefined) {
      throw new runtime.RequiredError(
        'identity',
        'Required parameter requestParameters.identity was null or undefined when calling updateIdentityProvider.',
      );
    }

    if (requestParameters.updateIdentityProvider === null || requestParameters.updateIdentityProvider === undefined) {
      throw new runtime.RequiredError(
        'updateIdentityProvider',
        'Required parameter requestParameters.updateIdentityProvider was null or undefined when calling updateIdentityProvider.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/identities/{identity}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'identity'}}`, encodeURIComponent(String(requestParameters.identity))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: UpdateIdentityProviderToJSON(requestParameters.updateIdentityProvider),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => IdentityProviderFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_IDENTITY_PROVIDER[UPDATE] permission on the specified domain or DOMAIN_IDENTITY_PROVIDER[UPDATE] permission on the specified environment or DOMAIN_IDENTITY_PROVIDER[UPDATE] permission on the specified organization
   * Update an identity provider
   */
  async updateIdentityProvider(
    requestParameters: UpdateIdentityProviderRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<IdentityProvider> {
    const response = await this.updateIdentityProviderRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_SETTINGS[UPDATE] permission on the specified domain or DOMAIN_SETTINGS[UPDATE] permission on the specified environment or DOMAIN_SETTINGS[UPDATE] permission on the specified organization
   * Update a password policy
   */
  async updatePasswordPolicyRaw(
    requestParameters: UpdatePasswordPolicyRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<PasswordPolicy>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updatePasswordPolicy.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updatePasswordPolicy.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updatePasswordPolicy.',
      );
    }

    if (requestParameters.policy === null || requestParameters.policy === undefined) {
      throw new runtime.RequiredError(
        'policy',
        'Required parameter requestParameters.policy was null or undefined when calling updatePasswordPolicy.',
      );
    }

    if (requestParameters.updatePasswordPolicy === null || requestParameters.updatePasswordPolicy === undefined) {
      throw new runtime.RequiredError(
        'updatePasswordPolicy',
        'Required parameter requestParameters.updatePasswordPolicy was null or undefined when calling updatePasswordPolicy.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/password-policies/{policy}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'policy'}}`, encodeURIComponent(String(requestParameters.policy))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: UpdatePasswordPolicyToJSON(requestParameters.updatePasswordPolicy),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => PasswordPolicyFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_SETTINGS[UPDATE] permission on the specified domain or DOMAIN_SETTINGS[UPDATE] permission on the specified environment or DOMAIN_SETTINGS[UPDATE] permission on the specified organization
   * Update a password policy
   */
  async updatePasswordPolicy(
    requestParameters: UpdatePasswordPolicyRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<PasswordPolicy> {
    const response = await this.updatePasswordPolicyRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the PROTECTED_RESOURCE[UPDATE] permission on the specified resource or PROTECTED_RESOURCE[UPDATE] permission on the specified domain or PROTECTED_RESOURCE[UPDATE] permission on the specified environment or PROTECTED_RESOURCE[UPDATE] permission on the specified organization.
   * Update a Protected Resource
   */
  async updateProtectedResourceRaw(
    requestParameters: UpdateProtectedResourceRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ProtectedResource>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateProtectedResource.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateProtectedResource.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateProtectedResource.',
      );
    }

    if (requestParameters.protectedResource === null || requestParameters.protectedResource === undefined) {
      throw new runtime.RequiredError(
        'protectedResource',
        'Required parameter requestParameters.protectedResource was null or undefined when calling updateProtectedResource.',
      );
    }

    if (requestParameters.updateProtectedResource === null || requestParameters.updateProtectedResource === undefined) {
      throw new runtime.RequiredError(
        'updateProtectedResource',
        'Required parameter requestParameters.updateProtectedResource was null or undefined when calling updateProtectedResource.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/protected-resources/{protected-resource}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'protected-resource'}}`, encodeURIComponent(String(requestParameters.protectedResource))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: UpdateProtectedResourceToJSON(requestParameters.updateProtectedResource),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ProtectedResourceFromJSON(jsonValue));
  }

  /**
   * User must have the PROTECTED_RESOURCE[UPDATE] permission on the specified resource or PROTECTED_RESOURCE[UPDATE] permission on the specified domain or PROTECTED_RESOURCE[UPDATE] permission on the specified environment or PROTECTED_RESOURCE[UPDATE] permission on the specified organization.
   * Update a Protected Resource
   */
  async updateProtectedResource(
    requestParameters: UpdateProtectedResourceRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<ProtectedResource> {
    const response = await this.updateProtectedResourceRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_RESOURCE[UPDATE] permission on the specified domain or DOMAIN_RESOURCE[UPDATE] permission on the specified environment or DOMAIN_RESOURCE[UPDATE] permission on the specified organization
   * Update a resource
   */
  async updateResourceRaw(
    requestParameters: UpdateResourceRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ServiceResource>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateResource.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateResource.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateResource.',
      );
    }

    if (requestParameters.resource === null || requestParameters.resource === undefined) {
      throw new runtime.RequiredError(
        'resource',
        'Required parameter requestParameters.resource was null or undefined when calling updateResource.',
      );
    }

    if (requestParameters.updateServiceResource === null || requestParameters.updateServiceResource === undefined) {
      throw new runtime.RequiredError(
        'updateServiceResource',
        'Required parameter requestParameters.updateServiceResource was null or undefined when calling updateResource.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/resources/{resource}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'resource'}}`, encodeURIComponent(String(requestParameters.resource))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: UpdateServiceResourceToJSON(requestParameters.updateServiceResource),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ServiceResourceFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_RESOURCE[UPDATE] permission on the specified domain or DOMAIN_RESOURCE[UPDATE] permission on the specified environment or DOMAIN_RESOURCE[UPDATE] permission on the specified organization
   * Update a resource
   */
  async updateResource(
    requestParameters: UpdateResourceRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<ServiceResource> {
    const response = await this.updateResourceRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_ROLE[UPDATE] permission on the specified domain or DOMAIN_ROLE[UPDATE] permission on the specified environment or DOMAIN_ROLE[UPDATE] permission on the specified organization
   * Update a role
   */
  async updateRoleRaw(
    requestParameters: UpdateRoleRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<RoleEntity>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateRole.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateRole.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateRole.',
      );
    }

    if (requestParameters.role === null || requestParameters.role === undefined) {
      throw new runtime.RequiredError('role', 'Required parameter requestParameters.role was null or undefined when calling updateRole.');
    }

    if (requestParameters.updateRole === null || requestParameters.updateRole === undefined) {
      throw new runtime.RequiredError(
        'updateRole',
        'Required parameter requestParameters.updateRole was null or undefined when calling updateRole.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/roles/{role}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'role'}}`, encodeURIComponent(String(requestParameters.role))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: UpdateRoleToJSON(requestParameters.updateRole),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => RoleEntityFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_ROLE[UPDATE] permission on the specified domain or DOMAIN_ROLE[UPDATE] permission on the specified environment or DOMAIN_ROLE[UPDATE] permission on the specified organization
   * Update a role
   */
  async updateRole(requestParameters: UpdateRoleRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<RoleEntity> {
    const response = await this.updateRoleRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_SCOPE[UPDATE] permission on the specified domain or DOMAIN_SCOPE[UPDATE] permission on the specified environment or DOMAIN_SCOPE[UPDATE] permission on the specified organization
   * Update a scope
   */
  async updateScopeRaw(
    requestParameters: UpdateScopeRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Scope>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateScope.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateScope.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateScope.',
      );
    }

    if (requestParameters.scope === null || requestParameters.scope === undefined) {
      throw new runtime.RequiredError(
        'scope',
        'Required parameter requestParameters.scope was null or undefined when calling updateScope.',
      );
    }

    if (requestParameters.updateScope === null || requestParameters.updateScope === undefined) {
      throw new runtime.RequiredError(
        'updateScope',
        'Required parameter requestParameters.updateScope was null or undefined when calling updateScope.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/scopes/{scope}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'scope'}}`, encodeURIComponent(String(requestParameters.scope))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: UpdateScopeToJSON(requestParameters.updateScope),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ScopeFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_SCOPE[UPDATE] permission on the specified domain or DOMAIN_SCOPE[UPDATE] permission on the specified environment or DOMAIN_SCOPE[UPDATE] permission on the specified organization
   * Update a scope
   */
  async updateScope(requestParameters: UpdateScopeRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Scope> {
    const response = await this.updateScopeRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_THEME[UPDATE] permission on the specified domain or DOMAIN_THEME[UPDATE] permission on the specified environment or DOMAIN_THEME[UPDATE] permission on the specified organization
   * Update a theme on the specified security domain
   */
  async updateThemeRaw(
    requestParameters: UpdateThemeRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ThemeEntity>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateTheme.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateTheme.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateTheme.',
      );
    }

    if (requestParameters.themeId === null || requestParameters.themeId === undefined) {
      throw new runtime.RequiredError(
        'themeId',
        'Required parameter requestParameters.themeId was null or undefined when calling updateTheme.',
      );
    }

    if (requestParameters.themeEntity === null || requestParameters.themeEntity === undefined) {
      throw new runtime.RequiredError(
        'themeEntity',
        'Required parameter requestParameters.themeEntity was null or undefined when calling updateTheme.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/themes/{themeId}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'themeId'}}`, encodeURIComponent(String(requestParameters.themeId))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: ThemeEntityToJSON(requestParameters.themeEntity),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ThemeEntityFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_THEME[UPDATE] permission on the specified domain or DOMAIN_THEME[UPDATE] permission on the specified environment or DOMAIN_THEME[UPDATE] permission on the specified organization
   * Update a theme on the specified security domain
   */
  async updateTheme(
    requestParameters: UpdateThemeRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<ThemeEntity> {
    const response = await this.updateThemeRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Update a user
   */
  async updateUserRaw(
    requestParameters: UpdateUserRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<User>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateUser.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateUser.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateUser.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError('user', 'Required parameter requestParameters.user was null or undefined when calling updateUser.');
    }

    if (requestParameters.updateUser === null || requestParameters.updateUser === undefined) {
      throw new runtime.RequiredError(
        'updateUser',
        'Required parameter requestParameters.updateUser was null or undefined when calling updateUser.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: UpdateUserToJSON(requestParameters.updateUser),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Update a user
   */
  async updateUser(requestParameters: UpdateUserRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<User> {
    const response = await this.updateUserRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Update a user status
   */
  async updateUserStatusRaw(
    requestParameters: UpdateUserStatusRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<User>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateUserStatus.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateUserStatus.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateUserStatus.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling updateUserStatus.',
      );
    }

    if (requestParameters.statusEntity === null || requestParameters.statusEntity === undefined) {
      throw new runtime.RequiredError(
        'statusEntity',
        'Required parameter requestParameters.statusEntity was null or undefined when calling updateUserStatus.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/status`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: StatusEntityToJSON(requestParameters.statusEntity),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Update a user status
   */
  async updateUserStatus(
    requestParameters: UpdateUserStatusRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<User> {
    const response = await this.updateUserStatusRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Update a user username
   */
  async updateUsernameRaw(
    requestParameters: UpdateUsernameRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<User>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateUsername.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateUsername.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateUsername.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling updateUsername.',
      );
    }

    if (requestParameters.usernameEntity === null || requestParameters.usernameEntity === undefined) {
      throw new runtime.RequiredError(
        'usernameEntity',
        'Required parameter requestParameters.usernameEntity was null or undefined when calling updateUsername.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/username`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'PATCH',
        headers: headerParameters,
        query: queryParameters,
        body: UsernameEntityToJSON(requestParameters.usernameEntity),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Update a user username
   */
  async updateUsername(requestParameters: UpdateUsernameRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<User> {
    const response = await this.updateUsernameRaw(requestParameters, initOverrides);
    return await response.value();
  }
}

/**
 * @export
 */
export const FindApplicationEmailTemplateEnum = {
  Login: 'LOGIN',
  Registration: 'REGISTRATION',
  RegistrationConfirmation: 'REGISTRATION_CONFIRMATION',
  RegistrationVerify: 'REGISTRATION_VERIFY',
  ForgotPassword: 'FORGOT_PASSWORD',
  ResetPassword: 'RESET_PASSWORD',
  Oauth2UserConsent: 'OAUTH2_USER_CONSENT',
  MfaEnroll: 'MFA_ENROLL',
  MfaChallenge: 'MFA_CHALLENGE',
  MfaChallengeAlternatives: 'MFA_CHALLENGE_ALTERNATIVES',
  MfaRecoveryCode: 'MFA_RECOVERY_CODE',
  BlockedAccount: 'BLOCKED_ACCOUNT',
  CompleteProfile: 'COMPLETE_PROFILE',
  WebauthnRegister: 'WEBAUTHN_REGISTER',
  WebauthnRegisterSuccess: 'WEBAUTHN_REGISTER_SUCCESS',
  WebauthnLogin: 'WEBAUTHN_LOGIN',
  IdentifierFirstLogin: 'IDENTIFIER_FIRST_LOGIN',
  Error: 'ERROR',
  CertificateExpiration: 'CERTIFICATE_EXPIRATION',
  ClientSecretExpiration: 'CLIENT_SECRET_EXPIRATION',
  VerifyAttempt: 'VERIFY_ATTEMPT',
} as const;
export type FindApplicationEmailTemplateEnum = typeof FindApplicationEmailTemplateEnum[keyof typeof FindApplicationEmailTemplateEnum];
/**
 * @export
 */
export const FindApplicationFormTemplateEnum = {
  Login: 'LOGIN',
  Registration: 'REGISTRATION',
  RegistrationConfirmation: 'REGISTRATION_CONFIRMATION',
  RegistrationVerify: 'REGISTRATION_VERIFY',
  ForgotPassword: 'FORGOT_PASSWORD',
  ResetPassword: 'RESET_PASSWORD',
  Oauth2UserConsent: 'OAUTH2_USER_CONSENT',
  MfaEnroll: 'MFA_ENROLL',
  MfaChallenge: 'MFA_CHALLENGE',
  MfaChallengeAlternatives: 'MFA_CHALLENGE_ALTERNATIVES',
  MfaRecoveryCode: 'MFA_RECOVERY_CODE',
  BlockedAccount: 'BLOCKED_ACCOUNT',
  CompleteProfile: 'COMPLETE_PROFILE',
  WebauthnRegister: 'WEBAUTHN_REGISTER',
  WebauthnRegisterSuccess: 'WEBAUTHN_REGISTER_SUCCESS',
  WebauthnLogin: 'WEBAUTHN_LOGIN',
  IdentifierFirstLogin: 'IDENTIFIER_FIRST_LOGIN',
  Error: 'ERROR',
  CertificateExpiration: 'CERTIFICATE_EXPIRATION',
  ClientSecretExpiration: 'CLIENT_SECRET_EXPIRATION',
  VerifyAttempt: 'VERIFY_ATTEMPT',
} as const;
export type FindApplicationFormTemplateEnum = typeof FindApplicationFormTemplateEnum[keyof typeof FindApplicationFormTemplateEnum];
/**
 * @export
 */
export const FindEmailTemplateEnum = {
  Login: 'LOGIN',
  Registration: 'REGISTRATION',
  RegistrationConfirmation: 'REGISTRATION_CONFIRMATION',
  RegistrationVerify: 'REGISTRATION_VERIFY',
  ForgotPassword: 'FORGOT_PASSWORD',
  ResetPassword: 'RESET_PASSWORD',
  Oauth2UserConsent: 'OAUTH2_USER_CONSENT',
  MfaEnroll: 'MFA_ENROLL',
  MfaChallenge: 'MFA_CHALLENGE',
  MfaChallengeAlternatives: 'MFA_CHALLENGE_ALTERNATIVES',
  MfaRecoveryCode: 'MFA_RECOVERY_CODE',
  BlockedAccount: 'BLOCKED_ACCOUNT',
  CompleteProfile: 'COMPLETE_PROFILE',
  WebauthnRegister: 'WEBAUTHN_REGISTER',
  WebauthnRegisterSuccess: 'WEBAUTHN_REGISTER_SUCCESS',
  WebauthnLogin: 'WEBAUTHN_LOGIN',
  IdentifierFirstLogin: 'IDENTIFIER_FIRST_LOGIN',
  Error: 'ERROR',
  CertificateExpiration: 'CERTIFICATE_EXPIRATION',
  ClientSecretExpiration: 'CLIENT_SECRET_EXPIRATION',
  VerifyAttempt: 'VERIFY_ATTEMPT',
} as const;
export type FindEmailTemplateEnum = typeof FindEmailTemplateEnum[keyof typeof FindEmailTemplateEnum];
/**
 * @export
 */
export const FindFormTemplateEnum = {
  Login: 'LOGIN',
  Registration: 'REGISTRATION',
  RegistrationConfirmation: 'REGISTRATION_CONFIRMATION',
  RegistrationVerify: 'REGISTRATION_VERIFY',
  ForgotPassword: 'FORGOT_PASSWORD',
  ResetPassword: 'RESET_PASSWORD',
  Oauth2UserConsent: 'OAUTH2_USER_CONSENT',
  MfaEnroll: 'MFA_ENROLL',
  MfaChallenge: 'MFA_CHALLENGE',
  MfaChallengeAlternatives: 'MFA_CHALLENGE_ALTERNATIVES',
  MfaRecoveryCode: 'MFA_RECOVERY_CODE',
  BlockedAccount: 'BLOCKED_ACCOUNT',
  CompleteProfile: 'COMPLETE_PROFILE',
  WebauthnRegister: 'WEBAUTHN_REGISTER',
  WebauthnRegisterSuccess: 'WEBAUTHN_REGISTER_SUCCESS',
  WebauthnLogin: 'WEBAUTHN_LOGIN',
  IdentifierFirstLogin: 'IDENTIFIER_FIRST_LOGIN',
  Error: 'ERROR',
  CertificateExpiration: 'CERTIFICATE_EXPIRATION',
  ClientSecretExpiration: 'CLIENT_SECRET_EXPIRATION',
  VerifyAttempt: 'VERIFY_ATTEMPT',
} as const;
export type FindFormTemplateEnum = typeof FindFormTemplateEnum[keyof typeof FindFormTemplateEnum];
