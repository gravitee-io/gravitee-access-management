/*
 * Copyright (C) 2015 The Gravitee team (http://gravitee.io)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* Gravitee.io - Access Management API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/* tslint:disable */
/* eslint-disable */

import * as runtime from '../runtime';
import {
  AccessPolicy,
  AccessPolicyFromJSON,
  AccessPolicyToJSON,
  AccessPolicyListItem,
  AccessPolicyListItemFromJSON,
  AccessPolicyListItemToJSON,
  AlertNotifier,
  AlertNotifierFromJSON,
  AlertNotifierToJSON,
  AlertTrigger,
  AlertTriggerFromJSON,
  AlertTriggerToJSON,
  AnalyticsTypeParam,
  AnalyticsTypeParamFromJSON,
  AnalyticsTypeParamToJSON,
  Application,
  ApplicationFromJSON,
  ApplicationToJSON,
  ApplicationPage,
  ApplicationPageFromJSON,
  ApplicationPageToJSON,
  AssignPasswordPolicy,
  AssignPasswordPolicyFromJSON,
  AssignPasswordPolicyToJSON,
  Audit,
  AuditFromJSON,
  AuditToJSON,
  AuthenticationDeviceNotifier,
  AuthenticationDeviceNotifierFromJSON,
  AuthenticationDeviceNotifierToJSON,
  AuthorizationEngine,
  AuthorizationEngineFromJSON,
  AuthorizationEngineToJSON,
  BotDetection,
  BotDetectionFromJSON,
  BotDetectionToJSON,
  BulkResponse,
  BulkResponseFromJSON,
  BulkResponseToJSON,
  CertificateEntity,
  CertificateEntityFromJSON,
  CertificateEntityToJSON,
  CertificateKey,
  CertificateKeyFromJSON,
  CertificateKeyToJSON,
  ClientSecret,
  ClientSecretFromJSON,
  ClientSecretToJSON,
  Credential,
  CredentialFromJSON,
  CredentialToJSON,
  DeviceIdentifier,
  DeviceIdentifierFromJSON,
  DeviceIdentifierToJSON,
  Domain,
  DomainFromJSON,
  DomainToJSON,
  DomainPage,
  DomainPageFromJSON,
  DomainPageToJSON,
  DomainUserBulkRequest,
  DomainUserBulkRequestFromJSON,
  DomainUserBulkRequestToJSON,
  Email,
  EmailFromJSON,
  EmailToJSON,
  EnrolledFactorEntity,
  EnrolledFactorEntityFromJSON,
  EnrolledFactorEntityToJSON,
  Entrypoint,
  EntrypointFromJSON,
  EntrypointToJSON,
  ExtensionGrant,
  ExtensionGrantFromJSON,
  ExtensionGrantToJSON,
  Factor,
  FactorFromJSON,
  FactorToJSON,
  FilteredIdentityProviderInfo,
  FilteredIdentityProviderInfoFromJSON,
  FilteredIdentityProviderInfoToJSON,
  Flow,
  FlowFromJSON,
  FlowToJSON,
  FlowEntity,
  FlowEntityFromJSON,
  FlowEntityToJSON,
  Form,
  FormFromJSON,
  FormToJSON,
  Group,
  GroupFromJSON,
  GroupToJSON,
  GroupPage,
  GroupPageFromJSON,
  GroupPageToJSON,
  I18nDictionary,
  I18nDictionaryFromJSON,
  I18nDictionaryToJSON,
  IdentityProvider,
  IdentityProviderFromJSON,
  IdentityProviderToJSON,
  MembershipListItem,
  MembershipListItemFromJSON,
  MembershipListItemToJSON,
  ModifiedCertificateEntity,
  ModifiedCertificateEntityFromJSON,
  ModifiedCertificateEntityToJSON,
  NewAlertNotifier,
  NewAlertNotifierFromJSON,
  NewAlertNotifierToJSON,
  NewApplication,
  NewApplicationFromJSON,
  NewApplicationToJSON,
  NewAuthenticationDeviceNotifier,
  NewAuthenticationDeviceNotifierFromJSON,
  NewAuthenticationDeviceNotifierToJSON,
  NewAuthorizationEngine,
  NewAuthorizationEngineFromJSON,
  NewAuthorizationEngineToJSON,
  NewBotDetection,
  NewBotDetectionFromJSON,
  NewBotDetectionToJSON,
  NewCertificate,
  NewCertificateFromJSON,
  NewCertificateToJSON,
  NewClientSecret,
  NewClientSecretFromJSON,
  NewClientSecretToJSON,
  NewDeviceIdentifier,
  NewDeviceIdentifierFromJSON,
  NewDeviceIdentifierToJSON,
  NewDictionary,
  NewDictionaryFromJSON,
  NewDictionaryToJSON,
  NewDomain,
  NewDomainFromJSON,
  NewDomainToJSON,
  NewEmail,
  NewEmailFromJSON,
  NewEmailToJSON,
  NewExtensionGrant,
  NewExtensionGrantFromJSON,
  NewExtensionGrantToJSON,
  NewFactor,
  NewFactorFromJSON,
  NewFactorToJSON,
  NewForm,
  NewFormFromJSON,
  NewFormToJSON,
  NewGroup,
  NewGroupFromJSON,
  NewGroupToJSON,
  NewIdentityProvider,
  NewIdentityProviderFromJSON,
  NewIdentityProviderToJSON,
  NewMembership,
  NewMembershipFromJSON,
  NewMembershipToJSON,
  NewPasswordPolicy,
  NewPasswordPolicyFromJSON,
  NewPasswordPolicyToJSON,
  NewProtectedResource,
  NewProtectedResourceFromJSON,
  NewProtectedResourceToJSON,
  NewReporter,
  NewReporterFromJSON,
  NewReporterToJSON,
  NewRole,
  NewRoleFromJSON,
  NewRoleToJSON,
  NewScope,
  NewScopeFromJSON,
  NewScopeToJSON,
  NewServiceResource,
  NewServiceResourceFromJSON,
  NewServiceResourceToJSON,
  NewTheme,
  NewThemeFromJSON,
  NewThemeToJSON,
  NewUser,
  NewUserFromJSON,
  NewUserToJSON,
  PasswordPolicy,
  PasswordPolicyFromJSON,
  PasswordPolicyToJSON,
  PasswordPolicyEntity,
  PasswordPolicyEntityFromJSON,
  PasswordPolicyEntityToJSON,
  PasswordValue,
  PasswordValueFromJSON,
  PasswordValueToJSON,
  PatchAlertNotifier,
  PatchAlertNotifierFromJSON,
  PatchAlertNotifierToJSON,
  PatchAlertTrigger,
  PatchAlertTriggerFromJSON,
  PatchAlertTriggerToJSON,
  PatchApplication,
  PatchApplicationFromJSON,
  PatchApplicationToJSON,
  PatchApplicationType,
  PatchApplicationTypeFromJSON,
  PatchApplicationTypeToJSON,
  PatchDomain,
  PatchDomainFromJSON,
  PatchDomainToJSON,
  PatchScope,
  PatchScopeFromJSON,
  PatchScopeToJSON,
  PreviewRequest,
  PreviewRequestFromJSON,
  PreviewRequestToJSON,
  PreviewResponse,
  PreviewResponseFromJSON,
  PreviewResponseToJSON,
  ProtectedResource,
  ProtectedResourceFromJSON,
  ProtectedResourceToJSON,
  ProtectedResourcePage,
  ProtectedResourcePageFromJSON,
  ProtectedResourcePageToJSON,
  ProtectedResourcePrimaryData,
  ProtectedResourcePrimaryDataFromJSON,
  ProtectedResourcePrimaryDataToJSON,
  ProtectedResourceSecret,
  ProtectedResourceSecretFromJSON,
  ProtectedResourceSecretToJSON,
  Reporter,
  ReporterFromJSON,
  ReporterToJSON,
  Resource,
  ResourceFromJSON,
  ResourceToJSON,
  ResourceListItem,
  ResourceListItemFromJSON,
  ResourceListItemToJSON,
  Role,
  RoleFromJSON,
  RoleToJSON,
  RoleEntity,
  RoleEntityFromJSON,
  RoleEntityToJSON,
  RolePage,
  RolePageFromJSON,
  RolePageToJSON,
  Scope,
  ScopeFromJSON,
  ScopeToJSON,
  ScopeApprovalEntity,
  ScopeApprovalEntityFromJSON,
  ScopeApprovalEntityToJSON,
  ScopePage,
  ScopePageFromJSON,
  ScopePageToJSON,
  ServiceResource,
  ServiceResourceFromJSON,
  ServiceResourceToJSON,
  StatusEntity,
  StatusEntityFromJSON,
  StatusEntityToJSON,
  ThemeEntity,
  ThemeEntityFromJSON,
  ThemeEntityToJSON,
  UpdateAuthenticationDeviceNotifier,
  UpdateAuthenticationDeviceNotifierFromJSON,
  UpdateAuthenticationDeviceNotifierToJSON,
  UpdateAuthorizationEngine,
  UpdateAuthorizationEngineFromJSON,
  UpdateAuthorizationEngineToJSON,
  UpdateBotDetection,
  UpdateBotDetectionFromJSON,
  UpdateBotDetectionToJSON,
  UpdateCertificate,
  UpdateCertificateFromJSON,
  UpdateCertificateToJSON,
  UpdateDeviceIdentifier,
  UpdateDeviceIdentifierFromJSON,
  UpdateDeviceIdentifierToJSON,
  UpdateEmail,
  UpdateEmailFromJSON,
  UpdateEmailToJSON,
  UpdateExtensionGrant,
  UpdateExtensionGrantFromJSON,
  UpdateExtensionGrantToJSON,
  UpdateFactor,
  UpdateFactorFromJSON,
  UpdateFactorToJSON,
  UpdateForm,
  UpdateFormFromJSON,
  UpdateFormToJSON,
  UpdateGroup,
  UpdateGroupFromJSON,
  UpdateGroupToJSON,
  UpdateI18nDictionary,
  UpdateI18nDictionaryFromJSON,
  UpdateI18nDictionaryToJSON,
  UpdateIdentityProvider,
  UpdateIdentityProviderFromJSON,
  UpdateIdentityProviderToJSON,
  UpdatePasswordPolicy,
  UpdatePasswordPolicyFromJSON,
  UpdatePasswordPolicyToJSON,
  UpdateProtectedResource,
  UpdateProtectedResourceFromJSON,
  UpdateProtectedResourceToJSON,
  UpdateReporter,
  UpdateReporterFromJSON,
  UpdateReporterToJSON,
  UpdateRole,
  UpdateRoleFromJSON,
  UpdateRoleToJSON,
  UpdateScope,
  UpdateScopeFromJSON,
  UpdateScopeToJSON,
  UpdateServiceResource,
  UpdateServiceResourceFromJSON,
  UpdateServiceResourceToJSON,
  UpdateUser,
  UpdateUserFromJSON,
  UpdateUserToJSON,
  User,
  UserFromJSON,
  UserToJSON,
  UserEntity,
  UserEntityFromJSON,
  UserEntityToJSON,
  UserIdentityEntity,
  UserIdentityEntityFromJSON,
  UserIdentityEntityToJSON,
  UserPage,
  UserPageFromJSON,
  UserPageToJSON,
  UsernameEntity,
  UsernameEntityFromJSON,
  UsernameEntityToJSON,
} from '../models';

export interface AddGroupMemberRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  group: string;
  member: string;
}

export interface AddOrUpdateMemberRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  newMembership: NewMembership;
}

export interface AddOrUpdateMember1Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  newMembership: NewMembership;
}

export interface AssignRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  requestBody: Array<string>;
}

export interface AssignPasswordPolicyToIdpRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  identity: string;
  assignPasswordPolicy: AssignPasswordPolicy;
}

export interface AssignRolesRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  group: string;
  requestBody: Array<string>;
}

export interface BulkUserOperationRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  domainUserBulkRequest: DomainUserBulkRequest;
}

export interface Create1Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  newClientSecret: NewClientSecret;
}

export interface Create2Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  newEmail: NewEmail;
}

export interface Create3Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  newForm: NewForm;
}

export interface Create4Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  newAuthenticationDeviceNotifier: NewAuthenticationDeviceNotifier;
}

export interface Create5Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  newEmail: NewEmail;
}

export interface Create6Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  newForm: NewForm;
}

export interface Create7Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  newReporter?: NewReporter;
}

export interface CreateAlertNotifierRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  newAlertNotifier: NewAlertNotifier;
}

export interface CreateApplicationRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  newApplication: NewApplication;
}

export interface CreateAuthorizationEngineRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  newAuthorizationEngine: NewAuthorizationEngine;
}

export interface CreateBotDetectionRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  newBotDetection: NewBotDetection;
}

export interface CreateCertificateRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  newCertificate: NewCertificate;
}

export interface CreateDeviceIdentifierRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  newDeviceIdentifier: NewDeviceIdentifier;
}

export interface CreateDomainRequest {
  organizationId: string;
  environmentId: string;
  newDomain: NewDomain;
}

export interface CreateExtensionGrantRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  newExtensionGrant: NewExtensionGrant;
}

export interface CreateFactorRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  newFactor: NewFactor;
}

export interface CreateGroupRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  newGroup: NewGroup;
}

export interface CreateI18nDictionaryRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  newDictionary: NewDictionary;
}

export interface CreateIdentityProviderRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  newIdentityProvider: NewIdentityProvider;
}

export interface CreatePasswordPolicyRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  newPasswordPolicy: NewPasswordPolicy;
}

export interface CreateProtectedResourceRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  newProtectedResource: NewProtectedResource;
}

export interface CreateResourceRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  newServiceResource: NewServiceResource;
}

export interface CreateRoleRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  newRole: NewRole;
}

export interface CreateScopeRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  newScope: NewScope;
}

export interface CreateThemeRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  newTheme: NewTheme;
}

export interface CreateUserRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  newUser: NewUser;
}

export interface DefineAppFlowsRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  flow: Array<Flow>;
}

export interface DefineDomainFlowsRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  flow: Array<Flow>;
}

export interface Delete1Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  secret: string;
}

export interface Delete10Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  identity: string;
}

export interface Delete2Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  email: string;
}

export interface Delete3Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  form: string;
}

export interface Delete4Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  authDeviceNotifier: string;
}

export interface Delete5Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  email: string;
}

export interface Delete6Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  form: string;
}

export interface Delete7Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  reporter: string;
}

export interface Delete8Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  clientId?: string;
}

export interface Delete9Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  device: string;
}

export interface DeleteAlertNotifierRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  notifierId: string;
}

export interface DeleteApplicationRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
}

export interface DeleteAuthorizationEngineRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  engineId: string;
}

export interface DeleteBotDetectionRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  botDetection: string;
}

export interface DeleteCertificateRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  certificate: string;
}

export interface DeleteDeviceIdentifierRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  deviceIdentifier: string;
}

export interface DeleteDomainRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
}

export interface DeleteExtensionGrantRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  extensionGrant: string;
}

export interface DeleteFactorRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  factor: string;
}

export interface DeleteGroupRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  group: string;
}

export interface DeleteI18nDictionaryRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  dictionary: string;
}

export interface DeleteIdentityProviderRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  identity: string;
}

export interface DeletePasswordPolicyRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  policy: string;
}

export interface DeleteResourceRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  resource: string;
}

export interface DeleteRoleRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  role: string;
}

export interface DeleteScopeRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  scope: string;
}

export interface DeleteThemeRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  themeId: string;
}

export interface DeleteUserRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
}

export interface DeleteUserFactorRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  factor: string;
}

export interface EvaluatePolicyRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  policy: string;
}

export interface FindApplicationRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
}

export interface FindAuthorizationEngineRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  engineId: string;
}

export interface FindCertificateRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  certificate: string;
}

export interface FindDomainRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
}

export interface FindDomainByHridRequest {
  organizationId: string;
  environmentId: string;
  hrid: string;
}

export interface FindGroupRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  group: string;
}

export interface FindGroupRolesRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  group: string;
}

export interface FindIdentityProviderRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  identity: string;
}

export interface FindProtectedResourceRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  protectedResource: string;
  type?: string;
}

export interface FindRoleRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  role: string;
}

export interface FindRolesRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  page?: number;
  size?: number;
  q?: string;
}

export interface FindScopeRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  scope: string;
}

export interface FindUserRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
}

export interface Get10Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  authDeviceNotifier: string;
}

export interface Get11Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  template: Get11TemplateEnum;
}

export interface Get12Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  template: Get12TemplateEnum;
}

export interface Get13Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  reporter: string;
}

export interface Get14Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  audit: string;
}

export interface Get15Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  consent: string;
}

export interface Get16Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  credential: string;
}

export interface Get3Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  from?: number;
  to?: number;
  interval?: number;
  size?: number;
  type: AnalyticsTypeParam;
  field?: string;
}

export interface Get4Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  from?: number;
  to?: number;
  interval?: number;
  size?: number;
  type: AnalyticsTypeParam;
  field?: string;
}

export interface Get5Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  template: Get5TemplateEnum;
}

export interface Get6Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  template: Get6TemplateEnum;
}

export interface Get7Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  resource: string;
}

export interface Get8Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  resource: string;
  policy: string;
}

export interface Get9Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  audit: string;
}

export interface GetAlertNotifierRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  notifierId: string;
}

export interface GetAppFlowRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  flow: string;
}

export interface GetBotDetectionRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  botDetection: string;
}

export interface GetCertificatePublicKeyRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  certificate: string;
}

export interface GetCertificatePublicKeysRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  certificate: string;
}

export interface GetDeviceIdentifierRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  deviceIdentifier: string;
}

export interface GetDomainEntrypointsRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
}

export interface GetDomainFlowRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  flow: string;
}

export interface GetEffectivePasswordPolicyRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  identity?: string;
}

export interface GetExtensionGrantRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  extensionGrant: string;
}

export interface GetFactorRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  factor: string;
}

export interface GetGroupMembersRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  group: string;
  page?: number;
  size?: number;
}

export interface GetI18nDictionaryRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  dictionary: string;
}

export interface GetMembersRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
}

export interface GetPasswordPolicyRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  policy: string;
}

export interface GetResourceRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  resource: string;
}

export interface GetSecretsRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
}

export interface GetThemeRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  themeId: string;
}

export interface List10Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  type?: string;
  status?: string;
  from?: number;
  to?: number;
  size?: number;
  page?: number;
}

export interface List11Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  clientId?: string;
}

export interface List12Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
}

export interface List13Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
}

export interface List14Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
}

export interface List15Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
}

export interface List16Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  dynamic?: boolean;
}

export interface List2Request {
  organizationId: string;
  environmentId: string;
  domain: string;
}

export interface List3Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  patchAlertTrigger: Array<PatchAlertTrigger>;
}

export interface List4Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  resource: string;
}

export interface List5Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  page?: number;
  size?: number;
}

export interface List6Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  type?: string;
  status?: string;
  user?: string;
  from?: number;
  to?: number;
  size?: number;
  page?: number;
}

export interface List7Request {
  organizationId: string;
  environmentId: string;
  domain: string;
}

export interface List8Request {
  organizationId: string;
  environmentId: string;
  domain: string;
}

export interface List9Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  userProvider?: boolean;
}

export interface ListAlertNotifiersRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
}

export interface ListAppFlowsRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
}

export interface ListApplicationsRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  page?: number;
  size?: number;
  q?: string;
}

export interface ListAuthorizationEnginesRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
}

export interface ListBotDetectionsRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
}

export interface ListCertificatesRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  use?: string;
}

export interface ListDeviceIdentifiersRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
}

export interface ListDomainFlowsRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
}

export interface ListDomainsRequest {
  organizationId: string;
  environmentId: string;
  page?: number;
  size?: number;
  q?: string;
}

export interface ListExtensionGrantsRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
}

export interface ListFactorsRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
}

export interface ListGroupsRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  page?: number;
  size?: number;
}

export interface ListI18nDictionariesRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
}

export interface ListIdentityProvidersRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  userProvider?: boolean;
}

export interface ListPasswordPoliciesRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
}

export interface ListProtectedResourcesRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  type?: string;
  page?: number;
  size?: number;
  sort?: string;
}

export interface ListResourcesRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
}

export interface ListScopesRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  page?: number;
  size?: number;
  q?: string;
}

export interface ListThemesRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
}

export interface ListUsersRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  q?: string;
  filter?: string;
  page?: number;
  size?: number;
}

export interface LockUserRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
}

export interface PatchAlertNotifierRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  notifierId: string;
  patchAlertNotifier: PatchAlertNotifier;
}

export interface PatchApplicationRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  patchApplication: PatchApplication;
}

export interface PatchDomainRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  patchDomain: PatchDomain;
}

export interface PatchScopeRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  scope: string;
  patchScope: PatchScope;
}

export interface PermissionsRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
}

export interface Permissions1Request {
  organizationId: string;
  environmentId: string;
  domain: string;
}

export interface PutI18nDictionaryRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  dictionary: string;
  updateI18nDictionary: UpdateI18nDictionary;
}

export interface RemoveGroupMemberRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  group: string;
  member: string;
}

export interface RemoveMemberRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  member: string;
}

export interface RemoveMember1Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  member: string;
}

export interface RenderDomainTemplateRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  previewRequest: PreviewRequest;
}

export interface RenewClientSecretRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  secret: string;
}

export interface ReplaceI18nDictionaryEntriesRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  dictionary: string;
  requestBody: { [key: string]: string };
}

export interface ResetPasswordRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  passwordValue: PasswordValue;
}

export interface RevokeRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  consent: string;
}

export interface Revoke1Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  credential: string;
}

export interface Revoke2Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  role: string;
}

export interface RevokeRoleRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  group: string;
  role: string;
}

export interface RotateCertificateRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
}

export interface SendRegistrationConfirmationRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
}

export interface SetDefaultPolicyRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  policy: string;
}

export interface UnlockUserRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
}

export interface Update1Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  email: string;
  updateEmail: UpdateEmail;
}

export interface Update2Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  form: string;
  updateForm: UpdateForm;
}

export interface Update3Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  authDeviceNotifier: string;
  updateAuthenticationDeviceNotifier: UpdateAuthenticationDeviceNotifier;
}

export interface Update4Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  email: string;
  updateEmail: UpdateEmail;
}

export interface Update5Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  form: string;
  updateForm: UpdateForm;
}

export interface Update6Request {
  organizationId: string;
  environmentId: string;
  domain: string;
  reporter: string;
  updateReporter: UpdateReporter;
}

export interface UpdateAppFlowRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  flow: string;
  flow2: Flow;
}

export interface UpdateApplicationRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  patchApplication: PatchApplication;
}

export interface UpdateApplicationTypeRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  application: string;
  patchApplicationType: PatchApplicationType;
}

export interface UpdateAuthorizationEngineRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  engineId: string;
  updateAuthorizationEngine: UpdateAuthorizationEngine;
}

export interface UpdateBotDetectionRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  botDetection: string;
  updateBotDetection: UpdateBotDetection;
}

export interface UpdateCertificateRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  certificate: string;
  updateCertificate: UpdateCertificate;
}

export interface UpdateDeviceIdentifierRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  deviceIdentifier: string;
  updateDeviceIdentifier: UpdateDeviceIdentifier;
}

export interface UpdateDomainRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  patchDomain: PatchDomain;
}

export interface UpdateDomainFlowRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  flow: string;
  flow2: Flow;
}

export interface UpdateExtensionGrantRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  extensionGrant: string;
  updateExtensionGrant: UpdateExtensionGrant;
}

export interface UpdateFactorRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  factor: string;
  updateFactor: UpdateFactor;
}

export interface UpdateGroupRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  group: string;
  updateGroup: UpdateGroup;
}

export interface UpdateIdentityProviderRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  identity: string;
  updateIdentityProvider: UpdateIdentityProvider;
}

export interface UpdatePasswordPolicyRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  policy: string;
  updatePasswordPolicy: UpdatePasswordPolicy;
}

export interface UpdateProtectedResourceRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  protectedResource: string;
  updateProtectedResource: UpdateProtectedResource;
}

export interface UpdateResourceRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  resource: string;
  updateServiceResource: UpdateServiceResource;
}

export interface UpdateRoleRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  role: string;
  updateRole: UpdateRole;
}

export interface UpdateScopeRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  scope: string;
  updateScope: UpdateScope;
}

export interface UpdateThemeRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  themeId: string;
  themeEntity: ThemeEntity;
}

export interface UpdateUserRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  updateUser: UpdateUser;
}

export interface UpdateUserStatusRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  statusEntity: StatusEntity;
}

export interface UpdateUsernameRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  usernameEntity: UsernameEntity;
}

/**
 *
 */
export class DomainApi extends runtime.BaseAPI {
  /**
   * User must have the DOMAIN_GROUP[UPDATE] permission on the specified domain or DOMAIN_GROUP[UPDATE] permission on the specified environment or DOMAIN_GROUP[UPDATE] permission on the specified organization
   * Add a group member
   */
  async addGroupMemberRaw(
    requestParameters: AddGroupMemberRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling addGroupMember.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling addGroupMember.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling addGroupMember.',
      );
    }

    if (requestParameters.group === null || requestParameters.group === undefined) {
      throw new runtime.RequiredError(
        'group',
        'Required parameter requestParameters.group was null or undefined when calling addGroupMember.',
      );
    }

    if (requestParameters.member === null || requestParameters.member === undefined) {
      throw new runtime.RequiredError(
        'member',
        'Required parameter requestParameters.member was null or undefined when calling addGroupMember.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/groups/{group}/members/{member}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'group'}}`, encodeURIComponent(String(requestParameters.group)))
          .replace(`{${'member'}}`, encodeURIComponent(String(requestParameters.member))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_GROUP[UPDATE] permission on the specified domain or DOMAIN_GROUP[UPDATE] permission on the specified environment or DOMAIN_GROUP[UPDATE] permission on the specified organization
   * Add a group member
   */
  async addGroupMember(requestParameters: AddGroupMemberRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.addGroupMemberRaw(requestParameters, initOverrides);
  }

  /**
   * User must have APPLICATION_MEMBER[CREATE] permission on the specified application or APPLICATION_MEMBER[CREATE] permission on the specified domain or APPLICATION_MEMBER[CREATE] permission on the specified environment or APPLICATION_MEMBER[CREATE] permission on the specified organization
   * Add or update an application member
   */
  async addOrUpdateMemberRaw(
    requestParameters: AddOrUpdateMemberRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling addOrUpdateMember.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling addOrUpdateMember.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling addOrUpdateMember.',
      );
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling addOrUpdateMember.',
      );
    }

    if (requestParameters.newMembership === null || requestParameters.newMembership === undefined) {
      throw new runtime.RequiredError(
        'newMembership',
        'Required parameter requestParameters.newMembership was null or undefined when calling addOrUpdateMember.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/members`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewMembershipToJSON(requestParameters.newMembership),
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have APPLICATION_MEMBER[CREATE] permission on the specified application or APPLICATION_MEMBER[CREATE] permission on the specified domain or APPLICATION_MEMBER[CREATE] permission on the specified environment or APPLICATION_MEMBER[CREATE] permission on the specified organization
   * Add or update an application member
   */
  async addOrUpdateMember(
    requestParameters: AddOrUpdateMemberRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.addOrUpdateMemberRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_MEMBER[CREATE] permission on the specified domain or DOMAIN_MEMBER[CREATE] permission on the specified environment or DOMAIN_MEMBER[CREATE] permission on the specified organization
   * Add or update an security domain member
   */
  async addOrUpdateMember1Raw(
    requestParameters: AddOrUpdateMember1Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling addOrUpdateMember1.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling addOrUpdateMember1.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling addOrUpdateMember1.',
      );
    }

    if (requestParameters.newMembership === null || requestParameters.newMembership === undefined) {
      throw new runtime.RequiredError(
        'newMembership',
        'Required parameter requestParameters.newMembership was null or undefined when calling addOrUpdateMember1.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/members`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewMembershipToJSON(requestParameters.newMembership),
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_MEMBER[CREATE] permission on the specified domain or DOMAIN_MEMBER[CREATE] permission on the specified environment or DOMAIN_MEMBER[CREATE] permission on the specified organization
   * Add or update an security domain member
   */
  async addOrUpdateMember1(
    requestParameters: AddOrUpdateMember1Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.addOrUpdateMember1Raw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Assign roles to a user
   */
  async assignRaw(
    requestParameters: AssignRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<User>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling assign.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling assign.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling assign.');
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError('user', 'Required parameter requestParameters.user was null or undefined when calling assign.');
    }

    if (requestParameters.requestBody === null || requestParameters.requestBody === undefined) {
      throw new runtime.RequiredError(
        'requestBody',
        'Required parameter requestParameters.requestBody was null or undefined when calling assign.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/roles`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.requestBody,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Assign roles to a user
   */
  async assign(requestParameters: AssignRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<User> {
    const response = await this.assignRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_IDENTITY_PROVIDER[UPDATE] permission on the specified domain or DOMAIN_IDENTITY_PROVIDER[UPDATE] permission on the specified environment or DOMAIN_IDENTITY_PROVIDER[UPDATE] permission on the specified organization
   * Assign password policy to identity provider
   */
  async assignPasswordPolicyToIdpRaw(
    requestParameters: AssignPasswordPolicyToIdpRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<AssignPasswordPolicy>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling assignPasswordPolicyToIdp.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling assignPasswordPolicyToIdp.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling assignPasswordPolicyToIdp.',
      );
    }

    if (requestParameters.identity === null || requestParameters.identity === undefined) {
      throw new runtime.RequiredError(
        'identity',
        'Required parameter requestParameters.identity was null or undefined when calling assignPasswordPolicyToIdp.',
      );
    }

    if (requestParameters.assignPasswordPolicy === null || requestParameters.assignPasswordPolicy === undefined) {
      throw new runtime.RequiredError(
        'assignPasswordPolicy',
        'Required parameter requestParameters.assignPasswordPolicy was null or undefined when calling assignPasswordPolicyToIdp.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/identities/{identity}/password-policy`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'identity'}}`, encodeURIComponent(String(requestParameters.identity))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: AssignPasswordPolicyToJSON(requestParameters.assignPasswordPolicy),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => AssignPasswordPolicyFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_IDENTITY_PROVIDER[UPDATE] permission on the specified domain or DOMAIN_IDENTITY_PROVIDER[UPDATE] permission on the specified environment or DOMAIN_IDENTITY_PROVIDER[UPDATE] permission on the specified organization
   * Assign password policy to identity provider
   */
  async assignPasswordPolicyToIdp(
    requestParameters: AssignPasswordPolicyToIdpRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<AssignPasswordPolicy> {
    const response = await this.assignPasswordPolicyToIdpRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_GROUP[UPDATE] permission on the specified domain or DOMAIN_GROUP[UPDATE] permission on the specified environment or DOMAIN_GROUP[UPDATE] permission on the specified organization
   * Assign roles to a group
   */
  async assignRolesRaw(
    requestParameters: AssignRolesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Group>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling assignRoles.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling assignRoles.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling assignRoles.',
      );
    }

    if (requestParameters.group === null || requestParameters.group === undefined) {
      throw new runtime.RequiredError(
        'group',
        'Required parameter requestParameters.group was null or undefined when calling assignRoles.',
      );
    }

    if (requestParameters.requestBody === null || requestParameters.requestBody === undefined) {
      throw new runtime.RequiredError(
        'requestBody',
        'Required parameter requestParameters.requestBody was null or undefined when calling assignRoles.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/groups/{group}/roles`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'group'}}`, encodeURIComponent(String(requestParameters.group))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.requestBody,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => GroupFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_GROUP[UPDATE] permission on the specified domain or DOMAIN_GROUP[UPDATE] permission on the specified environment or DOMAIN_GROUP[UPDATE] permission on the specified organization
   * Assign roles to a group
   */
  async assignRoles(requestParameters: AssignRolesRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Group> {
    const response = await this.assignRolesRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[CREATE/UPDATE/DELETE] permission on the specified domain, the environment, or the organization
   * Create/update/delete multiple users on the specified security domain
   */
  async bulkUserOperationRaw(
    requestParameters: BulkUserOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<BulkResponse>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling bulkUserOperation.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling bulkUserOperation.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling bulkUserOperation.',
      );
    }

    if (requestParameters.domainUserBulkRequest === null || requestParameters.domainUserBulkRequest === undefined) {
      throw new runtime.RequiredError(
        'domainUserBulkRequest',
        'Required parameter requestParameters.domainUserBulkRequest was null or undefined when calling bulkUserOperation.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/bulk`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: DomainUserBulkRequestToJSON(requestParameters.domainUserBulkRequest),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => BulkResponseFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_USER[CREATE/UPDATE/DELETE] permission on the specified domain, the environment, or the organization
   * Create/update/delete multiple users on the specified security domain
   */
  async bulkUserOperation(
    requestParameters: BulkUserOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<BulkResponse> {
    const response = await this.bulkUserOperationRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have APPLICATION_OPENID[CREATE] permission on the specified application or APPLICATION_OPENID[CREATE] permission on the specified domain or APPLICATION_OPENID[CREATE] permission on the specified environment or APPLICATION_OPENID[CREATE] permission on the specified organization
   * Create a secret for an application
   */
  async create1Raw(
    requestParameters: Create1Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ClientSecret>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling create1.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling create1.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling create1.');
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling create1.',
      );
    }

    if (requestParameters.newClientSecret === null || requestParameters.newClientSecret === undefined) {
      throw new runtime.RequiredError(
        'newClientSecret',
        'Required parameter requestParameters.newClientSecret was null or undefined when calling create1.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/secrets`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewClientSecretToJSON(requestParameters.newClientSecret),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ClientSecretFromJSON(jsonValue));
  }

  /**
   * User must have APPLICATION_OPENID[CREATE] permission on the specified application or APPLICATION_OPENID[CREATE] permission on the specified domain or APPLICATION_OPENID[CREATE] permission on the specified environment or APPLICATION_OPENID[CREATE] permission on the specified organization
   * Create a secret for an application
   */
  async create1(requestParameters: Create1Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<ClientSecret> {
    const response = await this.create1Raw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have APPLICATION_EMAIL_TEMPLATE[CREATE] permission on the specified application or APPLICATION_EMAIL_TEMPLATE[CREATE] permission on the specified domain or APPLICATION_EMAIL_TEMPLATE[CREATE] permission on the specified environment or APPLICATION_EMAIL_TEMPLATE[CREATE] permission on the specified organization
   * Create a email for an application
   */
  async create2Raw(
    requestParameters: Create2Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling create2.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling create2.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling create2.');
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling create2.',
      );
    }

    if (requestParameters.newEmail === null || requestParameters.newEmail === undefined) {
      throw new runtime.RequiredError(
        'newEmail',
        'Required parameter requestParameters.newEmail was null or undefined when calling create2.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/emails`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewEmailToJSON(requestParameters.newEmail),
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have APPLICATION_EMAIL_TEMPLATE[CREATE] permission on the specified application or APPLICATION_EMAIL_TEMPLATE[CREATE] permission on the specified domain or APPLICATION_EMAIL_TEMPLATE[CREATE] permission on the specified environment or APPLICATION_EMAIL_TEMPLATE[CREATE] permission on the specified organization
   * Create a email for an application
   */
  async create2(requestParameters: Create2Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.create2Raw(requestParameters, initOverrides);
  }

  /**
   * User must have APPLICATION_FORM[CREATE] permission on the specified application or APPLICATION_FORM[CREATE] permission on the specified domain or APPLICATION_FORM[CREATE] permission on the specified environment or APPLICATION_FORM[CREATE] permission on the specified organization
   * Create a form for an application
   */
  async create3Raw(
    requestParameters: Create3Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling create3.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling create3.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling create3.');
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling create3.',
      );
    }

    if (requestParameters.newForm === null || requestParameters.newForm === undefined) {
      throw new runtime.RequiredError(
        'newForm',
        'Required parameter requestParameters.newForm was null or undefined when calling create3.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/forms`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewFormToJSON(requestParameters.newForm),
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have APPLICATION_FORM[CREATE] permission on the specified application or APPLICATION_FORM[CREATE] permission on the specified domain or APPLICATION_FORM[CREATE] permission on the specified environment or APPLICATION_FORM[CREATE] permission on the specified organization
   * Create a form for an application
   */
  async create3(requestParameters: Create3Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.create3Raw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_AUTHDEVICE_NOTIFIER[CREATE] permission on the specified domain or DOMAIN_AUTHDEVICE_NOTIFIER[CREATE] permission on the specified environment or DOMAIN_AUTHDEVICE_NOTIFIER[CREATE] permission on the specified organization
   * Create an Authentication Device Notifier
   */
  async create4Raw(
    requestParameters: Create4Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling create4.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling create4.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling create4.');
    }

    if (requestParameters.newAuthenticationDeviceNotifier === null || requestParameters.newAuthenticationDeviceNotifier === undefined) {
      throw new runtime.RequiredError(
        'newAuthenticationDeviceNotifier',
        'Required parameter requestParameters.newAuthenticationDeviceNotifier was null or undefined when calling create4.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/auth-device-notifiers`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewAuthenticationDeviceNotifierToJSON(requestParameters.newAuthenticationDeviceNotifier),
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_AUTHDEVICE_NOTIFIER[CREATE] permission on the specified domain or DOMAIN_AUTHDEVICE_NOTIFIER[CREATE] permission on the specified environment or DOMAIN_AUTHDEVICE_NOTIFIER[CREATE] permission on the specified organization
   * Create an Authentication Device Notifier
   */
  async create4(requestParameters: Create4Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.create4Raw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_EMAIL_TEMPLATE[CREATE] permission on the specified domain or DOMAIN_EMAIL_TEMPLATE[CREATE] permission on the specified environment or DOMAIN_EMAIL_TEMPLATE[CREATE] permission on the specified organization
   * Create a email
   */
  async create5Raw(
    requestParameters: Create5Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling create5.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling create5.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling create5.');
    }

    if (requestParameters.newEmail === null || requestParameters.newEmail === undefined) {
      throw new runtime.RequiredError(
        'newEmail',
        'Required parameter requestParameters.newEmail was null or undefined when calling create5.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/emails`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewEmailToJSON(requestParameters.newEmail),
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_EMAIL_TEMPLATE[CREATE] permission on the specified domain or DOMAIN_EMAIL_TEMPLATE[CREATE] permission on the specified environment or DOMAIN_EMAIL_TEMPLATE[CREATE] permission on the specified organization
   * Create a email
   */
  async create5(requestParameters: Create5Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.create5Raw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_FORM[CREATE] permission on the specified domain or DOMAIN_FORM[CREATE] permission on the specified environment or DOMAIN_FORM[CREATE] permission on the specified organization
   * Create a form
   */
  async create6Raw(
    requestParameters: Create6Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling create6.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling create6.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling create6.');
    }

    if (requestParameters.newForm === null || requestParameters.newForm === undefined) {
      throw new runtime.RequiredError(
        'newForm',
        'Required parameter requestParameters.newForm was null or undefined when calling create6.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/forms`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewFormToJSON(requestParameters.newForm),
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_FORM[CREATE] permission on the specified domain or DOMAIN_FORM[CREATE] permission on the specified environment or DOMAIN_FORM[CREATE] permission on the specified organization
   * Create a form
   */
  async create6(requestParameters: Create6Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.create6Raw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_REPORTER[CREATE] permission on the specified domain or DOMAIN_REPORTER[CREATE] permission on the specified environment or DOMAIN_REPORTER[CREATE] permission on the specified organization.
   * Create a reporter for a security domain
   */
  async create7Raw(
    requestParameters: Create7Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Reporter>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling create7.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling create7.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling create7.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/reporters`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewReporterToJSON(requestParameters.newReporter),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ReporterFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_REPORTER[CREATE] permission on the specified domain or DOMAIN_REPORTER[CREATE] permission on the specified environment or DOMAIN_REPORTER[CREATE] permission on the specified organization.
   * Create a reporter for a security domain
   */
  async create7(requestParameters: Create7Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Reporter> {
    const response = await this.create7Raw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Create a new alert notifierUser must have DOMAIN_ALERT_NOTIFIER[CREATE] permission on the specified domain, environment or organization.
   * Create an alert notifier
   */
  async createAlertNotifierRaw(
    requestParameters: CreateAlertNotifierRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<AlertNotifier>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createAlertNotifier.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createAlertNotifier.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling createAlertNotifier.',
      );
    }

    if (requestParameters.newAlertNotifier === null || requestParameters.newAlertNotifier === undefined) {
      throw new runtime.RequiredError(
        'newAlertNotifier',
        'Required parameter requestParameters.newAlertNotifier was null or undefined when calling createAlertNotifier.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/alerts/notifiers`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewAlertNotifierToJSON(requestParameters.newAlertNotifier),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => AlertNotifierFromJSON(jsonValue));
  }

  /**
   * Create a new alert notifierUser must have DOMAIN_ALERT_NOTIFIER[CREATE] permission on the specified domain, environment or organization.
   * Create an alert notifier
   */
  async createAlertNotifier(
    requestParameters: CreateAlertNotifierRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<AlertNotifier> {
    const response = await this.createAlertNotifierRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have APPLICATION[CREATE] permission on the specified domain or APPLICATION[CREATE] permission on the specified environment or APPLICATION[CREATE] permission on the specified organization
   * Create an application
   */
  async createApplicationRaw(
    requestParameters: CreateApplicationRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Application>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createApplication.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createApplication.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling createApplication.',
      );
    }

    if (requestParameters.newApplication === null || requestParameters.newApplication === undefined) {
      throw new runtime.RequiredError(
        'newApplication',
        'Required parameter requestParameters.newApplication was null or undefined when calling createApplication.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewApplicationToJSON(requestParameters.newApplication),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ApplicationFromJSON(jsonValue));
  }

  /**
   * User must have APPLICATION[CREATE] permission on the specified domain or APPLICATION[CREATE] permission on the specified environment or APPLICATION[CREATE] permission on the specified organization
   * Create an application
   */
  async createApplication(
    requestParameters: CreateApplicationRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Application> {
    const response = await this.createApplicationRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_AUTHORIZATION_ENGINE[CREATE] permission on the specified domain or DOMAIN_AUTHORIZATION_ENGINE[CREATE] permission on the specified environment or DOMAIN_AUTHORIZATION_ENGINE[CREATE] permission on the specified organization
   * Create an authorization engine
   */
  async createAuthorizationEngineRaw(
    requestParameters: CreateAuthorizationEngineRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<AuthorizationEngine>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createAuthorizationEngine.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createAuthorizationEngine.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling createAuthorizationEngine.',
      );
    }

    if (requestParameters.newAuthorizationEngine === null || requestParameters.newAuthorizationEngine === undefined) {
      throw new runtime.RequiredError(
        'newAuthorizationEngine',
        'Required parameter requestParameters.newAuthorizationEngine was null or undefined when calling createAuthorizationEngine.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/authorization-engines`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewAuthorizationEngineToJSON(requestParameters.newAuthorizationEngine),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => AuthorizationEngineFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_AUTHORIZATION_ENGINE[CREATE] permission on the specified domain or DOMAIN_AUTHORIZATION_ENGINE[CREATE] permission on the specified environment or DOMAIN_AUTHORIZATION_ENGINE[CREATE] permission on the specified organization
   * Create an authorization engine
   */
  async createAuthorizationEngine(
    requestParameters: CreateAuthorizationEngineRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<AuthorizationEngine> {
    const response = await this.createAuthorizationEngineRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_BOT_DETECTION[CREATE] permission on the specified domain or DOMAIN_BOT_DETECTION[CREATE] permission on the specified environment or DOMAIN_BOT_DETECTION[CREATE] permission on the specified organization
   * Create a bot detection
   */
  async createBotDetectionRaw(
    requestParameters: CreateBotDetectionRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<BotDetection>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createBotDetection.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createBotDetection.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling createBotDetection.',
      );
    }

    if (requestParameters.newBotDetection === null || requestParameters.newBotDetection === undefined) {
      throw new runtime.RequiredError(
        'newBotDetection',
        'Required parameter requestParameters.newBotDetection was null or undefined when calling createBotDetection.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/bot-detections`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewBotDetectionToJSON(requestParameters.newBotDetection),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => BotDetectionFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_BOT_DETECTION[CREATE] permission on the specified domain or DOMAIN_BOT_DETECTION[CREATE] permission on the specified environment or DOMAIN_BOT_DETECTION[CREATE] permission on the specified organization
   * Create a bot detection
   */
  async createBotDetection(
    requestParameters: CreateBotDetectionRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<BotDetection> {
    const response = await this.createBotDetectionRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_CERTIFICATE[CREATE] permission on the specified domain or DOMAIN_CERTIFICATE[CREATE] permission on the specified environment or DOMAIN_CERTIFICATE[CREATE] permission on the specified organization
   * Create a certificate
   */
  async createCertificateRaw(
    requestParameters: CreateCertificateRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ModifiedCertificateEntity>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createCertificate.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createCertificate.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling createCertificate.',
      );
    }

    if (requestParameters.newCertificate === null || requestParameters.newCertificate === undefined) {
      throw new runtime.RequiredError(
        'newCertificate',
        'Required parameter requestParameters.newCertificate was null or undefined when calling createCertificate.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/certificates`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewCertificateToJSON(requestParameters.newCertificate),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ModifiedCertificateEntityFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_CERTIFICATE[CREATE] permission on the specified domain or DOMAIN_CERTIFICATE[CREATE] permission on the specified environment or DOMAIN_CERTIFICATE[CREATE] permission on the specified organization
   * Create a certificate
   */
  async createCertificate(
    requestParameters: CreateCertificateRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<ModifiedCertificateEntity> {
    const response = await this.createCertificateRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_DEVICE_IDENTIFIER[CREATE] permission on the specified domain or DOMAIN_DEVICE_IDENTIFIER[CREATE] permission on the specified environment or DOMAIN_DEVICE_IDENTIFIER[CREATE] permission on the specified organization
   * Create a device identifier
   */
  async createDeviceIdentifierRaw(
    requestParameters: CreateDeviceIdentifierRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<DeviceIdentifier>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createDeviceIdentifier.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createDeviceIdentifier.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling createDeviceIdentifier.',
      );
    }

    if (requestParameters.newDeviceIdentifier === null || requestParameters.newDeviceIdentifier === undefined) {
      throw new runtime.RequiredError(
        'newDeviceIdentifier',
        'Required parameter requestParameters.newDeviceIdentifier was null or undefined when calling createDeviceIdentifier.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/device-identifiers`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewDeviceIdentifierToJSON(requestParameters.newDeviceIdentifier),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => DeviceIdentifierFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_DEVICE_IDENTIFIER[CREATE] permission on the specified domain or DOMAIN_DEVICE_IDENTIFIER[CREATE] permission on the specified environment or DOMAIN_DEVICE_IDENTIFIER[CREATE] permission on the specified organization
   * Create a device identifier
   */
  async createDeviceIdentifier(
    requestParameters: CreateDeviceIdentifierRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<DeviceIdentifier> {
    const response = await this.createDeviceIdentifierRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Create a security domain. User must have DOMAIN[CREATE] permission on the specified environment or DOMAIN[CREATE] permission on the specified organization
   * Create a security domain.
   */
  async createDomainRaw(
    requestParameters: CreateDomainRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Domain>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createDomain.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createDomain.',
      );
    }

    if (requestParameters.newDomain === null || requestParameters.newDomain === undefined) {
      throw new runtime.RequiredError(
        'newDomain',
        'Required parameter requestParameters.newDomain was null or undefined when calling createDomain.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewDomainToJSON(requestParameters.newDomain),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => DomainFromJSON(jsonValue));
  }

  /**
   * Create a security domain. User must have DOMAIN[CREATE] permission on the specified environment or DOMAIN[CREATE] permission on the specified organization
   * Create a security domain.
   */
  async createDomain(requestParameters: CreateDomainRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Domain> {
    const response = await this.createDomainRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_EXTENSION_GRANT[CREATE] permission on the specified domain or DOMAIN_EXTENSION_GRANT[CREATE] permission on the specified environment or DOMAIN_EXTENSION_GRANT[CREATE] permission on the specified organization
   * Create a extension grant
   */
  async createExtensionGrantRaw(
    requestParameters: CreateExtensionGrantRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ExtensionGrant>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createExtensionGrant.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createExtensionGrant.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling createExtensionGrant.',
      );
    }

    if (requestParameters.newExtensionGrant === null || requestParameters.newExtensionGrant === undefined) {
      throw new runtime.RequiredError(
        'newExtensionGrant',
        'Required parameter requestParameters.newExtensionGrant was null or undefined when calling createExtensionGrant.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/extensionGrants`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewExtensionGrantToJSON(requestParameters.newExtensionGrant),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ExtensionGrantFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_EXTENSION_GRANT[CREATE] permission on the specified domain or DOMAIN_EXTENSION_GRANT[CREATE] permission on the specified environment or DOMAIN_EXTENSION_GRANT[CREATE] permission on the specified organization
   * Create a extension grant
   */
  async createExtensionGrant(
    requestParameters: CreateExtensionGrantRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<ExtensionGrant> {
    const response = await this.createExtensionGrantRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_FACTOR[CREATE] permission on the specified domain or DOMAIN_FACTOR[CREATE] permission on the specified environment or DOMAIN_FACTOR[CREATE] permission on the specified organization
   * Create a factor
   */
  async createFactorRaw(
    requestParameters: CreateFactorRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Factor>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createFactor.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createFactor.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling createFactor.',
      );
    }

    if (requestParameters.newFactor === null || requestParameters.newFactor === undefined) {
      throw new runtime.RequiredError(
        'newFactor',
        'Required parameter requestParameters.newFactor was null or undefined when calling createFactor.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/factors`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewFactorToJSON(requestParameters.newFactor),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => FactorFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_FACTOR[CREATE] permission on the specified domain or DOMAIN_FACTOR[CREATE] permission on the specified environment or DOMAIN_FACTOR[CREATE] permission on the specified organization
   * Create a factor
   */
  async createFactor(requestParameters: CreateFactorRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Factor> {
    const response = await this.createFactorRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_GROUP[CREATE] permission on the specified domain or DOMAIN_GROUP[CREATE] permission on the specified environment or DOMAIN_GROUP[CREATE] permission on the specified organization
   * Create a group
   */
  async createGroupRaw(
    requestParameters: CreateGroupRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Group>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createGroup.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createGroup.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling createGroup.',
      );
    }

    if (requestParameters.newGroup === null || requestParameters.newGroup === undefined) {
      throw new runtime.RequiredError(
        'newGroup',
        'Required parameter requestParameters.newGroup was null or undefined when calling createGroup.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/groups`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewGroupToJSON(requestParameters.newGroup),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => GroupFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_GROUP[CREATE] permission on the specified domain or DOMAIN_GROUP[CREATE] permission on the specified environment or DOMAIN_GROUP[CREATE] permission on the specified organization
   * Create a group
   */
  async createGroup(requestParameters: CreateGroupRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Group> {
    const response = await this.createGroupRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_I18N_DICTIONARY[CREATE] permission on the specified domain or DOMAIN_I18N_DICTIONARY[CREATE] permission on the specified environment or DOMAIN_I18N_DICTIONARY[CREATE] permission on the specified organization.
   * Create a new i18n dictionary for a supported language for a security domain
   */
  async createI18nDictionaryRaw(
    requestParameters: CreateI18nDictionaryRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<I18nDictionary>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createI18nDictionary.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createI18nDictionary.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling createI18nDictionary.',
      );
    }

    if (requestParameters.newDictionary === null || requestParameters.newDictionary === undefined) {
      throw new runtime.RequiredError(
        'newDictionary',
        'Required parameter requestParameters.newDictionary was null or undefined when calling createI18nDictionary.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/i18n/dictionaries`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewDictionaryToJSON(requestParameters.newDictionary),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => I18nDictionaryFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_I18N_DICTIONARY[CREATE] permission on the specified domain or DOMAIN_I18N_DICTIONARY[CREATE] permission on the specified environment or DOMAIN_I18N_DICTIONARY[CREATE] permission on the specified organization.
   * Create a new i18n dictionary for a supported language for a security domain
   */
  async createI18nDictionary(
    requestParameters: CreateI18nDictionaryRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<I18nDictionary> {
    const response = await this.createI18nDictionaryRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_IDENTITY_PROVIDER[CREATE] permission on the specified domain or DOMAIN_IDENTITY_PROVIDER[CREATE] permission on the specified environment or DOMAIN_IDENTITY_PROVIDER[CREATE] permission on the specified organization
   * Create an identity provider
   */
  async createIdentityProviderRaw(
    requestParameters: CreateIdentityProviderRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<IdentityProvider>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createIdentityProvider.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createIdentityProvider.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling createIdentityProvider.',
      );
    }

    if (requestParameters.newIdentityProvider === null || requestParameters.newIdentityProvider === undefined) {
      throw new runtime.RequiredError(
        'newIdentityProvider',
        'Required parameter requestParameters.newIdentityProvider was null or undefined when calling createIdentityProvider.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/identities`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewIdentityProviderToJSON(requestParameters.newIdentityProvider),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => IdentityProviderFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_IDENTITY_PROVIDER[CREATE] permission on the specified domain or DOMAIN_IDENTITY_PROVIDER[CREATE] permission on the specified environment or DOMAIN_IDENTITY_PROVIDER[CREATE] permission on the specified organization
   * Create an identity provider
   */
  async createIdentityProvider(
    requestParameters: CreateIdentityProviderRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<IdentityProvider> {
    const response = await this.createIdentityProviderRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_SETTINGS[UPDATE] permission on the specified domain or DOMAIN_SETTINGS[UPDATE] permission on the specified environment or DOMAIN_SETTINGS[UPDATE] permission on the specified organization
   * Create a password policy
   */
  async createPasswordPolicyRaw(
    requestParameters: CreatePasswordPolicyRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<PasswordPolicy>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createPasswordPolicy.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createPasswordPolicy.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling createPasswordPolicy.',
      );
    }

    if (requestParameters.newPasswordPolicy === null || requestParameters.newPasswordPolicy === undefined) {
      throw new runtime.RequiredError(
        'newPasswordPolicy',
        'Required parameter requestParameters.newPasswordPolicy was null or undefined when calling createPasswordPolicy.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/password-policies`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewPasswordPolicyToJSON(requestParameters.newPasswordPolicy),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => PasswordPolicyFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_SETTINGS[UPDATE] permission on the specified domain or DOMAIN_SETTINGS[UPDATE] permission on the specified environment or DOMAIN_SETTINGS[UPDATE] permission on the specified organization
   * Create a password policy
   */
  async createPasswordPolicy(
    requestParameters: CreatePasswordPolicyRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<PasswordPolicy> {
    const response = await this.createPasswordPolicyRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have PROTECTED_RESOURCE[CREATE] permission on the specified domain or PROTECTED_RESOURCE[CREATE] permission on the specified environment or PROTECTED_RESOURCE[CREATE] permission on the specified organization
   * Create a Protected Resource definition
   */
  async createProtectedResourceRaw(
    requestParameters: CreateProtectedResourceRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ProtectedResourceSecret>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createProtectedResource.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createProtectedResource.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling createProtectedResource.',
      );
    }

    if (requestParameters.newProtectedResource === null || requestParameters.newProtectedResource === undefined) {
      throw new runtime.RequiredError(
        'newProtectedResource',
        'Required parameter requestParameters.newProtectedResource was null or undefined when calling createProtectedResource.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/protected-resources`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewProtectedResourceToJSON(requestParameters.newProtectedResource),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ProtectedResourceSecretFromJSON(jsonValue));
  }

  /**
   * User must have PROTECTED_RESOURCE[CREATE] permission on the specified domain or PROTECTED_RESOURCE[CREATE] permission on the specified environment or PROTECTED_RESOURCE[CREATE] permission on the specified organization
   * Create a Protected Resource definition
   */
  async createProtectedResource(
    requestParameters: CreateProtectedResourceRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<ProtectedResourceSecret> {
    const response = await this.createProtectedResourceRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_RESOURCE[CREATE] permission on the specified domain or DOMAIN_RESOURCE[CREATE] permission on the specified environment or DOMAIN_RESOURCE[CREATE] permission on the specified organization
   * Create a resource
   */
  async createResourceRaw(
    requestParameters: CreateResourceRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ServiceResource>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createResource.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createResource.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling createResource.',
      );
    }

    if (requestParameters.newServiceResource === null || requestParameters.newServiceResource === undefined) {
      throw new runtime.RequiredError(
        'newServiceResource',
        'Required parameter requestParameters.newServiceResource was null or undefined when calling createResource.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/resources`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewServiceResourceToJSON(requestParameters.newServiceResource),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ServiceResourceFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_RESOURCE[CREATE] permission on the specified domain or DOMAIN_RESOURCE[CREATE] permission on the specified environment or DOMAIN_RESOURCE[CREATE] permission on the specified organization
   * Create a resource
   */
  async createResource(
    requestParameters: CreateResourceRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<ServiceResource> {
    const response = await this.createResourceRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_ROLE[CREATE] permission on the specified domain or DOMAIN_ROLE[CREATE] permission on the specified environment or DOMAIN_ROLE[CREATE] permission on the specified organization
   * Create a role
   */
  async createRoleRaw(
    requestParameters: CreateRoleRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Role>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createRole.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createRole.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling createRole.',
      );
    }

    if (requestParameters.newRole === null || requestParameters.newRole === undefined) {
      throw new runtime.RequiredError(
        'newRole',
        'Required parameter requestParameters.newRole was null or undefined when calling createRole.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/roles`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewRoleToJSON(requestParameters.newRole),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => RoleFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_ROLE[CREATE] permission on the specified domain or DOMAIN_ROLE[CREATE] permission on the specified environment or DOMAIN_ROLE[CREATE] permission on the specified organization
   * Create a role
   */
  async createRole(requestParameters: CreateRoleRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Role> {
    const response = await this.createRoleRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_SCOPE[CREATE] permission on the specified domain or DOMAIN_SCOPE[CREATE] permission on the specified environment or DOMAIN_SCOPE[CREATE] permission on the specified organization
   * Create a scope
   */
  async createScopeRaw(
    requestParameters: CreateScopeRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Scope>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createScope.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createScope.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling createScope.',
      );
    }

    if (requestParameters.newScope === null || requestParameters.newScope === undefined) {
      throw new runtime.RequiredError(
        'newScope',
        'Required parameter requestParameters.newScope was null or undefined when calling createScope.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/scopes`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewScopeToJSON(requestParameters.newScope),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ScopeFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_SCOPE[CREATE] permission on the specified domain or DOMAIN_SCOPE[CREATE] permission on the specified environment or DOMAIN_SCOPE[CREATE] permission on the specified organization
   * Create a scope
   */
  async createScope(requestParameters: CreateScopeRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Scope> {
    const response = await this.createScopeRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_THEME[CREATE] permission on the specified domain or DOMAIN_THEME[CREATE] permission on the specified environment or DOMAIN_THEME[CREATE] permission on the specified organization
   * Create a theme on the specified security domain
   */
  async createThemeRaw(
    requestParameters: CreateThemeRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ThemeEntity>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createTheme.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createTheme.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling createTheme.',
      );
    }

    if (requestParameters.newTheme === null || requestParameters.newTheme === undefined) {
      throw new runtime.RequiredError(
        'newTheme',
        'Required parameter requestParameters.newTheme was null or undefined when calling createTheme.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/themes`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewThemeToJSON(requestParameters.newTheme),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ThemeEntityFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_THEME[CREATE] permission on the specified domain or DOMAIN_THEME[CREATE] permission on the specified environment or DOMAIN_THEME[CREATE] permission on the specified organization
   * Create a theme on the specified security domain
   */
  async createTheme(
    requestParameters: CreateThemeRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<ThemeEntity> {
    const response = await this.createThemeRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[CREATE] permission on the specified domain or DOMAIN_USER[CREATE] permission on the specified environment or DOMAIN_USER[CREATE] permission on the specified organization
   * Create a user on the specified security domain
   */
  async createUserRaw(
    requestParameters: CreateUserRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<User>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createUser.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createUser.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling createUser.',
      );
    }

    if (requestParameters.newUser === null || requestParameters.newUser === undefined) {
      throw new runtime.RequiredError(
        'newUser',
        'Required parameter requestParameters.newUser was null or undefined when calling createUser.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewUserToJSON(requestParameters.newUser),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_USER[CREATE] permission on the specified domain or DOMAIN_USER[CREATE] permission on the specified environment or DOMAIN_USER[CREATE] permission on the specified organization
   * Create a user on the specified security domain
   */
  async createUser(requestParameters: CreateUserRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<User> {
    const response = await this.createUserRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the APPLICATION_FLOW[UPDATE] permission on the specified domain or APPLICATION_FLOW[UPDATE] permission on the specified environment or APPLICATION_FLOW[UPDATE] permission on the specified organization
   * Create or update list of flows
   */
  async defineAppFlowsRaw(
    requestParameters: DefineAppFlowsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<FlowEntity>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling defineAppFlows.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling defineAppFlows.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling defineAppFlows.',
      );
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling defineAppFlows.',
      );
    }

    if (requestParameters.flow === null || requestParameters.flow === undefined) {
      throw new runtime.RequiredError(
        'flow',
        'Required parameter requestParameters.flow was null or undefined when calling defineAppFlows.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/flows`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.flow.map(FlowToJSON),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(FlowEntityFromJSON));
  }

  /**
   * User must have the APPLICATION_FLOW[UPDATE] permission on the specified domain or APPLICATION_FLOW[UPDATE] permission on the specified environment or APPLICATION_FLOW[UPDATE] permission on the specified organization
   * Create or update list of flows
   */
  async defineAppFlows(
    requestParameters: DefineAppFlowsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<FlowEntity>> {
    const response = await this.defineAppFlowsRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_FLOW[UPDATE] permission on the specified domain or DOMAIN_FLOW[UPDATE] permission on the specified environment or DOMAIN_FLOW[UPDATE] permission on the specified organization
   * Create or update list of flows
   */
  async defineDomainFlowsRaw(
    requestParameters: DefineDomainFlowsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<FlowEntity>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling defineDomainFlows.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling defineDomainFlows.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling defineDomainFlows.',
      );
    }

    if (requestParameters.flow === null || requestParameters.flow === undefined) {
      throw new runtime.RequiredError(
        'flow',
        'Required parameter requestParameters.flow was null or undefined when calling defineDomainFlows.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/flows`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.flow.map(FlowToJSON),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(FlowEntityFromJSON));
  }

  /**
   * User must have the DOMAIN_FLOW[UPDATE] permission on the specified domain or DOMAIN_FLOW[UPDATE] permission on the specified environment or DOMAIN_FLOW[UPDATE] permission on the specified organization
   * Create or update list of flows
   */
  async defineDomainFlows(
    requestParameters: DefineDomainFlowsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<FlowEntity>> {
    const response = await this.defineDomainFlowsRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have APPLICATION_OPENID[DELETE] permission on the specified application or APPLICATION_OPENID[DELETE] permission on the specified domain or APPLICATION_OPENID[DELETE] permission on the specified environment or APPLICATION_OPENID[DELETE] permission on the specified organization
   * Delete a secret of an application
   */
  async delete1Raw(
    requestParameters: Delete1Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling delete1.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling delete1.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling delete1.');
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling delete1.',
      );
    }

    if (requestParameters.secret === null || requestParameters.secret === undefined) {
      throw new runtime.RequiredError('secret', 'Required parameter requestParameters.secret was null or undefined when calling delete1.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/secrets/{secret}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application)))
          .replace(`{${'secret'}}`, encodeURIComponent(String(requestParameters.secret))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have APPLICATION_OPENID[DELETE] permission on the specified application or APPLICATION_OPENID[DELETE] permission on the specified domain or APPLICATION_OPENID[DELETE] permission on the specified environment or APPLICATION_OPENID[DELETE] permission on the specified organization
   * Delete a secret of an application
   */
  async delete1(requestParameters: Delete1Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.delete1Raw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Unlink user identity
   */
  async delete10Raw(
    requestParameters: Delete10Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling delete10.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling delete10.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling delete10.');
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError('user', 'Required parameter requestParameters.user was null or undefined when calling delete10.');
    }

    if (requestParameters.identity === null || requestParameters.identity === undefined) {
      throw new runtime.RequiredError(
        'identity',
        'Required parameter requestParameters.identity was null or undefined when calling delete10.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/identities/{identity}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user)))
          .replace(`{${'identity'}}`, encodeURIComponent(String(requestParameters.identity))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Unlink user identity
   */
  async delete10(requestParameters: Delete10Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.delete10Raw(requestParameters, initOverrides);
  }

  /**
   * User must have APPLICATION_EMAIL_TEMPLATE[DELETE] permission on the specified application or APPLICATION_EMAIL_TEMPLATE[DELETE] permission on the specified domain or APPLICATION_EMAIL_TEMPLATE[DELETE] permission on the specified environment or APPLICATION_EMAIL_TEMPLATE[DELETE] permission on the specified organization
   * Delete an email for an application
   */
  async delete2Raw(
    requestParameters: Delete2Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling delete2.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling delete2.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling delete2.');
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling delete2.',
      );
    }

    if (requestParameters.email === null || requestParameters.email === undefined) {
      throw new runtime.RequiredError('email', 'Required parameter requestParameters.email was null or undefined when calling delete2.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/emails/{email}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application)))
          .replace(`{${'email'}}`, encodeURIComponent(String(requestParameters.email))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have APPLICATION_EMAIL_TEMPLATE[DELETE] permission on the specified application or APPLICATION_EMAIL_TEMPLATE[DELETE] permission on the specified domain or APPLICATION_EMAIL_TEMPLATE[DELETE] permission on the specified environment or APPLICATION_EMAIL_TEMPLATE[DELETE] permission on the specified organization
   * Delete an email for an application
   */
  async delete2(requestParameters: Delete2Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.delete2Raw(requestParameters, initOverrides);
  }

  /**
   * User must have APPLICATION_FORM[DELETE] permission on the specified application or APPLICATION_FORM[DELETE] permission on the specified domain or APPLICATION_FORM[DELETE] permission on the specified environment or APPLICATION_FORM[DELETE] permission on the specified organization
   * Delete a form for an application
   */
  async delete3Raw(
    requestParameters: Delete3Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling delete3.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling delete3.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling delete3.');
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling delete3.',
      );
    }

    if (requestParameters.form === null || requestParameters.form === undefined) {
      throw new runtime.RequiredError('form', 'Required parameter requestParameters.form was null or undefined when calling delete3.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/forms/{form}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application)))
          .replace(`{${'form'}}`, encodeURIComponent(String(requestParameters.form))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have APPLICATION_FORM[DELETE] permission on the specified application or APPLICATION_FORM[DELETE] permission on the specified domain or APPLICATION_FORM[DELETE] permission on the specified environment or APPLICATION_FORM[DELETE] permission on the specified organization
   * Delete a form for an application
   */
  async delete3(requestParameters: Delete3Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.delete3Raw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_AUTHDEVICE_NOTIFIER[DELETE] permission on the specified domain or DOMAIN_AUTHDEVICE_NOTIFIER[DELETE] permission on the specified environment or DOMAIN_AUTHDEVICE_NOTIFIER[DELETE] permission on the specified organization
   * Delete an Authentication Device Notifier
   */
  async delete4Raw(
    requestParameters: Delete4Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling delete4.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling delete4.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling delete4.');
    }

    if (requestParameters.authDeviceNotifier === null || requestParameters.authDeviceNotifier === undefined) {
      throw new runtime.RequiredError(
        'authDeviceNotifier',
        'Required parameter requestParameters.authDeviceNotifier was null or undefined when calling delete4.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/auth-device-notifiers/{authDeviceNotifier}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'authDeviceNotifier'}}`, encodeURIComponent(String(requestParameters.authDeviceNotifier))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_AUTHDEVICE_NOTIFIER[DELETE] permission on the specified domain or DOMAIN_AUTHDEVICE_NOTIFIER[DELETE] permission on the specified environment or DOMAIN_AUTHDEVICE_NOTIFIER[DELETE] permission on the specified organization
   * Delete an Authentication Device Notifier
   */
  async delete4(requestParameters: Delete4Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.delete4Raw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_EMAIL_TEMPLATE[DELETE] permission on the specified domain or DOMAIN_EMAIL_TEMPLATE[DELETE] permission on the specified environment or DOMAIN_EMAIL_TEMPLATE[DELETE] permission on the specified organization
   * Delete an email
   */
  async delete5Raw(
    requestParameters: Delete5Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling delete5.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling delete5.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling delete5.');
    }

    if (requestParameters.email === null || requestParameters.email === undefined) {
      throw new runtime.RequiredError('email', 'Required parameter requestParameters.email was null or undefined when calling delete5.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/emails/{email}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'email'}}`, encodeURIComponent(String(requestParameters.email))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_EMAIL_TEMPLATE[DELETE] permission on the specified domain or DOMAIN_EMAIL_TEMPLATE[DELETE] permission on the specified environment or DOMAIN_EMAIL_TEMPLATE[DELETE] permission on the specified organization
   * Delete an email
   */
  async delete5(requestParameters: Delete5Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.delete5Raw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_FORM[DELETE] permission on the specified domain or DOMAIN_FORM[DELETE] permission on the specified environment or DOMAIN_FORM[DELETE] permission on the specified organization
   * Delete a form
   */
  async delete6Raw(
    requestParameters: Delete6Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling delete6.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling delete6.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling delete6.');
    }

    if (requestParameters.form === null || requestParameters.form === undefined) {
      throw new runtime.RequiredError('form', 'Required parameter requestParameters.form was null or undefined when calling delete6.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/forms/{form}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'form'}}`, encodeURIComponent(String(requestParameters.form))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_FORM[DELETE] permission on the specified domain or DOMAIN_FORM[DELETE] permission on the specified environment or DOMAIN_FORM[DELETE] permission on the specified organization
   * Delete a form
   */
  async delete6(requestParameters: Delete6Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.delete6Raw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_REPORTER[DELETE] permission on the specified domain or DOMAIN_REPORTER[DELETE] permission on the specified environment or DOMAIN_REPORTER[DELETE] permission on the specified organization
   * Delete a reporter
   */
  async delete7Raw(
    requestParameters: Delete7Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling delete7.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling delete7.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling delete7.');
    }

    if (requestParameters.reporter === null || requestParameters.reporter === undefined) {
      throw new runtime.RequiredError(
        'reporter',
        'Required parameter requestParameters.reporter was null or undefined when calling delete7.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/reporters/{reporter}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'reporter'}}`, encodeURIComponent(String(requestParameters.reporter))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_REPORTER[DELETE] permission on the specified domain or DOMAIN_REPORTER[DELETE] permission on the specified environment or DOMAIN_REPORTER[DELETE] permission on the specified organization
   * Delete a reporter
   */
  async delete7(requestParameters: Delete7Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.delete7Raw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Revoke user consents
   */
  async delete8Raw(
    requestParameters: Delete8Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling delete8.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling delete8.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling delete8.');
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError('user', 'Required parameter requestParameters.user was null or undefined when calling delete8.');
    }

    const queryParameters: any = {};

    if (requestParameters.clientId !== undefined) {
      queryParameters['clientId'] = requestParameters.clientId;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/consents`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Revoke user consents
   */
  async delete8(requestParameters: Delete8Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.delete8Raw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_USER_DEVICE[DELETE] permission on the specified domain or DOMAIN_USER_DEVICE[DELETE] permission on the specified environment or DOMAIN_USER_DEVICE[DELETE] permission on the specified organization
   * Delete a device
   */
  async delete9Raw(
    requestParameters: Delete9Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling delete9.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling delete9.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling delete9.');
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError('user', 'Required parameter requestParameters.user was null or undefined when calling delete9.');
    }

    if (requestParameters.device === null || requestParameters.device === undefined) {
      throw new runtime.RequiredError('device', 'Required parameter requestParameters.device was null or undefined when calling delete9.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/devices/{device}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user)))
          .replace(`{${'device'}}`, encodeURIComponent(String(requestParameters.device))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_USER_DEVICE[DELETE] permission on the specified domain or DOMAIN_USER_DEVICE[DELETE] permission on the specified environment or DOMAIN_USER_DEVICE[DELETE] permission on the specified organization
   * Delete a device
   */
  async delete9(requestParameters: Delete9Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.delete9Raw(requestParameters, initOverrides);
  }

  /**
   * Delete an alert notifier by its id. User must have DOMAIN_ALERT_NOTIFIER[DELETE] permission on the specified domain, environment or organization.
   * Delete an alert notifier
   */
  async deleteAlertNotifierRaw(
    requestParameters: DeleteAlertNotifierRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteAlertNotifier.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteAlertNotifier.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteAlertNotifier.',
      );
    }

    if (requestParameters.notifierId === null || requestParameters.notifierId === undefined) {
      throw new runtime.RequiredError(
        'notifierId',
        'Required parameter requestParameters.notifierId was null or undefined when calling deleteAlertNotifier.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/alerts/notifiers/{notifierId}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'notifierId'}}`, encodeURIComponent(String(requestParameters.notifierId))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Delete an alert notifier by its id. User must have DOMAIN_ALERT_NOTIFIER[DELETE] permission on the specified domain, environment or organization.
   * Delete an alert notifier
   */
  async deleteAlertNotifier(
    requestParameters: DeleteAlertNotifierRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.deleteAlertNotifierRaw(requestParameters, initOverrides);
  }

  /**
   * User must have APPLICATION[DELETE] permission on the specified application or APPLICATION[DELETE] permission on the specified domain or APPLICATION[DELETE] permission on the specified environment or APPLICATION[DELETE] permission on the specified organization
   * Delete an application
   */
  async deleteApplicationRaw(
    requestParameters: DeleteApplicationRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteApplication.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteApplication.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteApplication.',
      );
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling deleteApplication.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have APPLICATION[DELETE] permission on the specified application or APPLICATION[DELETE] permission on the specified domain or APPLICATION[DELETE] permission on the specified environment or APPLICATION[DELETE] permission on the specified organization
   * Delete an application
   */
  async deleteApplication(
    requestParameters: DeleteApplicationRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.deleteApplicationRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_AUTHORIZATION_ENGINE[DELETE] permission on the specified domain or DOMAIN_AUTHORIZATION_ENGINE[DELETE] permission on the specified environment or DOMAIN_AUTHORIZATION_ENGINE[DELETE] permission on the specified organization
   * Delete an authorization engine
   */
  async deleteAuthorizationEngineRaw(
    requestParameters: DeleteAuthorizationEngineRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteAuthorizationEngine.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteAuthorizationEngine.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteAuthorizationEngine.',
      );
    }

    if (requestParameters.engineId === null || requestParameters.engineId === undefined) {
      throw new runtime.RequiredError(
        'engineId',
        'Required parameter requestParameters.engineId was null or undefined when calling deleteAuthorizationEngine.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/authorization-engines/{engineId}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'engineId'}}`, encodeURIComponent(String(requestParameters.engineId))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_AUTHORIZATION_ENGINE[DELETE] permission on the specified domain or DOMAIN_AUTHORIZATION_ENGINE[DELETE] permission on the specified environment or DOMAIN_AUTHORIZATION_ENGINE[DELETE] permission on the specified organization
   * Delete an authorization engine
   */
  async deleteAuthorizationEngine(
    requestParameters: DeleteAuthorizationEngineRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.deleteAuthorizationEngineRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_BOT_DETECTION[DELETE] permission on the specified domain or DOMAIN_BOT_DETECTION[DELETE] permission on the specified environment or DOMAIN_BOT_DETECTION[DELETE] permission on the specified organization
   * Delete a bot detection
   */
  async deleteBotDetectionRaw(
    requestParameters: DeleteBotDetectionRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteBotDetection.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteBotDetection.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteBotDetection.',
      );
    }

    if (requestParameters.botDetection === null || requestParameters.botDetection === undefined) {
      throw new runtime.RequiredError(
        'botDetection',
        'Required parameter requestParameters.botDetection was null or undefined when calling deleteBotDetection.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/bot-detections/{botDetection}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'botDetection'}}`, encodeURIComponent(String(requestParameters.botDetection))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_BOT_DETECTION[DELETE] permission on the specified domain or DOMAIN_BOT_DETECTION[DELETE] permission on the specified environment or DOMAIN_BOT_DETECTION[DELETE] permission on the specified organization
   * Delete a bot detection
   */
  async deleteBotDetection(
    requestParameters: DeleteBotDetectionRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.deleteBotDetectionRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_CERTIFICATE[DELETE] permission on the specified domain or DOMAIN_CERTIFICATE[DELETE] permission on the specified environment or DOMAIN_CERTIFICATE[DELETE] permission on the specified organization
   * Delete a certificate
   */
  async deleteCertificateRaw(
    requestParameters: DeleteCertificateRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteCertificate.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteCertificate.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteCertificate.',
      );
    }

    if (requestParameters.certificate === null || requestParameters.certificate === undefined) {
      throw new runtime.RequiredError(
        'certificate',
        'Required parameter requestParameters.certificate was null or undefined when calling deleteCertificate.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/certificates/{certificate}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'certificate'}}`, encodeURIComponent(String(requestParameters.certificate))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_CERTIFICATE[DELETE] permission on the specified domain or DOMAIN_CERTIFICATE[DELETE] permission on the specified environment or DOMAIN_CERTIFICATE[DELETE] permission on the specified organization
   * Delete a certificate
   */
  async deleteCertificate(
    requestParameters: DeleteCertificateRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.deleteCertificateRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_DEVICE_IDENTIFIER[DELETE] permission on the specified domain or DOMAIN_DEVICE_IDENTIFIER[DELETE] permission on the specified environment or DOMAIN_DEVICE_IDENTIFIER[DELETE] permission on the specified organization
   * Delete a Device identifier
   */
  async deleteDeviceIdentifierRaw(
    requestParameters: DeleteDeviceIdentifierRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteDeviceIdentifier.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteDeviceIdentifier.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteDeviceIdentifier.',
      );
    }

    if (requestParameters.deviceIdentifier === null || requestParameters.deviceIdentifier === undefined) {
      throw new runtime.RequiredError(
        'deviceIdentifier',
        'Required parameter requestParameters.deviceIdentifier was null or undefined when calling deleteDeviceIdentifier.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/device-identifiers/{deviceIdentifier}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'deviceIdentifier'}}`, encodeURIComponent(String(requestParameters.deviceIdentifier))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_DEVICE_IDENTIFIER[DELETE] permission on the specified domain or DOMAIN_DEVICE_IDENTIFIER[DELETE] permission on the specified environment or DOMAIN_DEVICE_IDENTIFIER[DELETE] permission on the specified organization
   * Delete a Device identifier
   */
  async deleteDeviceIdentifier(
    requestParameters: DeleteDeviceIdentifierRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.deleteDeviceIdentifierRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN[DELETE] permission on the specified domain or DOMAIN[DELETE] permission on the specified environment or DOMAIN[DELETE] permission on the specified organization.
   * Delete the security domain
   */
  async deleteDomainRaw(
    requestParameters: DeleteDomainRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteDomain.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteDomain.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteDomain.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN[DELETE] permission on the specified domain or DOMAIN[DELETE] permission on the specified environment or DOMAIN[DELETE] permission on the specified organization.
   * Delete the security domain
   */
  async deleteDomain(requestParameters: DeleteDomainRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.deleteDomainRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_EXTENSION_GRANT[DELETE] permission on the specified domain or DOMAIN_EXTENSION_GRANT[DELETE] permission on the specified environment or DOMAIN_EXTENSION_GRANT[DELETE] permission on the specified organization
   * Delete a extension grant
   */
  async deleteExtensionGrantRaw(
    requestParameters: DeleteExtensionGrantRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteExtensionGrant.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteExtensionGrant.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteExtensionGrant.',
      );
    }

    if (requestParameters.extensionGrant === null || requestParameters.extensionGrant === undefined) {
      throw new runtime.RequiredError(
        'extensionGrant',
        'Required parameter requestParameters.extensionGrant was null or undefined when calling deleteExtensionGrant.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/extensionGrants/{extensionGrant}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'extensionGrant'}}`, encodeURIComponent(String(requestParameters.extensionGrant))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_EXTENSION_GRANT[DELETE] permission on the specified domain or DOMAIN_EXTENSION_GRANT[DELETE] permission on the specified environment or DOMAIN_EXTENSION_GRANT[DELETE] permission on the specified organization
   * Delete a extension grant
   */
  async deleteExtensionGrant(
    requestParameters: DeleteExtensionGrantRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.deleteExtensionGrantRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_FACTOR[DELETE] permission on the specified domain or DOMAIN_FACTOR[DELETE] permission on the specified environment or DOMAIN_FACTOR[DELETE] permission on the specified organization
   * Delete a factor
   */
  async deleteFactorRaw(
    requestParameters: DeleteFactorRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteFactor.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteFactor.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteFactor.',
      );
    }

    if (requestParameters.factor === null || requestParameters.factor === undefined) {
      throw new runtime.RequiredError(
        'factor',
        'Required parameter requestParameters.factor was null or undefined when calling deleteFactor.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/factors/{factor}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'factor'}}`, encodeURIComponent(String(requestParameters.factor))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_FACTOR[DELETE] permission on the specified domain or DOMAIN_FACTOR[DELETE] permission on the specified environment or DOMAIN_FACTOR[DELETE] permission on the specified organization
   * Delete a factor
   */
  async deleteFactor(requestParameters: DeleteFactorRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.deleteFactorRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_GROUP[DELETE] permission on the specified domain or DOMAIN_GROUP[DELETE] permission on the specified environment or DOMAIN_GROUP[DELETE] permission on the specified organization
   * Delete a group
   */
  async deleteGroupRaw(
    requestParameters: DeleteGroupRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteGroup.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteGroup.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteGroup.',
      );
    }

    if (requestParameters.group === null || requestParameters.group === undefined) {
      throw new runtime.RequiredError(
        'group',
        'Required parameter requestParameters.group was null or undefined when calling deleteGroup.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/groups/{group}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'group'}}`, encodeURIComponent(String(requestParameters.group))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_GROUP[DELETE] permission on the specified domain or DOMAIN_GROUP[DELETE] permission on the specified environment or DOMAIN_GROUP[DELETE] permission on the specified organization
   * Delete a group
   */
  async deleteGroup(requestParameters: DeleteGroupRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.deleteGroupRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_I18N_DICTIONARY[DELETE] permission on the specified domain or DOMAIN_I18N_DICTIONARY[DELETE] permission on the specified environment or DOMAIN_I18N_DICTIONARY[DELETE] permission on the specified organization.
   * Delete a i18n dictionary
   */
  async deleteI18nDictionaryRaw(
    requestParameters: DeleteI18nDictionaryRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteI18nDictionary.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteI18nDictionary.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteI18nDictionary.',
      );
    }

    if (requestParameters.dictionary === null || requestParameters.dictionary === undefined) {
      throw new runtime.RequiredError(
        'dictionary',
        'Required parameter requestParameters.dictionary was null or undefined when calling deleteI18nDictionary.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/i18n/dictionaries/{dictionary}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'dictionary'}}`, encodeURIComponent(String(requestParameters.dictionary))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_I18N_DICTIONARY[DELETE] permission on the specified domain or DOMAIN_I18N_DICTIONARY[DELETE] permission on the specified environment or DOMAIN_I18N_DICTIONARY[DELETE] permission on the specified organization.
   * Delete a i18n dictionary
   */
  async deleteI18nDictionary(
    requestParameters: DeleteI18nDictionaryRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.deleteI18nDictionaryRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_IDENTITY_PROVIDER[DELETE] permission on the specified domain or DOMAIN_IDENTITY_PROVIDER[DELETE] permission on the specified environment or DOMAIN_IDENTITY_PROVIDER[DELETE] permission on the specified organization
   * Delete an identity provider
   */
  async deleteIdentityProviderRaw(
    requestParameters: DeleteIdentityProviderRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteIdentityProvider.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteIdentityProvider.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteIdentityProvider.',
      );
    }

    if (requestParameters.identity === null || requestParameters.identity === undefined) {
      throw new runtime.RequiredError(
        'identity',
        'Required parameter requestParameters.identity was null or undefined when calling deleteIdentityProvider.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/identities/{identity}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'identity'}}`, encodeURIComponent(String(requestParameters.identity))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_IDENTITY_PROVIDER[DELETE] permission on the specified domain or DOMAIN_IDENTITY_PROVIDER[DELETE] permission on the specified environment or DOMAIN_IDENTITY_PROVIDER[DELETE] permission on the specified organization
   * Delete an identity provider
   */
  async deleteIdentityProvider(
    requestParameters: DeleteIdentityProviderRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.deleteIdentityProviderRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_SETTINGS[UPDATE] permission on the specified domain or DOMAIN_SETTINGS[UPDATE] permission on the specified environment or DOMAIN_SETTINGS[UPDATE] permission on the specified organization
   * Delete a password policy
   */
  async deletePasswordPolicyRaw(
    requestParameters: DeletePasswordPolicyRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deletePasswordPolicy.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deletePasswordPolicy.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deletePasswordPolicy.',
      );
    }

    if (requestParameters.policy === null || requestParameters.policy === undefined) {
      throw new runtime.RequiredError(
        'policy',
        'Required parameter requestParameters.policy was null or undefined when calling deletePasswordPolicy.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/password-policies/{policy}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'policy'}}`, encodeURIComponent(String(requestParameters.policy))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_SETTINGS[UPDATE] permission on the specified domain or DOMAIN_SETTINGS[UPDATE] permission on the specified environment or DOMAIN_SETTINGS[UPDATE] permission on the specified organization
   * Delete a password policy
   */
  async deletePasswordPolicy(
    requestParameters: DeletePasswordPolicyRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.deletePasswordPolicyRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_RESOURCE[DELETE] permission on the specified domain or DOMAIN_RESOURCE[DELETE] permission on the specified environment or DOMAIN_RESOURCE[DELETE] permission on the specified organization
   * Delete a resource
   */
  async deleteResourceRaw(
    requestParameters: DeleteResourceRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteResource.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteResource.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteResource.',
      );
    }

    if (requestParameters.resource === null || requestParameters.resource === undefined) {
      throw new runtime.RequiredError(
        'resource',
        'Required parameter requestParameters.resource was null or undefined when calling deleteResource.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/resources/{resource}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'resource'}}`, encodeURIComponent(String(requestParameters.resource))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_RESOURCE[DELETE] permission on the specified domain or DOMAIN_RESOURCE[DELETE] permission on the specified environment or DOMAIN_RESOURCE[DELETE] permission on the specified organization
   * Delete a resource
   */
  async deleteResource(requestParameters: DeleteResourceRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.deleteResourceRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_ROLE[DELETE] permission on the specified domain or DOMAIN_ROLE[DELETE] permission on the specified environment or DOMAIN_ROLE[DELETE] permission on the specified organization
   * Delete a role
   */
  async deleteRoleRaw(
    requestParameters: DeleteRoleRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteRole.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteRole.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteRole.',
      );
    }

    if (requestParameters.role === null || requestParameters.role === undefined) {
      throw new runtime.RequiredError('role', 'Required parameter requestParameters.role was null or undefined when calling deleteRole.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/roles/{role}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'role'}}`, encodeURIComponent(String(requestParameters.role))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_ROLE[DELETE] permission on the specified domain or DOMAIN_ROLE[DELETE] permission on the specified environment or DOMAIN_ROLE[DELETE] permission on the specified organization
   * Delete a role
   */
  async deleteRole(requestParameters: DeleteRoleRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.deleteRoleRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_SCOPE[DELETE] permission on the specified domain or DOMAIN_SCOPE[DELETE] permission on the specified environment or DOMAIN_SCOPE[DELETE] permission on the specified organization
   * Delete a scope
   */
  async deleteScopeRaw(
    requestParameters: DeleteScopeRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteScope.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteScope.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteScope.',
      );
    }

    if (requestParameters.scope === null || requestParameters.scope === undefined) {
      throw new runtime.RequiredError(
        'scope',
        'Required parameter requestParameters.scope was null or undefined when calling deleteScope.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/scopes/{scope}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'scope'}}`, encodeURIComponent(String(requestParameters.scope))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_SCOPE[DELETE] permission on the specified domain or DOMAIN_SCOPE[DELETE] permission on the specified environment or DOMAIN_SCOPE[DELETE] permission on the specified organization
   * Delete a scope
   */
  async deleteScope(requestParameters: DeleteScopeRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.deleteScopeRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_THEME[DELETE] permission on the specified domain or DOMAIN_THEME[DELETE] permission on the specified environment or DOMAIN_THEME[DELETE] permission on the specified organization
   * Delete a theme on the specified security domain
   */
  async deleteThemeRaw(
    requestParameters: DeleteThemeRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteTheme.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteTheme.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteTheme.',
      );
    }

    if (requestParameters.themeId === null || requestParameters.themeId === undefined) {
      throw new runtime.RequiredError(
        'themeId',
        'Required parameter requestParameters.themeId was null or undefined when calling deleteTheme.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/themes/{themeId}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'themeId'}}`, encodeURIComponent(String(requestParameters.themeId))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_THEME[DELETE] permission on the specified domain or DOMAIN_THEME[DELETE] permission on the specified environment or DOMAIN_THEME[DELETE] permission on the specified organization
   * Delete a theme on the specified security domain
   */
  async deleteTheme(requestParameters: DeleteThemeRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.deleteThemeRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_USER[DELETE] permission on the specified domain or DOMAIN_USER[DELETE] permission on the specified environment or DOMAIN_USER[DELETE] permission on the specified organization
   * Delete a user
   */
  async deleteUserRaw(
    requestParameters: DeleteUserRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteUser.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteUser.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteUser.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError('user', 'Required parameter requestParameters.user was null or undefined when calling deleteUser.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_USER[DELETE] permission on the specified domain or DOMAIN_USER[DELETE] permission on the specified environment or DOMAIN_USER[DELETE] permission on the specified organization
   * Delete a user
   */
  async deleteUser(requestParameters: DeleteUserRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.deleteUserRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Revoke user factor
   */
  async deleteUserFactorRaw(
    requestParameters: DeleteUserFactorRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteUserFactor.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteUserFactor.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteUserFactor.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling deleteUserFactor.',
      );
    }

    if (requestParameters.factor === null || requestParameters.factor === undefined) {
      throw new runtime.RequiredError(
        'factor',
        'Required parameter requestParameters.factor was null or undefined when calling deleteUserFactor.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/factors/{factor}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user)))
          .replace(`{${'factor'}}`, encodeURIComponent(String(requestParameters.factor))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Revoke user factor
   */
  async deleteUserFactor(
    requestParameters: DeleteUserFactorRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.deleteUserFactorRaw(requestParameters, initOverrides);
  }

  /**
   */
  async evaluatePolicyRaw(
    requestParameters: EvaluatePolicyRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling evaluatePolicy.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling evaluatePolicy.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling evaluatePolicy.',
      );
    }

    if (requestParameters.policy === null || requestParameters.policy === undefined) {
      throw new runtime.RequiredError(
        'policy',
        'Required parameter requestParameters.policy was null or undefined when calling evaluatePolicy.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/password-policies/{policy}/evaluate`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'policy'}}`, encodeURIComponent(String(requestParameters.policy))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   */
  async evaluatePolicy(requestParameters: EvaluatePolicyRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.evaluatePolicyRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the APPLICATION[READ] permission on the specified application or APPLICATION[READ] permission on the specified domain or APPLICATION[READ] permission on the specified environment or APPLICATION[READ] permission on the specified organization. Application will be filtered according to permissions (READ on APPLICATION_IDENTITY_PROVIDER, APPLICATION_CERTIFICATE, APPLICATION_METADATA, APPLICATION_USER_ACCOUNT, APPLICATION_SETTINGS)
   * Get an application
   */
  async findApplicationRaw(
    requestParameters: FindApplicationRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Application>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling findApplication.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling findApplication.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling findApplication.',
      );
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling findApplication.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ApplicationFromJSON(jsonValue));
  }

  /**
   * User must have the APPLICATION[READ] permission on the specified application or APPLICATION[READ] permission on the specified domain or APPLICATION[READ] permission on the specified environment or APPLICATION[READ] permission on the specified organization. Application will be filtered according to permissions (READ on APPLICATION_IDENTITY_PROVIDER, APPLICATION_CERTIFICATE, APPLICATION_METADATA, APPLICATION_USER_ACCOUNT, APPLICATION_SETTINGS)
   * Get an application
   */
  async findApplication(
    requestParameters: FindApplicationRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Application> {
    const response = await this.findApplicationRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_AUTHORIZATION_ENGINE[READ] permission on the specified domain or DOMAIN_AUTHORIZATION_ENGINE[READ] permission on the specified environment or DOMAIN_AUTHORIZATION_ENGINE[READ] permission on the specified organization
   * Get an authorization engine
   */
  async findAuthorizationEngineRaw(
    requestParameters: FindAuthorizationEngineRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<AuthorizationEngine>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling findAuthorizationEngine.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling findAuthorizationEngine.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling findAuthorizationEngine.',
      );
    }

    if (requestParameters.engineId === null || requestParameters.engineId === undefined) {
      throw new runtime.RequiredError(
        'engineId',
        'Required parameter requestParameters.engineId was null or undefined when calling findAuthorizationEngine.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/authorization-engines/{engineId}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'engineId'}}`, encodeURIComponent(String(requestParameters.engineId))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => AuthorizationEngineFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_AUTHORIZATION_ENGINE[READ] permission on the specified domain or DOMAIN_AUTHORIZATION_ENGINE[READ] permission on the specified environment or DOMAIN_AUTHORIZATION_ENGINE[READ] permission on the specified organization
   * Get an authorization engine
   */
  async findAuthorizationEngine(
    requestParameters: FindAuthorizationEngineRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<AuthorizationEngine> {
    const response = await this.findAuthorizationEngineRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_CERTIFICATE[READ] permission on the specified domain or DOMAIN_CERTIFICATE[READ] permission on the specified environment or DOMAIN_CERTIFICATE[READ] permission on the specified organization
   * Get a certificate
   */
  async findCertificateRaw(
    requestParameters: FindCertificateRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<CertificateEntity>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling findCertificate.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling findCertificate.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling findCertificate.',
      );
    }

    if (requestParameters.certificate === null || requestParameters.certificate === undefined) {
      throw new runtime.RequiredError(
        'certificate',
        'Required parameter requestParameters.certificate was null or undefined when calling findCertificate.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/certificates/{certificate}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'certificate'}}`, encodeURIComponent(String(requestParameters.certificate))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => CertificateEntityFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_CERTIFICATE[READ] permission on the specified domain or DOMAIN_CERTIFICATE[READ] permission on the specified environment or DOMAIN_CERTIFICATE[READ] permission on the specified organization
   * Get a certificate
   */
  async findCertificate(
    requestParameters: FindCertificateRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<CertificateEntity> {
    const response = await this.findCertificateRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN[READ] permission on the specified domain, environment or organization. Domain will be filtered according to permissions (READ on DOMAIN_USER_ACCOUNT, DOMAIN_IDENTITY_PROVIDER, DOMAIN_FORM, DOMAIN_LOGIN_SETTINGS, DOMAIN_DCR, DOMAIN_SCIM, DOMAIN_SETTINGS)
   * Get a security domain
   */
  async findDomainRaw(
    requestParameters: FindDomainRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Domain>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling findDomain.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling findDomain.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling findDomain.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => DomainFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN[READ] permission on the specified domain, environment or organization. Domain will be filtered according to permissions (READ on DOMAIN_USER_ACCOUNT, DOMAIN_IDENTITY_PROVIDER, DOMAIN_FORM, DOMAIN_LOGIN_SETTINGS, DOMAIN_DCR, DOMAIN_SCIM, DOMAIN_SETTINGS)
   * Get a security domain
   */
  async findDomain(requestParameters: FindDomainRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Domain> {
    const response = await this.findDomainRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN[READ] permission on the specified domain, environment or organization. Domain will be filtered according to permissions (READ on DOMAIN_USER_ACCOUNT, DOMAIN_IDENTITY_PROVIDER, DOMAIN_FORM, DOMAIN_LOGIN_SETTINGS, DOMAIN_DCR, DOMAIN_SCIM, DOMAIN_SETTINGS)
   * Get a security domain by hrid
   */
  async findDomainByHridRaw(
    requestParameters: FindDomainByHridRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Domain>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling findDomainByHrid.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling findDomainByHrid.',
      );
    }

    if (requestParameters.hrid === null || requestParameters.hrid === undefined) {
      throw new runtime.RequiredError(
        'hrid',
        'Required parameter requestParameters.hrid was null or undefined when calling findDomainByHrid.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/_hrid/{hrid}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'hrid'}}`, encodeURIComponent(String(requestParameters.hrid))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => DomainFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN[READ] permission on the specified domain, environment or organization. Domain will be filtered according to permissions (READ on DOMAIN_USER_ACCOUNT, DOMAIN_IDENTITY_PROVIDER, DOMAIN_FORM, DOMAIN_LOGIN_SETTINGS, DOMAIN_DCR, DOMAIN_SCIM, DOMAIN_SETTINGS)
   * Get a security domain by hrid
   */
  async findDomainByHrid(
    requestParameters: FindDomainByHridRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Domain> {
    const response = await this.findDomainByHridRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_GROUP[READ] permission on the specified domain or DOMAIN_GROUP[READ] permission on the specified environment or DOMAIN_GROUP[READ] permission on the specified organization
   * Get a group
   */
  async findGroupRaw(
    requestParameters: FindGroupRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Group>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling findGroup.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling findGroup.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling findGroup.',
      );
    }

    if (requestParameters.group === null || requestParameters.group === undefined) {
      throw new runtime.RequiredError('group', 'Required parameter requestParameters.group was null or undefined when calling findGroup.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/groups/{group}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'group'}}`, encodeURIComponent(String(requestParameters.group))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => GroupFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_GROUP[READ] permission on the specified domain or DOMAIN_GROUP[READ] permission on the specified environment or DOMAIN_GROUP[READ] permission on the specified organization
   * Get a group
   */
  async findGroup(requestParameters: FindGroupRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Group> {
    const response = await this.findGroupRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_GROUP[READ] permission on the specified domain or DOMAIN_GROUP[READ] permission on the specified environment or DOMAIN_GROUP[READ] permission on the specified organization
   * Get a group roles
   */
  async findGroupRolesRaw(
    requestParameters: FindGroupRolesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<Role>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling findGroupRoles.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling findGroupRoles.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling findGroupRoles.',
      );
    }

    if (requestParameters.group === null || requestParameters.group === undefined) {
      throw new runtime.RequiredError(
        'group',
        'Required parameter requestParameters.group was null or undefined when calling findGroupRoles.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/groups/{group}/roles`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'group'}}`, encodeURIComponent(String(requestParameters.group))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(RoleFromJSON));
  }

  /**
   * User must have the DOMAIN_GROUP[READ] permission on the specified domain or DOMAIN_GROUP[READ] permission on the specified environment or DOMAIN_GROUP[READ] permission on the specified organization
   * Get a group roles
   */
  async findGroupRoles(
    requestParameters: FindGroupRolesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<Role>> {
    const response = await this.findGroupRolesRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_IDENTITY_PROVIDER[READ] permission on the specified domain or DOMAIN_IDENTITY_PROVIDER[READ] permission on the specified environment or DOMAIN_IDENTITY_PROVIDER[READ] permission on the specified organization
   * Get an identity provider
   */
  async findIdentityProviderRaw(
    requestParameters: FindIdentityProviderRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<IdentityProvider>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling findIdentityProvider.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling findIdentityProvider.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling findIdentityProvider.',
      );
    }

    if (requestParameters.identity === null || requestParameters.identity === undefined) {
      throw new runtime.RequiredError(
        'identity',
        'Required parameter requestParameters.identity was null or undefined when calling findIdentityProvider.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/identities/{identity}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'identity'}}`, encodeURIComponent(String(requestParameters.identity))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => IdentityProviderFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_IDENTITY_PROVIDER[READ] permission on the specified domain or DOMAIN_IDENTITY_PROVIDER[READ] permission on the specified environment or DOMAIN_IDENTITY_PROVIDER[READ] permission on the specified organization
   * Get an identity provider
   */
  async findIdentityProvider(
    requestParameters: FindIdentityProviderRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<IdentityProvider> {
    const response = await this.findIdentityProviderRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the PROTECTED_RESOURCE[READ] permission on the specified resource or PROTECTED_RESOURCE[READ] permission on the specified domain or PROTECTED_RESOURCE[READ] permission on the specified environment or PROTECTED_RESOURCE[READ] permission on the specified organization.
   * Get a Protected Resource
   */
  async findProtectedResourceRaw(
    requestParameters: FindProtectedResourceRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ProtectedResourcePrimaryData>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling findProtectedResource.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling findProtectedResource.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling findProtectedResource.',
      );
    }

    if (requestParameters.protectedResource === null || requestParameters.protectedResource === undefined) {
      throw new runtime.RequiredError(
        'protectedResource',
        'Required parameter requestParameters.protectedResource was null or undefined when calling findProtectedResource.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.type !== undefined) {
      queryParameters['type'] = requestParameters.type;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/protected-resources/{protected-resource}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'protected-resource'}}`, encodeURIComponent(String(requestParameters.protectedResource))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ProtectedResourcePrimaryDataFromJSON(jsonValue));
  }

  /**
   * User must have the PROTECTED_RESOURCE[READ] permission on the specified resource or PROTECTED_RESOURCE[READ] permission on the specified domain or PROTECTED_RESOURCE[READ] permission on the specified environment or PROTECTED_RESOURCE[READ] permission on the specified organization.
   * Get a Protected Resource
   */
  async findProtectedResource(
    requestParameters: FindProtectedResourceRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<ProtectedResourcePrimaryData> {
    const response = await this.findProtectedResourceRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_ROLE[READ] permission on the specified domain or DOMAIN_ROLE[READ] permission on the specified environment or DOMAIN_ROLE[READ] permission on the specified organization
   * Get a role
   */
  async findRoleRaw(
    requestParameters: FindRoleRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<RoleEntity>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling findRole.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling findRole.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling findRole.');
    }

    if (requestParameters.role === null || requestParameters.role === undefined) {
      throw new runtime.RequiredError('role', 'Required parameter requestParameters.role was null or undefined when calling findRole.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/roles/{role}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'role'}}`, encodeURIComponent(String(requestParameters.role))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => RoleEntityFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_ROLE[READ] permission on the specified domain or DOMAIN_ROLE[READ] permission on the specified environment or DOMAIN_ROLE[READ] permission on the specified organization
   * Get a role
   */
  async findRole(requestParameters: FindRoleRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<RoleEntity> {
    const response = await this.findRoleRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_ROLE[LIST] permission on the specified domain or DOMAIN_ROLE[LIST] permission on the specified environment or DOMAIN_ROLE[LIST] permission on the specified organization. Each returned role is filtered and contains only basic information such as id and name.
   * List registered roles for a security domain
   */
  async findRolesRaw(
    requestParameters: FindRolesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<RolePage>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling findRoles.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling findRoles.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling findRoles.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.page !== undefined) {
      queryParameters['page'] = requestParameters.page;
    }

    if (requestParameters.size !== undefined) {
      queryParameters['size'] = requestParameters.size;
    }

    if (requestParameters.q !== undefined) {
      queryParameters['q'] = requestParameters.q;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/roles`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => RolePageFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_ROLE[LIST] permission on the specified domain or DOMAIN_ROLE[LIST] permission on the specified environment or DOMAIN_ROLE[LIST] permission on the specified organization. Each returned role is filtered and contains only basic information such as id and name.
   * List registered roles for a security domain
   */
  async findRoles(requestParameters: FindRolesRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<RolePage> {
    const response = await this.findRolesRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_SCOPE[READ] permission on the specified domain or DOMAIN_SCOPE[READ] permission on the specified environment or DOMAIN_SCOPE[READ] permission on the specified organization
   * Get a scope
   */
  async findScopeRaw(
    requestParameters: FindScopeRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Scope>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling findScope.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling findScope.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling findScope.',
      );
    }

    if (requestParameters.scope === null || requestParameters.scope === undefined) {
      throw new runtime.RequiredError('scope', 'Required parameter requestParameters.scope was null or undefined when calling findScope.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/scopes/{scope}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'scope'}}`, encodeURIComponent(String(requestParameters.scope))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ScopeFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_SCOPE[READ] permission on the specified domain or DOMAIN_SCOPE[READ] permission on the specified environment or DOMAIN_SCOPE[READ] permission on the specified organization
   * Get a scope
   */
  async findScope(requestParameters: FindScopeRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Scope> {
    const response = await this.findScopeRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user
   */
  async findUserRaw(
    requestParameters: FindUserRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<UserEntity>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling findUser.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling findUser.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling findUser.');
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError('user', 'Required parameter requestParameters.user was null or undefined when calling findUser.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => UserEntityFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user
   */
  async findUser(requestParameters: FindUserRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<UserEntity> {
    const response = await this.findUserRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_AUTHDEVICE_NOTIFIER[READ] permission on the specified domain or DOMAIN_AUTHDEVICE_NOTIFIER[READ] permission on the specified environment or DOMAIN_AUTHDEVICE_NOTIFIER[READ] permission on the specified organization
   * Get an Authentication Device Notifier
   */
  async get10Raw(
    requestParameters: Get10Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<AuthenticationDeviceNotifier>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling get10.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling get10.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling get10.');
    }

    if (requestParameters.authDeviceNotifier === null || requestParameters.authDeviceNotifier === undefined) {
      throw new runtime.RequiredError(
        'authDeviceNotifier',
        'Required parameter requestParameters.authDeviceNotifier was null or undefined when calling get10.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/auth-device-notifiers/{authDeviceNotifier}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'authDeviceNotifier'}}`, encodeURIComponent(String(requestParameters.authDeviceNotifier))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => AuthenticationDeviceNotifierFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_AUTHDEVICE_NOTIFIER[READ] permission on the specified domain or DOMAIN_AUTHDEVICE_NOTIFIER[READ] permission on the specified environment or DOMAIN_AUTHDEVICE_NOTIFIER[READ] permission on the specified organization
   * Get an Authentication Device Notifier
   */
  async get10(
    requestParameters: Get10Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<AuthenticationDeviceNotifier> {
    const response = await this.get10Raw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_EMAIL_TEMPLATE[READ] permission on the specified domain or DOMAIN_EMAIL_TEMPLATE[READ] permission on the specified environment or DOMAIN_EMAIL_TEMPLATE[READ] permission on the specified organization
   * Find a email
   */
  async get11Raw(
    requestParameters: Get11Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling get11.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling get11.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling get11.');
    }

    if (requestParameters.template === null || requestParameters.template === undefined) {
      throw new runtime.RequiredError(
        'template',
        'Required parameter requestParameters.template was null or undefined when calling get11.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.template !== undefined) {
      queryParameters['template'] = requestParameters.template;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/emails`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_EMAIL_TEMPLATE[READ] permission on the specified domain or DOMAIN_EMAIL_TEMPLATE[READ] permission on the specified environment or DOMAIN_EMAIL_TEMPLATE[READ] permission on the specified organization
   * Find a email
   */
  async get11(requestParameters: Get11Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.get11Raw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_FORM[READ] permission on the specified domain or DOMAIN_FORM[READ] permission on the specified environment or DOMAIN_FORM[READ] permission on the specified organization
   * Find a form
   */
  async get12Raw(
    requestParameters: Get12Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling get12.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling get12.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling get12.');
    }

    if (requestParameters.template === null || requestParameters.template === undefined) {
      throw new runtime.RequiredError(
        'template',
        'Required parameter requestParameters.template was null or undefined when calling get12.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.template !== undefined) {
      queryParameters['template'] = requestParameters.template;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/forms`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_FORM[READ] permission on the specified domain or DOMAIN_FORM[READ] permission on the specified environment or DOMAIN_FORM[READ] permission on the specified organization
   * Find a form
   */
  async get12(requestParameters: Get12Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.get12Raw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_REPORTER[READ] permission on the specified domain or DOMAIN_REPORTER[READ] permission on the specified environment or DOMAIN_REPORTER[READ] permission on the specified organization
   * Get a reporter
   */
  async get13Raw(
    requestParameters: Get13Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Reporter>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling get13.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling get13.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling get13.');
    }

    if (requestParameters.reporter === null || requestParameters.reporter === undefined) {
      throw new runtime.RequiredError(
        'reporter',
        'Required parameter requestParameters.reporter was null or undefined when calling get13.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/reporters/{reporter}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'reporter'}}`, encodeURIComponent(String(requestParameters.reporter))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ReporterFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_REPORTER[READ] permission on the specified domain or DOMAIN_REPORTER[READ] permission on the specified environment or DOMAIN_REPORTER[READ] permission on the specified organization
   * Get a reporter
   */
  async get13(requestParameters: Get13Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Reporter> {
    const response = await this.get13Raw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user audit log
   */
  async get14Raw(
    requestParameters: Get14Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Audit>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling get14.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling get14.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling get14.');
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError('user', 'Required parameter requestParameters.user was null or undefined when calling get14.');
    }

    if (requestParameters.audit === null || requestParameters.audit === undefined) {
      throw new runtime.RequiredError('audit', 'Required parameter requestParameters.audit was null or undefined when calling get14.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/audits/{audit}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user)))
          .replace(`{${'audit'}}`, encodeURIComponent(String(requestParameters.audit))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => AuditFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user audit log
   */
  async get14(requestParameters: Get14Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Audit> {
    const response = await this.get14Raw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user consent
   */
  async get15Raw(
    requestParameters: Get15Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ScopeApprovalEntity>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling get15.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling get15.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling get15.');
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError('user', 'Required parameter requestParameters.user was null or undefined when calling get15.');
    }

    if (requestParameters.consent === null || requestParameters.consent === undefined) {
      throw new runtime.RequiredError('consent', 'Required parameter requestParameters.consent was null or undefined when calling get15.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/consents/{consent}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user)))
          .replace(`{${'consent'}}`, encodeURIComponent(String(requestParameters.consent))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ScopeApprovalEntityFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user consent
   */
  async get15(requestParameters: Get15Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<ScopeApprovalEntity> {
    const response = await this.get15Raw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user credential
   */
  async get16Raw(
    requestParameters: Get16Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Credential>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling get16.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling get16.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling get16.');
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError('user', 'Required parameter requestParameters.user was null or undefined when calling get16.');
    }

    if (requestParameters.credential === null || requestParameters.credential === undefined) {
      throw new runtime.RequiredError(
        'credential',
        'Required parameter requestParameters.credential was null or undefined when calling get16.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/credentials/{credential}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user)))
          .replace(`{${'credential'}}`, encodeURIComponent(String(requestParameters.credential))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => CredentialFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user credential
   */
  async get16(requestParameters: Get16Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Credential> {
    const response = await this.get16Raw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have DOMAIN_ANALYTICS[READ] permission on the specified domain or DOMAIN_ANALYTICS[READ] permission on the specified environment or DOMAIN_ANALYTICS[READ] permission on the specified organization
   * Find domain analytics
   */
  async get3Raw(
    requestParameters: Get3Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling get3.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling get3.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling get3.');
    }

    if (requestParameters.type === null || requestParameters.type === undefined) {
      throw new runtime.RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling get3.');
    }

    const queryParameters: any = {};

    if (requestParameters.from !== undefined) {
      queryParameters['from'] = requestParameters.from;
    }

    if (requestParameters.to !== undefined) {
      queryParameters['to'] = requestParameters.to;
    }

    if (requestParameters.interval !== undefined) {
      queryParameters['interval'] = requestParameters.interval;
    }

    if (requestParameters.size !== undefined) {
      queryParameters['size'] = requestParameters.size;
    }

    if (requestParameters.type !== undefined) {
      queryParameters['type'] = requestParameters.type;
    }

    if (requestParameters.field !== undefined) {
      queryParameters['field'] = requestParameters.field;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/analytics`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have DOMAIN_ANALYTICS[READ] permission on the specified domain or DOMAIN_ANALYTICS[READ] permission on the specified environment or DOMAIN_ANALYTICS[READ] permission on the specified organization
   * Find domain analytics
   */
  async get3(requestParameters: Get3Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.get3Raw(requestParameters, initOverrides);
  }

  /**
   * User must have APPLICATION_ANALYTICS[READ] permission on the specified application or APPLICATION_ANALYTICS[READ] permission on the specified domain or APPLICATION_ANALYTICS[READ] permission on the specified environment or APPLICATION_ANALYTICS[READ] permission on the specified organization
   * Find application analytics
   */
  async get4Raw(
    requestParameters: Get4Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling get4.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling get4.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling get4.');
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling get4.',
      );
    }

    if (requestParameters.type === null || requestParameters.type === undefined) {
      throw new runtime.RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling get4.');
    }

    const queryParameters: any = {};

    if (requestParameters.from !== undefined) {
      queryParameters['from'] = requestParameters.from;
    }

    if (requestParameters.to !== undefined) {
      queryParameters['to'] = requestParameters.to;
    }

    if (requestParameters.interval !== undefined) {
      queryParameters['interval'] = requestParameters.interval;
    }

    if (requestParameters.size !== undefined) {
      queryParameters['size'] = requestParameters.size;
    }

    if (requestParameters.type !== undefined) {
      queryParameters['type'] = requestParameters.type;
    }

    if (requestParameters.field !== undefined) {
      queryParameters['field'] = requestParameters.field;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/analytics`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have APPLICATION_ANALYTICS[READ] permission on the specified application or APPLICATION_ANALYTICS[READ] permission on the specified domain or APPLICATION_ANALYTICS[READ] permission on the specified environment or APPLICATION_ANALYTICS[READ] permission on the specified organization
   * Find application analytics
   */
  async get4(requestParameters: Get4Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.get4Raw(requestParameters, initOverrides);
  }

  /**
   * User must have APPLICATION_EMAIL_TEMPLATE[READ] permission on the specified application or APPLICATION_EMAIL_TEMPLATE[READ] permission on the specified domain or APPLICATION_EMAIL_TEMPLATE[READ] permission on the specified environment or APPLICATION_EMAIL_TEMPLATE[READ] permission on the specified organization
   * Find a email for an application
   */
  async get5Raw(
    requestParameters: Get5Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling get5.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling get5.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling get5.');
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling get5.',
      );
    }

    if (requestParameters.template === null || requestParameters.template === undefined) {
      throw new runtime.RequiredError('template', 'Required parameter requestParameters.template was null or undefined when calling get5.');
    }

    const queryParameters: any = {};

    if (requestParameters.template !== undefined) {
      queryParameters['template'] = requestParameters.template;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/emails`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have APPLICATION_EMAIL_TEMPLATE[READ] permission on the specified application or APPLICATION_EMAIL_TEMPLATE[READ] permission on the specified domain or APPLICATION_EMAIL_TEMPLATE[READ] permission on the specified environment or APPLICATION_EMAIL_TEMPLATE[READ] permission on the specified organization
   * Find a email for an application
   */
  async get5(requestParameters: Get5Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.get5Raw(requestParameters, initOverrides);
  }

  /**
   * User must have APPLICATION_FORM[READ] permission on the specified application or APPLICATION_FORM[READ] permission on the specified domain or APPLICATION_FORM[READ] permission on the specified environment or APPLICATION_FORM[READ] permission on the specified organization
   * Find a form for an application
   */
  async get6Raw(
    requestParameters: Get6Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling get6.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling get6.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling get6.');
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling get6.',
      );
    }

    if (requestParameters.template === null || requestParameters.template === undefined) {
      throw new runtime.RequiredError('template', 'Required parameter requestParameters.template was null or undefined when calling get6.');
    }

    const queryParameters: any = {};

    if (requestParameters.template !== undefined) {
      queryParameters['template'] = requestParameters.template;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/forms`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have APPLICATION_FORM[READ] permission on the specified application or APPLICATION_FORM[READ] permission on the specified domain or APPLICATION_FORM[READ] permission on the specified environment or APPLICATION_FORM[READ] permission on the specified organization
   * Find a form for an application
   */
  async get6(requestParameters: Get6Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.get6Raw(requestParameters, initOverrides);
  }

  /**
   * User must have APPLICATION_RESOURCE[READ] permission on the specified application or APPLICATION_RESOURCE[READ] permission on the specified domain or APPLICATION_RESOURCE[READ] permission on the specified environment or APPLICATION_RESOURCE[READ] permission on the specified organization
   * Get a resource for an application
   */
  async get7Raw(
    requestParameters: Get7Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Resource>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling get7.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling get7.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling get7.');
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling get7.',
      );
    }

    if (requestParameters.resource === null || requestParameters.resource === undefined) {
      throw new runtime.RequiredError('resource', 'Required parameter requestParameters.resource was null or undefined when calling get7.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/resources/{resource}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application)))
          .replace(`{${'resource'}}`, encodeURIComponent(String(requestParameters.resource))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ResourceFromJSON(jsonValue));
  }

  /**
   * User must have APPLICATION_RESOURCE[READ] permission on the specified application or APPLICATION_RESOURCE[READ] permission on the specified domain or APPLICATION_RESOURCE[READ] permission on the specified environment or APPLICATION_RESOURCE[READ] permission on the specified organization
   * Get a resource for an application
   */
  async get7(requestParameters: Get7Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Resource> {
    const response = await this.get7Raw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have APPLICATION_RESOURCE[READ] permission on the specified application or APPLICATION_RESOURCE[READ] permission on the specified domain or APPLICATION_RESOURCE[READ] permission on the specified environment or APPLICATION_RESOURCE[READ] permission on the specified organization
   * Get resource access policy
   */
  async get8Raw(
    requestParameters: Get8Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<AccessPolicy>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling get8.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling get8.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling get8.');
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling get8.',
      );
    }

    if (requestParameters.resource === null || requestParameters.resource === undefined) {
      throw new runtime.RequiredError('resource', 'Required parameter requestParameters.resource was null or undefined when calling get8.');
    }

    if (requestParameters.policy === null || requestParameters.policy === undefined) {
      throw new runtime.RequiredError('policy', 'Required parameter requestParameters.policy was null or undefined when calling get8.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/resources/{resource}/policies/{policy}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application)))
          .replace(`{${'resource'}}`, encodeURIComponent(String(requestParameters.resource)))
          .replace(`{${'policy'}}`, encodeURIComponent(String(requestParameters.policy))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => AccessPolicyFromJSON(jsonValue));
  }

  /**
   * User must have APPLICATION_RESOURCE[READ] permission on the specified application or APPLICATION_RESOURCE[READ] permission on the specified domain or APPLICATION_RESOURCE[READ] permission on the specified environment or APPLICATION_RESOURCE[READ] permission on the specified organization
   * Get resource access policy
   */
  async get8(requestParameters: Get8Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<AccessPolicy> {
    const response = await this.get8Raw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_AUDIT[READ] permission on the specified domain or DOMAIN_AUDIT[READ] permission on the specified environment or DOMAIN_AUDIT[READ] permission on the specified organization
   * Get an audit log
   */
  async get9Raw(
    requestParameters: Get9Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Audit>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling get9.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling get9.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling get9.');
    }

    if (requestParameters.audit === null || requestParameters.audit === undefined) {
      throw new runtime.RequiredError('audit', 'Required parameter requestParameters.audit was null or undefined when calling get9.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/audits/{audit}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'audit'}}`, encodeURIComponent(String(requestParameters.audit))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => AuditFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_AUDIT[READ] permission on the specified domain or DOMAIN_AUDIT[READ] permission on the specified environment or DOMAIN_AUDIT[READ] permission on the specified organization
   * Get an audit log
   */
  async get9(requestParameters: Get9Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Audit> {
    const response = await this.get9Raw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Get an alert notifier by its id. User must have DOMAIN_ALERT_NOTIFIER[LIST] permission on the specified domain, environment or organization.
   * Get an alert notifier
   */
  async getAlertNotifierRaw(
    requestParameters: GetAlertNotifierRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<AlertNotifier>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getAlertNotifier.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getAlertNotifier.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getAlertNotifier.',
      );
    }

    if (requestParameters.notifierId === null || requestParameters.notifierId === undefined) {
      throw new runtime.RequiredError(
        'notifierId',
        'Required parameter requestParameters.notifierId was null or undefined when calling getAlertNotifier.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/alerts/notifiers/{notifierId}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'notifierId'}}`, encodeURIComponent(String(requestParameters.notifierId))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => AlertNotifierFromJSON(jsonValue));
  }

  /**
   * Get an alert notifier by its id. User must have DOMAIN_ALERT_NOTIFIER[LIST] permission on the specified domain, environment or organization.
   * Get an alert notifier
   */
  async getAlertNotifier(
    requestParameters: GetAlertNotifierRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<AlertNotifier> {
    const response = await this.getAlertNotifierRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the APPLICATION_FLOW[READ] permission on the specified domain or APPLICATION_FLOW[READ] permission on the specified environment or APPLICATION_FLOW[READ] permission on the specified organization
   * Get a flow
   */
  async getAppFlowRaw(
    requestParameters: GetAppFlowRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<FlowEntity>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getAppFlow.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getAppFlow.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getAppFlow.',
      );
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling getAppFlow.',
      );
    }

    if (requestParameters.flow === null || requestParameters.flow === undefined) {
      throw new runtime.RequiredError('flow', 'Required parameter requestParameters.flow was null or undefined when calling getAppFlow.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/flows/{flow}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application)))
          .replace(`{${'flow'}}`, encodeURIComponent(String(requestParameters.flow))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => FlowEntityFromJSON(jsonValue));
  }

  /**
   * User must have the APPLICATION_FLOW[READ] permission on the specified domain or APPLICATION_FLOW[READ] permission on the specified environment or APPLICATION_FLOW[READ] permission on the specified organization
   * Get a flow
   */
  async getAppFlow(requestParameters: GetAppFlowRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<FlowEntity> {
    const response = await this.getAppFlowRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_BOT_DETECTION[READ] permission on the specified domain or DOMAIN_BOT_DETECTION[READ] permission on the specified environment or DOMAIN_BOT_DETECTION[READ] permission on the specified organization
   * Get a bot detection
   */
  async getBotDetectionRaw(
    requestParameters: GetBotDetectionRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<BotDetection>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getBotDetection.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getBotDetection.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getBotDetection.',
      );
    }

    if (requestParameters.botDetection === null || requestParameters.botDetection === undefined) {
      throw new runtime.RequiredError(
        'botDetection',
        'Required parameter requestParameters.botDetection was null or undefined when calling getBotDetection.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/bot-detections/{botDetection}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'botDetection'}}`, encodeURIComponent(String(requestParameters.botDetection))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => BotDetectionFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_BOT_DETECTION[READ] permission on the specified domain or DOMAIN_BOT_DETECTION[READ] permission on the specified environment or DOMAIN_BOT_DETECTION[READ] permission on the specified organization
   * Get a bot detection
   */
  async getBotDetection(
    requestParameters: GetBotDetectionRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<BotDetection> {
    const response = await this.getBotDetectionRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN[READ] permission on the specified domain or DOMAIN[READ] permission on the specified environment or DOMAIN[READ] permission on the specified organization
   * Get the certificate public key
   */
  async getCertificatePublicKeyRaw(
    requestParameters: GetCertificatePublicKeyRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getCertificatePublicKey.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getCertificatePublicKey.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getCertificatePublicKey.',
      );
    }

    if (requestParameters.certificate === null || requestParameters.certificate === undefined) {
      throw new runtime.RequiredError(
        'certificate',
        'Required parameter requestParameters.certificate was null or undefined when calling getCertificatePublicKey.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/certificates/{certificate}/key`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'certificate'}}`, encodeURIComponent(String(requestParameters.certificate))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.TextApiResponse(response) as any;
  }

  /**
   * User must have the DOMAIN[READ] permission on the specified domain or DOMAIN[READ] permission on the specified environment or DOMAIN[READ] permission on the specified organization
   * Get the certificate public key
   */
  async getCertificatePublicKey(
    requestParameters: GetCertificatePublicKeyRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<string> {
    const response = await this.getCertificatePublicKeyRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN[READ] permission on the specified domain or DOMAIN[READ] permission on the specified environment or DOMAIN[READ] permission on the specified organization
   * Get the certificate public keys
   */
  async getCertificatePublicKeysRaw(
    requestParameters: GetCertificatePublicKeysRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<CertificateKey>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getCertificatePublicKeys.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getCertificatePublicKeys.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getCertificatePublicKeys.',
      );
    }

    if (requestParameters.certificate === null || requestParameters.certificate === undefined) {
      throw new runtime.RequiredError(
        'certificate',
        'Required parameter requestParameters.certificate was null or undefined when calling getCertificatePublicKeys.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/certificates/{certificate}/keys`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'certificate'}}`, encodeURIComponent(String(requestParameters.certificate))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CertificateKeyFromJSON));
  }

  /**
   * User must have the DOMAIN[READ] permission on the specified domain or DOMAIN[READ] permission on the specified environment or DOMAIN[READ] permission on the specified organization
   * Get the certificate public keys
   */
  async getCertificatePublicKeys(
    requestParameters: GetCertificatePublicKeysRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<CertificateKey>> {
    const response = await this.getCertificatePublicKeysRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_DEVICE_IDENTIFIER[READ] permission on the specified domain or DOMAIN_DEVICE_IDENTIFIER[READ] permission on the specified environment or DOMAIN_DEVICE_IDENTIFIER[READ] permission on the specified organization
   * Get a Device identifier
   */
  async getDeviceIdentifierRaw(
    requestParameters: GetDeviceIdentifierRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<DeviceIdentifier>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getDeviceIdentifier.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getDeviceIdentifier.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getDeviceIdentifier.',
      );
    }

    if (requestParameters.deviceIdentifier === null || requestParameters.deviceIdentifier === undefined) {
      throw new runtime.RequiredError(
        'deviceIdentifier',
        'Required parameter requestParameters.deviceIdentifier was null or undefined when calling getDeviceIdentifier.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/device-identifiers/{deviceIdentifier}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'deviceIdentifier'}}`, encodeURIComponent(String(requestParameters.deviceIdentifier))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => DeviceIdentifierFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_DEVICE_IDENTIFIER[READ] permission on the specified domain or DOMAIN_DEVICE_IDENTIFIER[READ] permission on the specified environment or DOMAIN_DEVICE_IDENTIFIER[READ] permission on the specified organization
   * Get a Device identifier
   */
  async getDeviceIdentifier(
    requestParameters: GetDeviceIdentifierRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<DeviceIdentifier> {
    const response = await this.getDeviceIdentifierRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN[READ] permission on the specified domain, environment or organization. Domain will be filtered according to permissions (READ on DOMAIN_USER_ACCOUNT, DOMAIN_IDENTITY_PROVIDER, DOMAIN_FORM, DOMAIN_LOGIN_SETTINGS, DOMAIN_DCR, DOMAIN_SCIM, DOMAIN_SETTINGS)
   * Get the matching gateway entrypoint of the domain
   */
  async getDomainEntrypointsRaw(
    requestParameters: GetDomainEntrypointsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<Entrypoint>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getDomainEntrypoints.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getDomainEntrypoints.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getDomainEntrypoints.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/entrypoints`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(EntrypointFromJSON));
  }

  /**
   * User must have the DOMAIN[READ] permission on the specified domain, environment or organization. Domain will be filtered according to permissions (READ on DOMAIN_USER_ACCOUNT, DOMAIN_IDENTITY_PROVIDER, DOMAIN_FORM, DOMAIN_LOGIN_SETTINGS, DOMAIN_DCR, DOMAIN_SCIM, DOMAIN_SETTINGS)
   * Get the matching gateway entrypoint of the domain
   */
  async getDomainEntrypoints(
    requestParameters: GetDomainEntrypointsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<Entrypoint>> {
    const response = await this.getDomainEntrypointsRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_FLOW[READ] permission on the specified domain or DOMAIN_FLOW[READ] permission on the specified environment or DOMAIN_FLOW[READ] permission on the specified organization
   * Get a flow
   */
  async getDomainFlowRaw(
    requestParameters: GetDomainFlowRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<FlowEntity>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getDomainFlow.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getDomainFlow.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getDomainFlow.',
      );
    }

    if (requestParameters.flow === null || requestParameters.flow === undefined) {
      throw new runtime.RequiredError(
        'flow',
        'Required parameter requestParameters.flow was null or undefined when calling getDomainFlow.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/flows/{flow}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'flow'}}`, encodeURIComponent(String(requestParameters.flow))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => FlowEntityFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_FLOW[READ] permission on the specified domain or DOMAIN_FLOW[READ] permission on the specified environment or DOMAIN_FLOW[READ] permission on the specified organization
   * Get a flow
   */
  async getDomainFlow(
    requestParameters: GetDomainFlowRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<FlowEntity> {
    const response = await this.getDomainFlowRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   */
  async getEffectivePasswordPolicyRaw(
    requestParameters: GetEffectivePasswordPolicyRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getEffectivePasswordPolicy.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getEffectivePasswordPolicy.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getEffectivePasswordPolicy.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.identity !== undefined) {
      queryParameters['identity'] = requestParameters.identity;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/password-policies/activePolicy`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   */
  async getEffectivePasswordPolicy(
    requestParameters: GetEffectivePasswordPolicyRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.getEffectivePasswordPolicyRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_EXTENSION_GRANT[READ] permission on the specified domain or DOMAIN_EXTENSION_GRANT[READ] permission on the specified environment or DOMAIN_EXTENSION_GRANT[READ] permission on the specified organization
   * Get a extension grant
   */
  async getExtensionGrantRaw(
    requestParameters: GetExtensionGrantRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ExtensionGrant>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getExtensionGrant.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getExtensionGrant.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getExtensionGrant.',
      );
    }

    if (requestParameters.extensionGrant === null || requestParameters.extensionGrant === undefined) {
      throw new runtime.RequiredError(
        'extensionGrant',
        'Required parameter requestParameters.extensionGrant was null or undefined when calling getExtensionGrant.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/extensionGrants/{extensionGrant}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'extensionGrant'}}`, encodeURIComponent(String(requestParameters.extensionGrant))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ExtensionGrantFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_EXTENSION_GRANT[READ] permission on the specified domain or DOMAIN_EXTENSION_GRANT[READ] permission on the specified environment or DOMAIN_EXTENSION_GRANT[READ] permission on the specified organization
   * Get a extension grant
   */
  async getExtensionGrant(
    requestParameters: GetExtensionGrantRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<ExtensionGrant> {
    const response = await this.getExtensionGrantRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_FACTOR[READ] permission on the specified domain or DOMAIN_FACTOR[READ] permission on the specified environment or DOMAIN_FACTOR[READ] permission on the specified organization
   * Get a factor
   */
  async getFactorRaw(
    requestParameters: GetFactorRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Factor>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getFactor.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getFactor.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getFactor.',
      );
    }

    if (requestParameters.factor === null || requestParameters.factor === undefined) {
      throw new runtime.RequiredError(
        'factor',
        'Required parameter requestParameters.factor was null or undefined when calling getFactor.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/factors/{factor}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'factor'}}`, encodeURIComponent(String(requestParameters.factor))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => FactorFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_FACTOR[READ] permission on the specified domain or DOMAIN_FACTOR[READ] permission on the specified environment or DOMAIN_FACTOR[READ] permission on the specified organization
   * Get a factor
   */
  async getFactor(requestParameters: GetFactorRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Factor> {
    const response = await this.getFactorRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_GROUP[READ] permission on the specified domain or DOMAIN_GROUP[READ] permission on the specified environment or DOMAIN_GROUP[READ] permission on the specified organization
   * List group members
   */
  async getGroupMembersRaw(
    requestParameters: GetGroupMembersRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<User>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getGroupMembers.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getGroupMembers.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getGroupMembers.',
      );
    }

    if (requestParameters.group === null || requestParameters.group === undefined) {
      throw new runtime.RequiredError(
        'group',
        'Required parameter requestParameters.group was null or undefined when calling getGroupMembers.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.page !== undefined) {
      queryParameters['page'] = requestParameters.page;
    }

    if (requestParameters.size !== undefined) {
      queryParameters['size'] = requestParameters.size;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/groups/{group}/members`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'group'}}`, encodeURIComponent(String(requestParameters.group))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_GROUP[READ] permission on the specified domain or DOMAIN_GROUP[READ] permission on the specified environment or DOMAIN_GROUP[READ] permission on the specified organization
   * List group members
   */
  async getGroupMembers(
    requestParameters: GetGroupMembersRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<User> {
    const response = await this.getGroupMembersRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_I18N_DICTIONARY[READ] permission on the specified domain or DOMAIN_I18N_DICTIONARY[READ] permission on the specified environment or DOMAIN_I18N_DICTIONARY[READ] permission on the specified organization.
   * Get a i18n dictionary
   */
  async getI18nDictionaryRaw(
    requestParameters: GetI18nDictionaryRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<I18nDictionary>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getI18nDictionary.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getI18nDictionary.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getI18nDictionary.',
      );
    }

    if (requestParameters.dictionary === null || requestParameters.dictionary === undefined) {
      throw new runtime.RequiredError(
        'dictionary',
        'Required parameter requestParameters.dictionary was null or undefined when calling getI18nDictionary.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/i18n/dictionaries/{dictionary}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'dictionary'}}`, encodeURIComponent(String(requestParameters.dictionary))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => I18nDictionaryFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_I18N_DICTIONARY[READ] permission on the specified domain or DOMAIN_I18N_DICTIONARY[READ] permission on the specified environment or DOMAIN_I18N_DICTIONARY[READ] permission on the specified organization.
   * Get a i18n dictionary
   */
  async getI18nDictionary(
    requestParameters: GetI18nDictionaryRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<I18nDictionary> {
    const response = await this.getI18nDictionaryRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have APPLICATION_MEMBER[LIST] permission on the specified application or APPLICATION_MEMBER[LIST] permission on the specified domain or APPLICATION_MEMBER[LIST] permission on the specified environment or APPLICATION_MEMBER[LIST] permission on the specified organization
   * List members for an application
   */
  async getMembersRaw(
    requestParameters: GetMembersRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<MembershipListItem>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getMembers.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getMembers.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getMembers.',
      );
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling getMembers.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/members`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => MembershipListItemFromJSON(jsonValue));
  }

  /**
   * User must have APPLICATION_MEMBER[LIST] permission on the specified application or APPLICATION_MEMBER[LIST] permission on the specified domain or APPLICATION_MEMBER[LIST] permission on the specified environment or APPLICATION_MEMBER[LIST] permission on the specified organization
   * List members for an application
   */
  async getMembers(
    requestParameters: GetMembersRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<MembershipListItem> {
    const response = await this.getMembersRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_SETTINGS[READ] permission on the specified domain or DOMAIN_SETTINGS[READ] permission on the specified environment or DOMAIN_SETTINGS[READ] permission on the specified organization
   * Read a password policy
   */
  async getPasswordPolicyRaw(
    requestParameters: GetPasswordPolicyRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<PasswordPolicy>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getPasswordPolicy.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getPasswordPolicy.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getPasswordPolicy.',
      );
    }

    if (requestParameters.policy === null || requestParameters.policy === undefined) {
      throw new runtime.RequiredError(
        'policy',
        'Required parameter requestParameters.policy was null or undefined when calling getPasswordPolicy.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/password-policies/{policy}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'policy'}}`, encodeURIComponent(String(requestParameters.policy))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => PasswordPolicyFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_SETTINGS[READ] permission on the specified domain or DOMAIN_SETTINGS[READ] permission on the specified environment or DOMAIN_SETTINGS[READ] permission on the specified organization
   * Read a password policy
   */
  async getPasswordPolicy(
    requestParameters: GetPasswordPolicyRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<PasswordPolicy> {
    const response = await this.getPasswordPolicyRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_RESOURCE[READ] permission on the specified domain or DOMAIN_RESOURCE[READ] permission on the specified environment or DOMAIN_RESOURCE[READ] permission on the specified organization
   * Get a resource
   */
  async getResourceRaw(
    requestParameters: GetResourceRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ServiceResource>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getResource.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getResource.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getResource.',
      );
    }

    if (requestParameters.resource === null || requestParameters.resource === undefined) {
      throw new runtime.RequiredError(
        'resource',
        'Required parameter requestParameters.resource was null or undefined when calling getResource.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/resources/{resource}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'resource'}}`, encodeURIComponent(String(requestParameters.resource))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ServiceResourceFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_RESOURCE[READ] permission on the specified domain or DOMAIN_RESOURCE[READ] permission on the specified environment or DOMAIN_RESOURCE[READ] permission on the specified organization
   * Get a resource
   */
  async getResource(
    requestParameters: GetResourceRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<ServiceResource> {
    const response = await this.getResourceRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have APPLICATION_OPENID[LIST] permission on the specified application or APPLICATION_OPENID[LIST] permission on the specified domain or APPLICATION_OPENID[LIST] permission on the specified environment or APPLICATION_OPENID[LIST] permission on the specified organization
   * List secrets of an application
   */
  async getSecretsRaw(
    requestParameters: GetSecretsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<ClientSecret>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getSecrets.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getSecrets.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getSecrets.',
      );
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling getSecrets.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/secrets`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ClientSecretFromJSON));
  }

  /**
   * User must have APPLICATION_OPENID[LIST] permission on the specified application or APPLICATION_OPENID[LIST] permission on the specified domain or APPLICATION_OPENID[LIST] permission on the specified environment or APPLICATION_OPENID[LIST] permission on the specified organization
   * List secrets of an application
   */
  async getSecrets(
    requestParameters: GetSecretsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<ClientSecret>> {
    const response = await this.getSecretsRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_THEME[READ] permission on the specified domain or DOMAIN_THEME[READ] permission on the specified environment or DOMAIN_THEME[READ] permission on the specified organization
   * Get the theme linked to the specified security domain
   */
  async getThemeRaw(
    requestParameters: GetThemeRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ThemeEntity>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getTheme.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getTheme.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling getTheme.');
    }

    if (requestParameters.themeId === null || requestParameters.themeId === undefined) {
      throw new runtime.RequiredError(
        'themeId',
        'Required parameter requestParameters.themeId was null or undefined when calling getTheme.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/themes/{themeId}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'themeId'}}`, encodeURIComponent(String(requestParameters.themeId))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ThemeEntityFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_THEME[READ] permission on the specified domain or DOMAIN_THEME[READ] permission on the specified environment or DOMAIN_THEME[READ] permission on the specified organization
   * Get the theme linked to the specified security domain
   */
  async getTheme(requestParameters: GetThemeRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<ThemeEntity> {
    const response = await this.getThemeRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user audit logs
   */
  async list10Raw(
    requestParameters: List10Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<Audit>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling list10.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling list10.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling list10.');
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError('user', 'Required parameter requestParameters.user was null or undefined when calling list10.');
    }

    const queryParameters: any = {};

    if (requestParameters.type !== undefined) {
      queryParameters['type'] = requestParameters.type;
    }

    if (requestParameters.status !== undefined) {
      queryParameters['status'] = requestParameters.status;
    }

    if (requestParameters.from !== undefined) {
      queryParameters['from'] = requestParameters.from;
    }

    if (requestParameters.to !== undefined) {
      queryParameters['to'] = requestParameters.to;
    }

    if (requestParameters.size !== undefined) {
      queryParameters['size'] = requestParameters.size;
    }

    if (requestParameters.page !== undefined) {
      queryParameters['page'] = requestParameters.page;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/audits`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AuditFromJSON));
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user audit logs
   */
  async list10(requestParameters: List10Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Array<Audit>> {
    const response = await this.list10Raw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user consents
   */
  async list11Raw(
    requestParameters: List11Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ScopeApprovalEntity>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling list11.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling list11.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling list11.');
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError('user', 'Required parameter requestParameters.user was null or undefined when calling list11.');
    }

    const queryParameters: any = {};

    if (requestParameters.clientId !== undefined) {
      queryParameters['clientId'] = requestParameters.clientId;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/consents`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ScopeApprovalEntityFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user consents
   */
  async list11(requestParameters: List11Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<ScopeApprovalEntity> {
    const response = await this.list11Raw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user credentials
   */
  async list12Raw(
    requestParameters: List12Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Credential>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling list12.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling list12.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling list12.');
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError('user', 'Required parameter requestParameters.user was null or undefined when calling list12.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/credentials`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => CredentialFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user credentials
   */
  async list12(requestParameters: List12Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Credential> {
    const response = await this.list12Raw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER_DEVICES[LIST] permission on the specified domain or DOMAIN_USER_DEVICES[LIST] permission on the specified environment or DOMAIN_USER_DEVICES[LIST] permission on the specified organization.
   * List users for a security domain
   */
  async list13Raw(
    requestParameters: List13Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<User>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling list13.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling list13.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling list13.');
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError('user', 'Required parameter requestParameters.user was null or undefined when calling list13.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/devices`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UserFromJSON));
  }

  /**
   * User must have the DOMAIN_USER_DEVICES[LIST] permission on the specified domain or DOMAIN_USER_DEVICES[LIST] permission on the specified environment or DOMAIN_USER_DEVICES[LIST] permission on the specified organization.
   * List users for a security domain
   */
  async list13(requestParameters: List13Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Array<User>> {
    const response = await this.list13Raw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user enrolled factors
   */
  async list14Raw(
    requestParameters: List14Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<EnrolledFactorEntity>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling list14.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling list14.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling list14.');
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError('user', 'Required parameter requestParameters.user was null or undefined when calling list14.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/factors`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(EnrolledFactorEntityFromJSON));
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user enrolled factors
   */
  async list14(
    requestParameters: List14Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<EnrolledFactorEntity>> {
    const response = await this.list14Raw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user linked identities
   */
  async list15Raw(
    requestParameters: List15Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<UserIdentityEntity>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling list15.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling list15.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling list15.');
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError('user', 'Required parameter requestParameters.user was null or undefined when calling list15.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/identities`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UserIdentityEntityFromJSON));
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user linked identities
   */
  async list15(
    requestParameters: List15Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<UserIdentityEntity>> {
    const response = await this.list15Raw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user roles
   */
  async list16Raw(
    requestParameters: List16Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<Role>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling list16.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling list16.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling list16.');
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError('user', 'Required parameter requestParameters.user was null or undefined when calling list16.');
    }

    const queryParameters: any = {};

    if (requestParameters.dynamic !== undefined) {
      queryParameters['dynamic'] = requestParameters.dynamic;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/roles`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(RoleFromJSON));
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user roles
   */
  async list16(requestParameters: List16Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Array<Role>> {
    const response = await this.list16Raw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * List all the alert triggers of the domain accessible to the current user. User must have DOMAIN_ALERT[LIST] permission on the specified domain, environment or organization.
   * List alert alert triggers
   */
  async list2Raw(
    requestParameters: List2Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<AlertTrigger>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling list2.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling list2.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling list2.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/alerts/triggers`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AlertTriggerFromJSON));
  }

  /**
   * List all the alert triggers of the domain accessible to the current user. User must have DOMAIN_ALERT[LIST] permission on the specified domain, environment or organization.
   * List alert alert triggers
   */
  async list2(requestParameters: List2Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Array<AlertTrigger>> {
    const response = await this.list2Raw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Update multiple alert triggers in the same timeUser must have DOMAIN_ALERT[UPDATE] permission on the specified domain, environment or organization.
   * Update multiple alert triggers
   */
  async list3Raw(
    requestParameters: List3Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<AlertTrigger>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling list3.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling list3.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling list3.');
    }

    if (requestParameters.patchAlertTrigger === null || requestParameters.patchAlertTrigger === undefined) {
      throw new runtime.RequiredError(
        'patchAlertTrigger',
        'Required parameter requestParameters.patchAlertTrigger was null or undefined when calling list3.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/alerts/triggers`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'PATCH',
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.patchAlertTrigger.map(PatchAlertTriggerToJSON),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AlertTriggerFromJSON));
  }

  /**
   * Update multiple alert triggers in the same timeUser must have DOMAIN_ALERT[UPDATE] permission on the specified domain, environment or organization.
   * Update multiple alert triggers
   */
  async list3(requestParameters: List3Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Array<AlertTrigger>> {
    const response = await this.list3Raw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have APPLICATION_RESOURCE[READ] permission on the specified application or APPLICATION_RESOURCE[READ] permission on the specified domain or APPLICATION_RESOURCE[READ] permission on the specified environment or APPLICATION_RESOURCE[READ] permission on the specified organization
   * Get resource access policies
   */
  async list4Raw(
    requestParameters: List4Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<AccessPolicyListItem>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling list4.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling list4.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling list4.');
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling list4.',
      );
    }

    if (requestParameters.resource === null || requestParameters.resource === undefined) {
      throw new runtime.RequiredError(
        'resource',
        'Required parameter requestParameters.resource was null or undefined when calling list4.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/resources/{resource}/policies`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application)))
          .replace(`{${'resource'}}`, encodeURIComponent(String(requestParameters.resource))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AccessPolicyListItemFromJSON));
  }

  /**
   * User must have APPLICATION_RESOURCE[READ] permission on the specified application or APPLICATION_RESOURCE[READ] permission on the specified domain or APPLICATION_RESOURCE[READ] permission on the specified environment or APPLICATION_RESOURCE[READ] permission on the specified organization
   * Get resource access policies
   */
  async list4(
    requestParameters: List4Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<AccessPolicyListItem>> {
    const response = await this.list4Raw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have APPLICATION_RESOURCE[LIST] permission on the specified application or APPLICATION_RESOURCE[LIST] permission on the specified domain or APPLICATION_RESOURCE[LIST] permission on the specified environment or APPLICATION_RESOURCE[LIST] permission on the specified organization
   * List resources for an application
   */
  async list5Raw(
    requestParameters: List5Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ResourceListItem>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling list5.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling list5.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling list5.');
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling list5.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.page !== undefined) {
      queryParameters['page'] = requestParameters.page;
    }

    if (requestParameters.size !== undefined) {
      queryParameters['size'] = requestParameters.size;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/resources`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ResourceListItemFromJSON(jsonValue));
  }

  /**
   * User must have APPLICATION_RESOURCE[LIST] permission on the specified application or APPLICATION_RESOURCE[LIST] permission on the specified domain or APPLICATION_RESOURCE[LIST] permission on the specified environment or APPLICATION_RESOURCE[LIST] permission on the specified organization
   * List resources for an application
   */
  async list5(requestParameters: List5Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<ResourceListItem> {
    const response = await this.list5Raw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_AUDIT[LIST] permission on the specified domain, environment or organization. Except if user has ORGANIZATION_AUDIT[READ] permission on the domain, environment or organization, each returned audit is filtered and contains only basic information such as id, date, event, actor, target and status.
   * List audit logs for a security domain
   */
  async list6Raw(
    requestParameters: List6Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<Audit>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling list6.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling list6.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling list6.');
    }

    const queryParameters: any = {};

    if (requestParameters.type !== undefined) {
      queryParameters['type'] = requestParameters.type;
    }

    if (requestParameters.status !== undefined) {
      queryParameters['status'] = requestParameters.status;
    }

    if (requestParameters.user !== undefined) {
      queryParameters['user'] = requestParameters.user;
    }

    if (requestParameters.from !== undefined) {
      queryParameters['from'] = requestParameters.from;
    }

    if (requestParameters.to !== undefined) {
      queryParameters['to'] = requestParameters.to;
    }

    if (requestParameters.size !== undefined) {
      queryParameters['size'] = requestParameters.size;
    }

    if (requestParameters.page !== undefined) {
      queryParameters['page'] = requestParameters.page;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/audits`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AuditFromJSON));
  }

  /**
   * User must have the DOMAIN_AUDIT[LIST] permission on the specified domain, environment or organization. Except if user has ORGANIZATION_AUDIT[READ] permission on the domain, environment or organization, each returned audit is filtered and contains only basic information such as id, date, event, actor, target and status.
   * List audit logs for a security domain
   */
  async list6(requestParameters: List6Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Array<Audit>> {
    const response = await this.list6Raw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_AUTHDEVICE_NOTIFIER[LIST] permission on the specified domain or DOMAIN_AUTHDEVICE_NOTIFIER[LIST] permission on the specified environment or DOMAIN_AUTHDEVICE_NOTIFIER[LIST] permission on the specified organization Each returned Authentication Device Notifier is filtered and contains only basic information such as id, name.
   * List registered Authentication Device Notifiers for a security domain
   */
  async list7Raw(
    requestParameters: List7Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<AuthenticationDeviceNotifier>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling list7.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling list7.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling list7.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/auth-device-notifiers`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AuthenticationDeviceNotifierFromJSON));
  }

  /**
   * User must have the DOMAIN_AUTHDEVICE_NOTIFIER[LIST] permission on the specified domain or DOMAIN_AUTHDEVICE_NOTIFIER[LIST] permission on the specified environment or DOMAIN_AUTHDEVICE_NOTIFIER[LIST] permission on the specified organization Each returned Authentication Device Notifier is filtered and contains only basic information such as id, name.
   * List registered Authentication Device Notifiers for a security domain
   */
  async list7(
    requestParameters: List7Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<AuthenticationDeviceNotifier>> {
    const response = await this.list7Raw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_MEMBER[LIST] permission on the specified domain or DOMAIN_MEMBER[LIST] permission on the specified environment or DOMAIN_MEMBER[LIST] permission on the specified organization
   * List members for a security domain
   */
  async list8Raw(
    requestParameters: List8Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<MembershipListItem>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling list8.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling list8.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling list8.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/members`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => MembershipListItemFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_MEMBER[LIST] permission on the specified domain or DOMAIN_MEMBER[LIST] permission on the specified environment or DOMAIN_MEMBER[LIST] permission on the specified organization
   * List members for a security domain
   */
  async list8(requestParameters: List8Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<MembershipListItem> {
    const response = await this.list8Raw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_REPORTER[LIST] permission on the specified domain or DOMAIN_REPORTER[LIST] permission on the specified environment or DOMAIN_REPORTER[LIST] permission on the specified organization. Except if user has DOMAIN_REPORTER[READ] permission on the domain, environment or organization, each returned reporter is filtered and contains only basic information such as id and name and type.
   * List registered reporters for a security domain
   */
  async list9Raw(
    requestParameters: List9Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<Reporter>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling list9.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling list9.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling list9.');
    }

    const queryParameters: any = {};

    if (requestParameters.userProvider !== undefined) {
      queryParameters['userProvider'] = requestParameters.userProvider;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/reporters`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ReporterFromJSON));
  }

  /**
   * User must have the DOMAIN_REPORTER[LIST] permission on the specified domain or DOMAIN_REPORTER[LIST] permission on the specified environment or DOMAIN_REPORTER[LIST] permission on the specified organization. Except if user has DOMAIN_REPORTER[READ] permission on the domain, environment or organization, each returned reporter is filtered and contains only basic information such as id and name and type.
   * List registered reporters for a security domain
   */
  async list9(requestParameters: List9Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Array<Reporter>> {
    const response = await this.list9Raw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * List all the alert notifiers of the domain. User must have DOMAIN_ALERT_NOTIFIER[LIST] permission on the specified domain, environment or organization.
   * List alert notifiers
   */
  async listAlertNotifiersRaw(
    requestParameters: ListAlertNotifiersRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<AlertNotifier>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listAlertNotifiers.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listAlertNotifiers.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listAlertNotifiers.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/alerts/notifiers`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AlertNotifierFromJSON));
  }

  /**
   * List all the alert notifiers of the domain. User must have DOMAIN_ALERT_NOTIFIER[LIST] permission on the specified domain, environment or organization.
   * List alert notifiers
   */
  async listAlertNotifiers(
    requestParameters: ListAlertNotifiersRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<AlertNotifier>> {
    const response = await this.listAlertNotifiersRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the APPLICATION_FLOW[LIST] permission on the specified domain or APPLICATION_FLOW[LIST] permission on the specified environment or APPLICATION_FLOW[LIST] permission on the specified organization. Except if user has APPLICATION_FLOW[READ] permission on the domain, environment or organization, each returned flow is filtered and contains only basic information such as id and name and isEnabled.
   * List registered flows for an application
   */
  async listAppFlowsRaw(
    requestParameters: ListAppFlowsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<FlowEntity>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listAppFlows.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listAppFlows.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listAppFlows.',
      );
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling listAppFlows.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/flows`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(FlowEntityFromJSON));
  }

  /**
   * User must have the APPLICATION_FLOW[LIST] permission on the specified domain or APPLICATION_FLOW[LIST] permission on the specified environment or APPLICATION_FLOW[LIST] permission on the specified organization. Except if user has APPLICATION_FLOW[READ] permission on the domain, environment or organization, each returned flow is filtered and contains only basic information such as id and name and isEnabled.
   * List registered flows for an application
   */
  async listAppFlows(
    requestParameters: ListAppFlowsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<FlowEntity>> {
    const response = await this.listAppFlowsRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the APPLICATION[LIST] permission on the specified domain, environment or organization AND either APPLICATION[READ] permission on each domain\'s application or APPLICATION[READ] permission on the specified domain or APPLICATION[READ] permission on the specified environment or APPLICATION[READ] permission on the specified organization. Each returned application is filtered and contains only basic information such as id, name, description and isEnabled.
   * List registered applications for a security domain
   */
  async listApplicationsRaw(
    requestParameters: ListApplicationsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ApplicationPage>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listApplications.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listApplications.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listApplications.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.page !== undefined) {
      queryParameters['page'] = requestParameters.page;
    }

    if (requestParameters.size !== undefined) {
      queryParameters['size'] = requestParameters.size;
    }

    if (requestParameters.q !== undefined) {
      queryParameters['q'] = requestParameters.q;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ApplicationPageFromJSON(jsonValue));
  }

  /**
   * User must have the APPLICATION[LIST] permission on the specified domain, environment or organization AND either APPLICATION[READ] permission on each domain\'s application or APPLICATION[READ] permission on the specified domain or APPLICATION[READ] permission on the specified environment or APPLICATION[READ] permission on the specified organization. Each returned application is filtered and contains only basic information such as id, name, description and isEnabled.
   * List registered applications for a security domain
   */
  async listApplications(
    requestParameters: ListApplicationsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<ApplicationPage> {
    const response = await this.listApplicationsRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_AUTHORIZATION_ENGINE[LIST] permission on the specified domain or DOMAIN_AUTHORIZATION_ENGINE[LIST] permission on the specified environment or DOMAIN_AUTHORIZATION_ENGINE[LIST] permission on the specified organization.
   * List registered authorization engines for a security domain
   */
  async listAuthorizationEnginesRaw(
    requestParameters: ListAuthorizationEnginesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<AuthorizationEngine>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listAuthorizationEngines.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listAuthorizationEngines.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listAuthorizationEngines.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/authorization-engines`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AuthorizationEngineFromJSON));
  }

  /**
   * User must have the DOMAIN_AUTHORIZATION_ENGINE[LIST] permission on the specified domain or DOMAIN_AUTHORIZATION_ENGINE[LIST] permission on the specified environment or DOMAIN_AUTHORIZATION_ENGINE[LIST] permission on the specified organization.
   * List registered authorization engines for a security domain
   */
  async listAuthorizationEngines(
    requestParameters: ListAuthorizationEnginesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<AuthorizationEngine>> {
    const response = await this.listAuthorizationEnginesRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_BOT_DETECTION[LIST] permission on the specified domain or DOMAIN_BOT_DETECTION[LIST] permission on the specified environment or DOMAIN_BOT_DETECTION[LIST] permission on the specified organization Each returned bot detections is filtered and contains only basic information such as id, name.
   * List registered bot detections for a security domain
   */
  async listBotDetectionsRaw(
    requestParameters: ListBotDetectionsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<BotDetection>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listBotDetections.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listBotDetections.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listBotDetections.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/bot-detections`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(BotDetectionFromJSON));
  }

  /**
   * User must have the DOMAIN_BOT_DETECTION[LIST] permission on the specified domain or DOMAIN_BOT_DETECTION[LIST] permission on the specified environment or DOMAIN_BOT_DETECTION[LIST] permission on the specified organization Each returned bot detections is filtered and contains only basic information such as id, name.
   * List registered bot detections for a security domain
   */
  async listBotDetections(
    requestParameters: ListBotDetectionsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<BotDetection>> {
    const response = await this.listBotDetectionsRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_CERTIFICATE[LIST] permission on the specified domain or DOMAIN_CERTIFICATE[LIST] permission on the specified environment or DOMAIN_CERTIFICATE[LIST] permission on the specified organization. Each returned certificate is filtered and contains only basic information such as id, name and type.
   * List registered certificates for a security domain
   */
  async listCertificatesRaw(
    requestParameters: ListCertificatesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<CertificateEntity>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listCertificates.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listCertificates.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listCertificates.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.use !== undefined) {
      queryParameters['use'] = requestParameters.use;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/certificates`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CertificateEntityFromJSON));
  }

  /**
   * User must have the DOMAIN_CERTIFICATE[LIST] permission on the specified domain or DOMAIN_CERTIFICATE[LIST] permission on the specified environment or DOMAIN_CERTIFICATE[LIST] permission on the specified organization. Each returned certificate is filtered and contains only basic information such as id, name and type.
   * List registered certificates for a security domain
   */
  async listCertificates(
    requestParameters: ListCertificatesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<CertificateEntity>> {
    const response = await this.listCertificatesRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_DEVICE_IDENTIFIERS[LIST] permission on the specified domain or DOMAIN_DEVICE_IDENTIFIERS[LIST] permission on the specified environment or DOMAIN_DEVICE_IDENTIFIERS[LIST] permission on the specified organization Each returned bot detections is filtered and contains only basic information such as id, name.
   * List registered device identifiers for a security domain
   */
  async listDeviceIdentifiersRaw(
    requestParameters: ListDeviceIdentifiersRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<DeviceIdentifier>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listDeviceIdentifiers.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listDeviceIdentifiers.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listDeviceIdentifiers.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/device-identifiers`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(DeviceIdentifierFromJSON));
  }

  /**
   * User must have the DOMAIN_DEVICE_IDENTIFIERS[LIST] permission on the specified domain or DOMAIN_DEVICE_IDENTIFIERS[LIST] permission on the specified environment or DOMAIN_DEVICE_IDENTIFIERS[LIST] permission on the specified organization Each returned bot detections is filtered and contains only basic information such as id, name.
   * List registered device identifiers for a security domain
   */
  async listDeviceIdentifiers(
    requestParameters: ListDeviceIdentifiersRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<DeviceIdentifier>> {
    const response = await this.listDeviceIdentifiersRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_FLOW[LIST] permission on the specified domain or DOMAIN_FLOW[LIST] permission on the specified environment or DOMAIN_FLOW[LIST] permission on the specified organization. Except if user has DOMAIN_FLOW[READ] permission on the domain, environment or organization, each returned flow is filtered and contains only basic information such as id and name and isEnabled.
   * List registered flows for a security domain
   */
  async listDomainFlowsRaw(
    requestParameters: ListDomainFlowsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<FlowEntity>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listDomainFlows.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listDomainFlows.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listDomainFlows.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/flows`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(FlowEntityFromJSON));
  }

  /**
   * User must have the DOMAIN_FLOW[LIST] permission on the specified domain or DOMAIN_FLOW[LIST] permission on the specified environment or DOMAIN_FLOW[LIST] permission on the specified organization. Except if user has DOMAIN_FLOW[READ] permission on the domain, environment or organization, each returned flow is filtered and contains only basic information such as id and name and isEnabled.
   * List registered flows for a security domain
   */
  async listDomainFlows(
    requestParameters: ListDomainFlowsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<FlowEntity>> {
    const response = await this.listDomainFlowsRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * List all the security domains accessible to the current user. User must have DOMAIN[LIST] permission on the specified environment or organization AND either DOMAIN[READ] permission on each security domain or DOMAIN[READ] permission on the specified environment or DOMAIN[READ] permission on the specified organization.Each returned domain is filtered and contains only basic information such as id, name and description and isEnabled.
   * List security domains for an environment
   */
  async listDomainsRaw(
    requestParameters: ListDomainsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<DomainPage>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listDomains.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listDomains.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.page !== undefined) {
      queryParameters['page'] = requestParameters.page;
    }

    if (requestParameters.size !== undefined) {
      queryParameters['size'] = requestParameters.size;
    }

    if (requestParameters.q !== undefined) {
      queryParameters['q'] = requestParameters.q;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(DomainPageFromJSON));
  }

  /**
   * List all the security domains accessible to the current user. User must have DOMAIN[LIST] permission on the specified environment or organization AND either DOMAIN[READ] permission on each security domain or DOMAIN[READ] permission on the specified environment or DOMAIN[READ] permission on the specified organization.Each returned domain is filtered and contains only basic information such as id, name and description and isEnabled.
   * List security domains for an environment
   */
  async listDomains(
    requestParameters: ListDomainsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<DomainPage>> {
    const response = await this.listDomainsRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_EXTENSION_GRANT[LIST] permission on the specified domain or DOMAIN_EXTENSION_GRANT[LIST] permission on the specified environment or DOMAIN_EXTENSION_GRANT[LIST] permission on the specified organization. Each returned extension grant is filtered and contains only basic information such as id, name and type.
   * List registered extension grants for a security domain
   */
  async listExtensionGrantsRaw(
    requestParameters: ListExtensionGrantsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<ExtensionGrant>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listExtensionGrants.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listExtensionGrants.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listExtensionGrants.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/extensionGrants`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ExtensionGrantFromJSON));
  }

  /**
   * User must have the DOMAIN_EXTENSION_GRANT[LIST] permission on the specified domain or DOMAIN_EXTENSION_GRANT[LIST] permission on the specified environment or DOMAIN_EXTENSION_GRANT[LIST] permission on the specified organization. Each returned extension grant is filtered and contains only basic information such as id, name and type.
   * List registered extension grants for a security domain
   */
  async listExtensionGrants(
    requestParameters: ListExtensionGrantsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<ExtensionGrant>> {
    const response = await this.listExtensionGrantsRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_FACTOR[LIST] permission on the specified domain or DOMAIN_FACTOR[LIST] permission on the specified environment or DOMAIN_FACTOR[LIST] permission on the specified organization Each returned factor is filtered and contains only basic information such as id, name and factor type.
   * List registered factors for a security domain
   */
  async listFactorsRaw(
    requestParameters: ListFactorsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<Factor>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listFactors.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listFactors.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listFactors.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/factors`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(FactorFromJSON));
  }

  /**
   * User must have the DOMAIN_FACTOR[LIST] permission on the specified domain or DOMAIN_FACTOR[LIST] permission on the specified environment or DOMAIN_FACTOR[LIST] permission on the specified organization Each returned factor is filtered and contains only basic information such as id, name and factor type.
   * List registered factors for a security domain
   */
  async listFactors(
    requestParameters: ListFactorsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<Factor>> {
    const response = await this.listFactorsRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_GROUP[LIST] permission on the specified domain or DOMAIN_GROUP[LIST] permission on the specified environment or DOMAIN_GROUP[LIST] permission on the specified organization. Each returned group is filtered and contains only basic information such as id and name.
   * List groups for a security domain
   */
  async listGroupsRaw(
    requestParameters: ListGroupsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<GroupPage>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listGroups.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listGroups.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listGroups.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.page !== undefined) {
      queryParameters['page'] = requestParameters.page;
    }

    if (requestParameters.size !== undefined) {
      queryParameters['size'] = requestParameters.size;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/groups`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => GroupPageFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_GROUP[LIST] permission on the specified domain or DOMAIN_GROUP[LIST] permission on the specified environment or DOMAIN_GROUP[LIST] permission on the specified organization. Each returned group is filtered and contains only basic information such as id and name.
   * List groups for a security domain
   */
  async listGroups(requestParameters: ListGroupsRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<GroupPage> {
    const response = await this.listGroupsRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_I18N_DICTIONARY[LIST] permission on the specified domain or DOMAIN_I18N_DICTIONARY[LIST] permission on the specified environment or DOMAIN_I18N_DICTIONARY[LIST] permission on the specified organization.
   * List all i18n dictionaries supported for a security domain
   */
  async listI18nDictionariesRaw(
    requestParameters: ListI18nDictionariesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<I18nDictionary>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listI18nDictionaries.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listI18nDictionaries.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listI18nDictionaries.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/i18n/dictionaries`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(I18nDictionaryFromJSON));
  }

  /**
   * User must have the DOMAIN_I18N_DICTIONARY[LIST] permission on the specified domain or DOMAIN_I18N_DICTIONARY[LIST] permission on the specified environment or DOMAIN_I18N_DICTIONARY[LIST] permission on the specified organization.
   * List all i18n dictionaries supported for a security domain
   */
  async listI18nDictionaries(
    requestParameters: ListI18nDictionariesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<I18nDictionary>> {
    const response = await this.listI18nDictionariesRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_IDENTITY_PROVIDER[LIST] permission on the specified domain or DOMAIN_IDENTITY_PROVIDER[LIST] permission on the specified environment or DOMAIN_IDENTITY_PROVIDER[LIST] permission on the specified organization. Each returned identity provider is filtered and contains only basic information such as id, name and type.
   * List registered identity providers for a security domain
   */
  async listIdentityProvidersRaw(
    requestParameters: ListIdentityProvidersRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<FilteredIdentityProviderInfo>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listIdentityProviders.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listIdentityProviders.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listIdentityProviders.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.userProvider !== undefined) {
      queryParameters['userProvider'] = requestParameters.userProvider;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/identities`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(FilteredIdentityProviderInfoFromJSON));
  }

  /**
   * User must have the DOMAIN_IDENTITY_PROVIDER[LIST] permission on the specified domain or DOMAIN_IDENTITY_PROVIDER[LIST] permission on the specified environment or DOMAIN_IDENTITY_PROVIDER[LIST] permission on the specified organization. Each returned identity provider is filtered and contains only basic information such as id, name and type.
   * List registered identity providers for a security domain
   */
  async listIdentityProviders(
    requestParameters: ListIdentityProvidersRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<FilteredIdentityProviderInfo>> {
    const response = await this.listIdentityProvidersRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_SETTINGS[READ] permission on the specified domain or DOMAIN_SETTINGS[READ] permission on the specified environment or DOMAIN_SETTINGS[READ] permission on the specified organization.
   * List registered password policies for a security domain
   */
  async listPasswordPoliciesRaw(
    requestParameters: ListPasswordPoliciesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<PasswordPolicyEntity>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listPasswordPolicies.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listPasswordPolicies.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listPasswordPolicies.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/password-policies`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PasswordPolicyEntityFromJSON));
  }

  /**
   * User must have the DOMAIN_SETTINGS[READ] permission on the specified domain or DOMAIN_SETTINGS[READ] permission on the specified environment or DOMAIN_SETTINGS[READ] permission on the specified organization.
   * List registered password policies for a security domain
   */
  async listPasswordPolicies(
    requestParameters: ListPasswordPoliciesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<PasswordPolicyEntity>> {
    const response = await this.listPasswordPoliciesRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the PROTECTED_RESOURCE[LIST] permission on the specified domain, environment or organization AND either PROTECTED_RESOURCE[READ] permission on each domain\'s protected resource or PROTECTED_RESOURCE[READ] permission on the specified domain or PROTECTED_RESOURCE[READ] permission on the specified environment or PROTECTED_RESOURCE[READ] permission on the specified organization. Each returned protected resource is filtered and contains only basic information such as id, name, description and isEnabled.
   * List registered protected resources for a security domain
   */
  async listProtectedResourcesRaw(
    requestParameters: ListProtectedResourcesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ProtectedResourcePage>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listProtectedResources.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listProtectedResources.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listProtectedResources.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.type !== undefined) {
      queryParameters['type'] = requestParameters.type;
    }

    if (requestParameters.page !== undefined) {
      queryParameters['page'] = requestParameters.page;
    }

    if (requestParameters.size !== undefined) {
      queryParameters['size'] = requestParameters.size;
    }

    if (requestParameters.sort !== undefined) {
      queryParameters['sort'] = requestParameters.sort;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/protected-resources`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ProtectedResourcePageFromJSON(jsonValue));
  }

  /**
   * User must have the PROTECTED_RESOURCE[LIST] permission on the specified domain, environment or organization AND either PROTECTED_RESOURCE[READ] permission on each domain\'s protected resource or PROTECTED_RESOURCE[READ] permission on the specified domain or PROTECTED_RESOURCE[READ] permission on the specified environment or PROTECTED_RESOURCE[READ] permission on the specified organization. Each returned protected resource is filtered and contains only basic information such as id, name, description and isEnabled.
   * List registered protected resources for a security domain
   */
  async listProtectedResources(
    requestParameters: ListProtectedResourcesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<ProtectedResourcePage> {
    const response = await this.listProtectedResourcesRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_RESOURCE[LIST] permission on the specified domain or DOMAIN_RESOURCE[LIST] permission on the specified environment or DOMAIN_RESOURCE[LIST] permission on the specified organization Each returned resource is filtered and contains only basic information such as id, name and resource type.
   * List registered resources for a security domain
   */
  async listResourcesRaw(
    requestParameters: ListResourcesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<ServiceResource>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listResources.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listResources.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listResources.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/resources`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ServiceResourceFromJSON));
  }

  /**
   * User must have the DOMAIN_RESOURCE[LIST] permission on the specified domain or DOMAIN_RESOURCE[LIST] permission on the specified environment or DOMAIN_RESOURCE[LIST] permission on the specified organization Each returned resource is filtered and contains only basic information such as id, name and resource type.
   * List registered resources for a security domain
   */
  async listResources(
    requestParameters: ListResourcesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<ServiceResource>> {
    const response = await this.listResourcesRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_SCOPE[LIST] permission on the specified domain or DOMAIN_SCOPE[LIST] permission on the specified environment or DOMAIN_SCOPE[LIST] permission on the specified organization Each returned scope is filtered and contains only basic information such as id, key, name, description, isSystem and isDiscovery.
   * List scopes for a security domain
   */
  async listScopesRaw(
    requestParameters: ListScopesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ScopePage>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listScopes.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listScopes.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listScopes.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.page !== undefined) {
      queryParameters['page'] = requestParameters.page;
    }

    if (requestParameters.size !== undefined) {
      queryParameters['size'] = requestParameters.size;
    }

    if (requestParameters.q !== undefined) {
      queryParameters['q'] = requestParameters.q;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/scopes`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ScopePageFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_SCOPE[LIST] permission on the specified domain or DOMAIN_SCOPE[LIST] permission on the specified environment or DOMAIN_SCOPE[LIST] permission on the specified organization Each returned scope is filtered and contains only basic information such as id, key, name, description, isSystem and isDiscovery.
   * List scopes for a security domain
   */
  async listScopes(requestParameters: ListScopesRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<ScopePage> {
    const response = await this.listScopesRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_THEME[LIST] permission on the specified domain or DOMAIN_THEME[LIST] permission on the specified environment or DOMAIN_THEME[LIST] permission on the specified organization
   * List themes on the specified security domain
   */
  async listThemesRaw(
    requestParameters: ListThemesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<ThemeEntity>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listThemes.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listThemes.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listThemes.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/themes`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ThemeEntityFromJSON));
  }

  /**
   * User must have the DOMAIN_THEME[LIST] permission on the specified domain or DOMAIN_THEME[LIST] permission on the specified environment or DOMAIN_THEME[LIST] permission on the specified organization
   * List themes on the specified security domain
   */
  async listThemes(
    requestParameters: ListThemesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<ThemeEntity>> {
    const response = await this.listThemesRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[LIST] permission on the specified domain or DOMAIN_USER[LIST] permission on the specified environment or DOMAIN_USER[LIST] permission on the specified organization. Each returned user is filtered and contains only basic information such as id and username and displayname. Last login and identity provider name will be also returned if current user has DOMAIN_USER[READ] permission on the domain, environment or organization.
   * List users for a security domain
   */
  async listUsersRaw(
    requestParameters: ListUsersRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<UserPage>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listUsers.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listUsers.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listUsers.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.q !== undefined) {
      queryParameters['q'] = requestParameters.q;
    }

    if (requestParameters.filter !== undefined) {
      queryParameters['filter'] = requestParameters.filter;
    }

    if (requestParameters.page !== undefined) {
      queryParameters['page'] = requestParameters.page;
    }

    if (requestParameters.size !== undefined) {
      queryParameters['size'] = requestParameters.size;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => UserPageFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_USER[LIST] permission on the specified domain or DOMAIN_USER[LIST] permission on the specified environment or DOMAIN_USER[LIST] permission on the specified organization. Each returned user is filtered and contains only basic information such as id and username and displayname. Last login and identity provider name will be also returned if current user has DOMAIN_USER[READ] permission on the domain, environment or organization.
   * List users for a security domain
   */
  async listUsers(requestParameters: ListUsersRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<UserPage> {
    const response = await this.listUsersRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Lock a user
   */
  async lockUserRaw(
    requestParameters: LockUserRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling lockUser.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling lockUser.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling lockUser.');
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError('user', 'Required parameter requestParameters.user was null or undefined when calling lockUser.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/lock`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Lock a user
   */
  async lockUser(requestParameters: LockUserRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.lockUserRaw(requestParameters, initOverrides);
  }

  /**
   * Update an alert notifierUser must have DOMAIN_ALERT_NOTIFIER[UPDATE] permission on the specified domain, environment or organization.
   * Update an alert notifier
   */
  async patchAlertNotifierRaw(
    requestParameters: PatchAlertNotifierRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<AlertNotifier>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling patchAlertNotifier.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling patchAlertNotifier.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling patchAlertNotifier.',
      );
    }

    if (requestParameters.notifierId === null || requestParameters.notifierId === undefined) {
      throw new runtime.RequiredError(
        'notifierId',
        'Required parameter requestParameters.notifierId was null or undefined when calling patchAlertNotifier.',
      );
    }

    if (requestParameters.patchAlertNotifier === null || requestParameters.patchAlertNotifier === undefined) {
      throw new runtime.RequiredError(
        'patchAlertNotifier',
        'Required parameter requestParameters.patchAlertNotifier was null or undefined when calling patchAlertNotifier.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/alerts/notifiers/{notifierId}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'notifierId'}}`, encodeURIComponent(String(requestParameters.notifierId))),
        method: 'PATCH',
        headers: headerParameters,
        query: queryParameters,
        body: PatchAlertNotifierToJSON(requestParameters.patchAlertNotifier),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => AlertNotifierFromJSON(jsonValue));
  }

  /**
   * Update an alert notifierUser must have DOMAIN_ALERT_NOTIFIER[UPDATE] permission on the specified domain, environment or organization.
   * Update an alert notifier
   */
  async patchAlertNotifier(
    requestParameters: PatchAlertNotifierRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<AlertNotifier> {
    const response = await this.patchAlertNotifierRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have APPLICATION[UPDATE] permission on the specified application or APPLICATION[UPDATE] permission on the specified domain or APPLICATION[UPDATE] permission on the specified environment or APPLICATION[UPDATE] permission on the specified organization
   * Patch an application
   */
  async patchApplicationRaw(
    requestParameters: PatchApplicationRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Application>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling patchApplication.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling patchApplication.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling patchApplication.',
      );
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling patchApplication.',
      );
    }

    if (requestParameters.patchApplication === null || requestParameters.patchApplication === undefined) {
      throw new runtime.RequiredError(
        'patchApplication',
        'Required parameter requestParameters.patchApplication was null or undefined when calling patchApplication.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application))),
        method: 'PATCH',
        headers: headerParameters,
        query: queryParameters,
        body: PatchApplicationToJSON(requestParameters.patchApplication),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ApplicationFromJSON(jsonValue));
  }

  /**
   * User must have APPLICATION[UPDATE] permission on the specified application or APPLICATION[UPDATE] permission on the specified domain or APPLICATION[UPDATE] permission on the specified environment or APPLICATION[UPDATE] permission on the specified organization
   * Patch an application
   */
  async patchApplication(
    requestParameters: PatchApplicationRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Application> {
    const response = await this.patchApplicationRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_SETTINGS[UPDATE] permission on the specified domain or DOMAIN_SETTINGS[UPDATE] permission on the specified environment or DOMAIN_SETTINGS[UPDATE] permission on the specified organization.
   * Patch the security domain
   */
  async patchDomainRaw(
    requestParameters: PatchDomainRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Domain>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling patchDomain.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling patchDomain.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling patchDomain.',
      );
    }

    if (requestParameters.patchDomain === null || requestParameters.patchDomain === undefined) {
      throw new runtime.RequiredError(
        'patchDomain',
        'Required parameter requestParameters.patchDomain was null or undefined when calling patchDomain.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'PATCH',
        headers: headerParameters,
        query: queryParameters,
        body: PatchDomainToJSON(requestParameters.patchDomain),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => DomainFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_SETTINGS[UPDATE] permission on the specified domain or DOMAIN_SETTINGS[UPDATE] permission on the specified environment or DOMAIN_SETTINGS[UPDATE] permission on the specified organization.
   * Patch the security domain
   */
  async patchDomain(requestParameters: PatchDomainRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Domain> {
    const response = await this.patchDomainRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_SCOPE[UPDATE] permission on the specified domain or DOMAIN_SCOPE[UPDATE] permission on the specified environment or DOMAIN_SCOPE[UPDATE] permission on the specified organization
   * Patch a scope
   */
  async patchScopeRaw(
    requestParameters: PatchScopeRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Scope>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling patchScope.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling patchScope.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling patchScope.',
      );
    }

    if (requestParameters.scope === null || requestParameters.scope === undefined) {
      throw new runtime.RequiredError('scope', 'Required parameter requestParameters.scope was null or undefined when calling patchScope.');
    }

    if (requestParameters.patchScope === null || requestParameters.patchScope === undefined) {
      throw new runtime.RequiredError(
        'patchScope',
        'Required parameter requestParameters.patchScope was null or undefined when calling patchScope.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/scopes/{scope}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'scope'}}`, encodeURIComponent(String(requestParameters.scope))),
        method: 'PATCH',
        headers: headerParameters,
        query: queryParameters,
        body: PatchScopeToJSON(requestParameters.patchScope),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ScopeFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_SCOPE[UPDATE] permission on the specified domain or DOMAIN_SCOPE[UPDATE] permission on the specified environment or DOMAIN_SCOPE[UPDATE] permission on the specified organization
   * Patch a scope
   */
  async patchScope(requestParameters: PatchScopeRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Scope> {
    const response = await this.patchScopeRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have APPLICATION[READ] permission on the specified application or APPLICATION[READ] permission on the specified domain or APPLICATION[READ] permission on the specified environment or APPLICATION[READ] permission on the specified organization
   * List application member\'s permissions
   */
  async permissionsRaw(
    requestParameters: PermissionsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling permissions.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling permissions.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling permissions.',
      );
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling permissions.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/members/permissions`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.TextApiResponse(response) as any;
  }

  /**
   * User must have APPLICATION[READ] permission on the specified application or APPLICATION[READ] permission on the specified domain or APPLICATION[READ] permission on the specified environment or APPLICATION[READ] permission on the specified organization
   * List application member\'s permissions
   */
  async permissions(requestParameters: PermissionsRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<string> {
    const response = await this.permissionsRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have DOMAIN[READ] permission on the specified domain or DOMAIN[READ] permission on the specified environment or DOMAIN[READ] permission on the specified organization
   * List domain member\'s permissions
   */
  async permissions1Raw(
    requestParameters: Permissions1Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling permissions1.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling permissions1.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling permissions1.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/members/permissions`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.TextApiResponse(response) as any;
  }

  /**
   * User must have DOMAIN[READ] permission on the specified domain or DOMAIN[READ] permission on the specified environment or DOMAIN[READ] permission on the specified organization
   * List domain member\'s permissions
   */
  async permissions1(requestParameters: Permissions1Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<string> {
    const response = await this.permissions1Raw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_I18N_DICTIONARY[UPDATE] permission on the specified domain or DOMAIN_I18N_DICTIONARY[UPDATE] permission on the specified environment or DOMAIN_I18N_DICTIONARY[UPDATE] permission on the specified organization.
   * Update a i18n dictionary description
   */
  async putI18nDictionaryRaw(
    requestParameters: PutI18nDictionaryRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<I18nDictionary>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling putI18nDictionary.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling putI18nDictionary.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling putI18nDictionary.',
      );
    }

    if (requestParameters.dictionary === null || requestParameters.dictionary === undefined) {
      throw new runtime.RequiredError(
        'dictionary',
        'Required parameter requestParameters.dictionary was null or undefined when calling putI18nDictionary.',
      );
    }

    if (requestParameters.updateI18nDictionary === null || requestParameters.updateI18nDictionary === undefined) {
      throw new runtime.RequiredError(
        'updateI18nDictionary',
        'Required parameter requestParameters.updateI18nDictionary was null or undefined when calling putI18nDictionary.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/i18n/dictionaries/{dictionary}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'dictionary'}}`, encodeURIComponent(String(requestParameters.dictionary))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: UpdateI18nDictionaryToJSON(requestParameters.updateI18nDictionary),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => I18nDictionaryFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_I18N_DICTIONARY[UPDATE] permission on the specified domain or DOMAIN_I18N_DICTIONARY[UPDATE] permission on the specified environment or DOMAIN_I18N_DICTIONARY[UPDATE] permission on the specified organization.
   * Update a i18n dictionary description
   */
  async putI18nDictionary(
    requestParameters: PutI18nDictionaryRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<I18nDictionary> {
    const response = await this.putI18nDictionaryRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_GROUP[UPDATE] permission on the specified domain or DOMAIN_GROUP[UPDATE] permission on the specified environment or DOMAIN_GROUP[UPDATE] permission on the specified organization
   * Remove a group member
   */
  async removeGroupMemberRaw(
    requestParameters: RemoveGroupMemberRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling removeGroupMember.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling removeGroupMember.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling removeGroupMember.',
      );
    }

    if (requestParameters.group === null || requestParameters.group === undefined) {
      throw new runtime.RequiredError(
        'group',
        'Required parameter requestParameters.group was null or undefined when calling removeGroupMember.',
      );
    }

    if (requestParameters.member === null || requestParameters.member === undefined) {
      throw new runtime.RequiredError(
        'member',
        'Required parameter requestParameters.member was null or undefined when calling removeGroupMember.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/groups/{group}/members/{member}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'group'}}`, encodeURIComponent(String(requestParameters.group)))
          .replace(`{${'member'}}`, encodeURIComponent(String(requestParameters.member))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_GROUP[UPDATE] permission on the specified domain or DOMAIN_GROUP[UPDATE] permission on the specified environment or DOMAIN_GROUP[UPDATE] permission on the specified organization
   * Remove a group member
   */
  async removeGroupMember(
    requestParameters: RemoveGroupMemberRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.removeGroupMemberRaw(requestParameters, initOverrides);
  }

  /**
   * User must have APPLICATION_MEMBER[DELETE] permission on the specified application or APPLICATION_MEMBER[DELETE] permission on the specified domain or APPLICATION_MEMBER[DELETE] permission on the specified environment or APPLICATION_MEMBER[DELETE] permission on the specified organization
   * Remove a membership
   */
  async removeMemberRaw(
    requestParameters: RemoveMemberRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling removeMember.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling removeMember.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling removeMember.',
      );
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling removeMember.',
      );
    }

    if (requestParameters.member === null || requestParameters.member === undefined) {
      throw new runtime.RequiredError(
        'member',
        'Required parameter requestParameters.member was null or undefined when calling removeMember.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/members/{member}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application)))
          .replace(`{${'member'}}`, encodeURIComponent(String(requestParameters.member))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have APPLICATION_MEMBER[DELETE] permission on the specified application or APPLICATION_MEMBER[DELETE] permission on the specified domain or APPLICATION_MEMBER[DELETE] permission on the specified environment or APPLICATION_MEMBER[DELETE] permission on the specified organization
   * Remove a membership
   */
  async removeMember(requestParameters: RemoveMemberRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.removeMemberRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_MEMBER[DELETE] permission on the specified domain or DOMAIN_MEMBER[DELETE] permission on the specified environment or DOMAIN_MEMBER[DELETE] permission on the specified organization
   * Remove a membership
   */
  async removeMember1Raw(
    requestParameters: RemoveMember1Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling removeMember1.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling removeMember1.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling removeMember1.',
      );
    }

    if (requestParameters.member === null || requestParameters.member === undefined) {
      throw new runtime.RequiredError(
        'member',
        'Required parameter requestParameters.member was null or undefined when calling removeMember1.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/members/{member}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'member'}}`, encodeURIComponent(String(requestParameters.member))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_MEMBER[DELETE] permission on the specified domain or DOMAIN_MEMBER[DELETE] permission on the specified environment or DOMAIN_MEMBER[DELETE] permission on the specified organization
   * Remove a membership
   */
  async removeMember1(requestParameters: RemoveMember1Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.removeMember1Raw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_THEME[READ] permission on the specified domain or DOMAIN_THEME[READ] permission on the specified environment or DOMAIN_THEME[READ] permission on the specified organization
   * Render the provided template
   */
  async renderDomainTemplateRaw(
    requestParameters: RenderDomainTemplateRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<PreviewResponse>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling renderDomainTemplate.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling renderDomainTemplate.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling renderDomainTemplate.',
      );
    }

    if (requestParameters.previewRequest === null || requestParameters.previewRequest === undefined) {
      throw new runtime.RequiredError(
        'previewRequest',
        'Required parameter requestParameters.previewRequest was null or undefined when calling renderDomainTemplate.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/forms/preview`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: PreviewRequestToJSON(requestParameters.previewRequest),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => PreviewResponseFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_THEME[READ] permission on the specified domain or DOMAIN_THEME[READ] permission on the specified environment or DOMAIN_THEME[READ] permission on the specified organization
   * Render the provided template
   */
  async renderDomainTemplate(
    requestParameters: RenderDomainTemplateRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<PreviewResponse> {
    const response = await this.renderDomainTemplateRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have APPLICATION_OPENID[UPDATE] permission on the specified application or APPLICATION_OPENID[UPDATE] permission on the specified domain or APPLICATION_OPENID[UPDATE] permission on the specified environment or APPLICATION_OPENID[UPDATE] permission on the specified organization
   * Renew application secret
   */
  async renewClientSecretRaw(
    requestParameters: RenewClientSecretRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ClientSecret>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling renewClientSecret.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling renewClientSecret.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling renewClientSecret.',
      );
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling renewClientSecret.',
      );
    }

    if (requestParameters.secret === null || requestParameters.secret === undefined) {
      throw new runtime.RequiredError(
        'secret',
        'Required parameter requestParameters.secret was null or undefined when calling renewClientSecret.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/secrets/{secret}/_renew`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application)))
          .replace(`{${'secret'}}`, encodeURIComponent(String(requestParameters.secret))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ClientSecretFromJSON(jsonValue));
  }

  /**
   * User must have APPLICATION_OPENID[UPDATE] permission on the specified application or APPLICATION_OPENID[UPDATE] permission on the specified domain or APPLICATION_OPENID[UPDATE] permission on the specified environment or APPLICATION_OPENID[UPDATE] permission on the specified organization
   * Renew application secret
   */
  async renewClientSecret(
    requestParameters: RenewClientSecretRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<ClientSecret> {
    const response = await this.renewClientSecretRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_I18N_DICTIONARY[UPDATE] permission on the specified domain or DOMAIN_I18N_DICTIONARY[UPDATE] permission on the specified environment or DOMAIN_I18N_DICTIONARY[UPDATE] permission on the specified organization.
   * Update all the entries for a i18n dictionary description
   */
  async replaceI18nDictionaryEntriesRaw(
    requestParameters: ReplaceI18nDictionaryEntriesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<I18nDictionary>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling replaceI18nDictionaryEntries.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling replaceI18nDictionaryEntries.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling replaceI18nDictionaryEntries.',
      );
    }

    if (requestParameters.dictionary === null || requestParameters.dictionary === undefined) {
      throw new runtime.RequiredError(
        'dictionary',
        'Required parameter requestParameters.dictionary was null or undefined when calling replaceI18nDictionaryEntries.',
      );
    }

    if (requestParameters.requestBody === null || requestParameters.requestBody === undefined) {
      throw new runtime.RequiredError(
        'requestBody',
        'Required parameter requestParameters.requestBody was null or undefined when calling replaceI18nDictionaryEntries.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/i18n/dictionaries/{dictionary}/entries`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'dictionary'}}`, encodeURIComponent(String(requestParameters.dictionary))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.requestBody,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => I18nDictionaryFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_I18N_DICTIONARY[UPDATE] permission on the specified domain or DOMAIN_I18N_DICTIONARY[UPDATE] permission on the specified environment or DOMAIN_I18N_DICTIONARY[UPDATE] permission on the specified organization.
   * Update all the entries for a i18n dictionary description
   */
  async replaceI18nDictionaryEntries(
    requestParameters: ReplaceI18nDictionaryEntriesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<I18nDictionary> {
    const response = await this.replaceI18nDictionaryEntriesRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Reset password
   */
  async resetPasswordRaw(
    requestParameters: ResetPasswordRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling resetPassword.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling resetPassword.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling resetPassword.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling resetPassword.',
      );
    }

    if (requestParameters.passwordValue === null || requestParameters.passwordValue === undefined) {
      throw new runtime.RequiredError(
        'passwordValue',
        'Required parameter requestParameters.passwordValue was null or undefined when calling resetPassword.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/resetPassword`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: PasswordValueToJSON(requestParameters.passwordValue),
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Reset password
   */
  async resetPassword(requestParameters: ResetPasswordRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.resetPasswordRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Revoke a user consent
   */
  async revokeRaw(
    requestParameters: RevokeRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling revoke.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling revoke.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling revoke.');
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError('user', 'Required parameter requestParameters.user was null or undefined when calling revoke.');
    }

    if (requestParameters.consent === null || requestParameters.consent === undefined) {
      throw new runtime.RequiredError('consent', 'Required parameter requestParameters.consent was null or undefined when calling revoke.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/consents/{consent}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user)))
          .replace(`{${'consent'}}`, encodeURIComponent(String(requestParameters.consent))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Revoke a user consent
   */
  async revoke(requestParameters: RevokeRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.revokeRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Revoke a user credential
   */
  async revoke1Raw(
    requestParameters: Revoke1Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling revoke1.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling revoke1.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling revoke1.');
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError('user', 'Required parameter requestParameters.user was null or undefined when calling revoke1.');
    }

    if (requestParameters.credential === null || requestParameters.credential === undefined) {
      throw new runtime.RequiredError(
        'credential',
        'Required parameter requestParameters.credential was null or undefined when calling revoke1.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/credentials/{credential}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user)))
          .replace(`{${'credential'}}`, encodeURIComponent(String(requestParameters.credential))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Revoke a user credential
   */
  async revoke1(requestParameters: Revoke1Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.revoke1Raw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Revoke role to a user
   */
  async revoke2Raw(
    requestParameters: Revoke2Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<User>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling revoke2.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling revoke2.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling revoke2.');
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError('user', 'Required parameter requestParameters.user was null or undefined when calling revoke2.');
    }

    if (requestParameters.role === null || requestParameters.role === undefined) {
      throw new runtime.RequiredError('role', 'Required parameter requestParameters.role was null or undefined when calling revoke2.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/roles/{role}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user)))
          .replace(`{${'role'}}`, encodeURIComponent(String(requestParameters.role))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Revoke role to a user
   */
  async revoke2(requestParameters: Revoke2Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<User> {
    const response = await this.revoke2Raw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_GROUP[UPDATE] permission on the specified domain or DOMAIN_GROUP[UPDATE] permission on the specified environment or DOMAIN_GROUP[UPDATE] permission on the specified organization
   * Revoke role to a group
   */
  async revokeRoleRaw(
    requestParameters: RevokeRoleRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Group>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling revokeRole.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling revokeRole.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling revokeRole.',
      );
    }

    if (requestParameters.group === null || requestParameters.group === undefined) {
      throw new runtime.RequiredError('group', 'Required parameter requestParameters.group was null or undefined when calling revokeRole.');
    }

    if (requestParameters.role === null || requestParameters.role === undefined) {
      throw new runtime.RequiredError('role', 'Required parameter requestParameters.role was null or undefined when calling revokeRole.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/groups/{group}/roles/{role}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'group'}}`, encodeURIComponent(String(requestParameters.group)))
          .replace(`{${'role'}}`, encodeURIComponent(String(requestParameters.role))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => GroupFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_GROUP[UPDATE] permission on the specified domain or DOMAIN_GROUP[UPDATE] permission on the specified environment or DOMAIN_GROUP[UPDATE] permission on the specified organization
   * Revoke role to a group
   */
  async revokeRole(requestParameters: RevokeRoleRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Group> {
    const response = await this.revokeRoleRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_CERTIFICATE[CREATE] permission on the specified domain or DOMAIN_CERTIFICATE[CREATE] permission on the specified environment or DOMAIN_CERTIFICATE[CREATE] permission on the specified organization
   * Generate a new System a certificate
   */
  async rotateCertificateRaw(
    requestParameters: RotateCertificateRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<CertificateEntity>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling rotateCertificate.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling rotateCertificate.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling rotateCertificate.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/certificates/rotate`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => CertificateEntityFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_CERTIFICATE[CREATE] permission on the specified domain or DOMAIN_CERTIFICATE[CREATE] permission on the specified environment or DOMAIN_CERTIFICATE[CREATE] permission on the specified organization
   * Generate a new System a certificate
   */
  async rotateCertificate(
    requestParameters: RotateCertificateRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<CertificateEntity> {
    const response = await this.rotateCertificateRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Send registration confirmation email
   */
  async sendRegistrationConfirmationRaw(
    requestParameters: SendRegistrationConfirmationRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling sendRegistrationConfirmation.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling sendRegistrationConfirmation.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling sendRegistrationConfirmation.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling sendRegistrationConfirmation.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/sendRegistrationConfirmation`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Send registration confirmation email
   */
  async sendRegistrationConfirmation(
    requestParameters: SendRegistrationConfirmationRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.sendRegistrationConfirmationRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_SETTINGS[UPDATE] permission on the specified domain or DOMAIN_SETTINGS[UPDATE] permission on the specified environment or DOMAIN_SETTINGS[UPDATE] permission on the specified organization
   * Set default policy
   */
  async setDefaultPolicyRaw(
    requestParameters: SetDefaultPolicyRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<PasswordPolicy>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling setDefaultPolicy.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling setDefaultPolicy.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling setDefaultPolicy.',
      );
    }

    if (requestParameters.policy === null || requestParameters.policy === undefined) {
      throw new runtime.RequiredError(
        'policy',
        'Required parameter requestParameters.policy was null or undefined when calling setDefaultPolicy.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/password-policies/{policy}/default`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'policy'}}`, encodeURIComponent(String(requestParameters.policy))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => PasswordPolicyFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_SETTINGS[UPDATE] permission on the specified domain or DOMAIN_SETTINGS[UPDATE] permission on the specified environment or DOMAIN_SETTINGS[UPDATE] permission on the specified organization
   * Set default policy
   */
  async setDefaultPolicy(
    requestParameters: SetDefaultPolicyRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<PasswordPolicy> {
    const response = await this.setDefaultPolicyRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Unlock a user
   */
  async unlockUserRaw(
    requestParameters: UnlockUserRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling unlockUser.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling unlockUser.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling unlockUser.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError('user', 'Required parameter requestParameters.user was null or undefined when calling unlockUser.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/unlock`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Unlock a user
   */
  async unlockUser(requestParameters: UnlockUserRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.unlockUserRaw(requestParameters, initOverrides);
  }

  /**
   * User must have APPLICATION_EMAIL_TEMPLATE[UPDATE] permission on the specified application or APPLICATION_EMAIL_TEMPLATE[UPDATE] permission on the specified domain or APPLICATION_EMAIL_TEMPLATE[UPDATE] permission on the specified environment or APPLICATION_EMAIL_TEMPLATE[UPDATE] permission on the specified organization
   * Update an email for an application
   */
  async update1Raw(
    requestParameters: Update1Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Email>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling update1.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling update1.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling update1.');
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling update1.',
      );
    }

    if (requestParameters.email === null || requestParameters.email === undefined) {
      throw new runtime.RequiredError('email', 'Required parameter requestParameters.email was null or undefined when calling update1.');
    }

    if (requestParameters.updateEmail === null || requestParameters.updateEmail === undefined) {
      throw new runtime.RequiredError(
        'updateEmail',
        'Required parameter requestParameters.updateEmail was null or undefined when calling update1.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/emails/{email}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application)))
          .replace(`{${'email'}}`, encodeURIComponent(String(requestParameters.email))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: UpdateEmailToJSON(requestParameters.updateEmail),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => EmailFromJSON(jsonValue));
  }

  /**
   * User must have APPLICATION_EMAIL_TEMPLATE[UPDATE] permission on the specified application or APPLICATION_EMAIL_TEMPLATE[UPDATE] permission on the specified domain or APPLICATION_EMAIL_TEMPLATE[UPDATE] permission on the specified environment or APPLICATION_EMAIL_TEMPLATE[UPDATE] permission on the specified organization
   * Update an email for an application
   */
  async update1(requestParameters: Update1Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Email> {
    const response = await this.update1Raw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have APPLICATION_FORM[UPDATE] permission on the specified application or APPLICATION_FORM[UPDATE] permission on the specified domain or APPLICATION_FORM[UPDATE] permission on the specified environment or APPLICATION_FORM[UPDATE] permission on the specified organization
   * Update a form for an application
   */
  async update2Raw(
    requestParameters: Update2Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Form>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling update2.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling update2.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling update2.');
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling update2.',
      );
    }

    if (requestParameters.form === null || requestParameters.form === undefined) {
      throw new runtime.RequiredError('form', 'Required parameter requestParameters.form was null or undefined when calling update2.');
    }

    if (requestParameters.updateForm === null || requestParameters.updateForm === undefined) {
      throw new runtime.RequiredError(
        'updateForm',
        'Required parameter requestParameters.updateForm was null or undefined when calling update2.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/forms/{form}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application)))
          .replace(`{${'form'}}`, encodeURIComponent(String(requestParameters.form))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: UpdateFormToJSON(requestParameters.updateForm),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => FormFromJSON(jsonValue));
  }

  /**
   * User must have APPLICATION_FORM[UPDATE] permission on the specified application or APPLICATION_FORM[UPDATE] permission on the specified domain or APPLICATION_FORM[UPDATE] permission on the specified environment or APPLICATION_FORM[UPDATE] permission on the specified organization
   * Update a form for an application
   */
  async update2(requestParameters: Update2Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Form> {
    const response = await this.update2Raw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_AUTHDEVICE_NOTIFIER[UPDATE] permission on the specified domain or DOMAIN_AUTHDEVICE_NOTIFIER[UPDATE] permission on the specified environment or DOMAIN_AUTHDEVICE_NOTIFIER[UPDATE] permission on the specified organization
   * Update an Authentication Device Notifier
   */
  async update3Raw(
    requestParameters: Update3Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<AuthenticationDeviceNotifier>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling update3.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling update3.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling update3.');
    }

    if (requestParameters.authDeviceNotifier === null || requestParameters.authDeviceNotifier === undefined) {
      throw new runtime.RequiredError(
        'authDeviceNotifier',
        'Required parameter requestParameters.authDeviceNotifier was null or undefined when calling update3.',
      );
    }

    if (
      requestParameters.updateAuthenticationDeviceNotifier === null ||
      requestParameters.updateAuthenticationDeviceNotifier === undefined
    ) {
      throw new runtime.RequiredError(
        'updateAuthenticationDeviceNotifier',
        'Required parameter requestParameters.updateAuthenticationDeviceNotifier was null or undefined when calling update3.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/auth-device-notifiers/{authDeviceNotifier}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'authDeviceNotifier'}}`, encodeURIComponent(String(requestParameters.authDeviceNotifier))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: UpdateAuthenticationDeviceNotifierToJSON(requestParameters.updateAuthenticationDeviceNotifier),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => AuthenticationDeviceNotifierFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_AUTHDEVICE_NOTIFIER[UPDATE] permission on the specified domain or DOMAIN_AUTHDEVICE_NOTIFIER[UPDATE] permission on the specified environment or DOMAIN_AUTHDEVICE_NOTIFIER[UPDATE] permission on the specified organization
   * Update an Authentication Device Notifier
   */
  async update3(
    requestParameters: Update3Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<AuthenticationDeviceNotifier> {
    const response = await this.update3Raw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_EMAIL_TEMPLATE[UPDATE] permission on the specified domain or DOMAIN_EMAIL_TEMPLATE[UPDATE] permission on the specified environment or DOMAIN_EMAIL_TEMPLATE[UPDATE] permission on the specified organization
   * Update an email
   */
  async update4Raw(
    requestParameters: Update4Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Email>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling update4.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling update4.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling update4.');
    }

    if (requestParameters.email === null || requestParameters.email === undefined) {
      throw new runtime.RequiredError('email', 'Required parameter requestParameters.email was null or undefined when calling update4.');
    }

    if (requestParameters.updateEmail === null || requestParameters.updateEmail === undefined) {
      throw new runtime.RequiredError(
        'updateEmail',
        'Required parameter requestParameters.updateEmail was null or undefined when calling update4.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/emails/{email}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'email'}}`, encodeURIComponent(String(requestParameters.email))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: UpdateEmailToJSON(requestParameters.updateEmail),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => EmailFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_EMAIL_TEMPLATE[UPDATE] permission on the specified domain or DOMAIN_EMAIL_TEMPLATE[UPDATE] permission on the specified environment or DOMAIN_EMAIL_TEMPLATE[UPDATE] permission on the specified organization
   * Update an email
   */
  async update4(requestParameters: Update4Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Email> {
    const response = await this.update4Raw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_FORM[UPDATE] permission on the specified domain or DOMAIN_FORM[UPDATE] permission on the specified environment or DOMAIN_FORM[UPDATE] permission on the specified organization
   * Update a form
   */
  async update5Raw(
    requestParameters: Update5Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Form>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling update5.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling update5.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling update5.');
    }

    if (requestParameters.form === null || requestParameters.form === undefined) {
      throw new runtime.RequiredError('form', 'Required parameter requestParameters.form was null or undefined when calling update5.');
    }

    if (requestParameters.updateForm === null || requestParameters.updateForm === undefined) {
      throw new runtime.RequiredError(
        'updateForm',
        'Required parameter requestParameters.updateForm was null or undefined when calling update5.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/forms/{form}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'form'}}`, encodeURIComponent(String(requestParameters.form))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: UpdateFormToJSON(requestParameters.updateForm),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => FormFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_FORM[UPDATE] permission on the specified domain or DOMAIN_FORM[UPDATE] permission on the specified environment or DOMAIN_FORM[UPDATE] permission on the specified organization
   * Update a form
   */
  async update5(requestParameters: Update5Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Form> {
    const response = await this.update5Raw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_REPORTER[UPDATE] permission on the specified domain or DOMAIN_REPORTER[UPDATE] permission on the specified environment or DOMAIN_REPORTER[UPDATE] permission on the specified organization
   * Update a reporter
   */
  async update6Raw(
    requestParameters: Update6Request,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Reporter>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling update6.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling update6.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling update6.');
    }

    if (requestParameters.reporter === null || requestParameters.reporter === undefined) {
      throw new runtime.RequiredError(
        'reporter',
        'Required parameter requestParameters.reporter was null or undefined when calling update6.',
      );
    }

    if (requestParameters.updateReporter === null || requestParameters.updateReporter === undefined) {
      throw new runtime.RequiredError(
        'updateReporter',
        'Required parameter requestParameters.updateReporter was null or undefined when calling update6.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/reporters/{reporter}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'reporter'}}`, encodeURIComponent(String(requestParameters.reporter))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: UpdateReporterToJSON(requestParameters.updateReporter),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ReporterFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_REPORTER[UPDATE] permission on the specified domain or DOMAIN_REPORTER[UPDATE] permission on the specified environment or DOMAIN_REPORTER[UPDATE] permission on the specified organization
   * Update a reporter
   */
  async update6(requestParameters: Update6Request, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Reporter> {
    const response = await this.update6Raw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the APPLICATION_FLOW[UPDATE] permission on the specified domain or APPLICATION_FLOW[UPDATE] permission on the specified environment or APPLICATION_FLOW[UPDATE] permission on the specified organization
   * Update a flow
   */
  async updateAppFlowRaw(
    requestParameters: UpdateAppFlowRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<FlowEntity>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateAppFlow.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateAppFlow.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateAppFlow.',
      );
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling updateAppFlow.',
      );
    }

    if (requestParameters.flow === null || requestParameters.flow === undefined) {
      throw new runtime.RequiredError(
        'flow',
        'Required parameter requestParameters.flow was null or undefined when calling updateAppFlow.',
      );
    }

    if (requestParameters.flow2 === null || requestParameters.flow2 === undefined) {
      throw new runtime.RequiredError(
        'flow2',
        'Required parameter requestParameters.flow2 was null or undefined when calling updateAppFlow.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/flows/{flow}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application)))
          .replace(`{${'flow'}}`, encodeURIComponent(String(requestParameters.flow))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: FlowToJSON(requestParameters.flow2),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => FlowEntityFromJSON(jsonValue));
  }

  /**
   * User must have the APPLICATION_FLOW[UPDATE] permission on the specified domain or APPLICATION_FLOW[UPDATE] permission on the specified environment or APPLICATION_FLOW[UPDATE] permission on the specified organization
   * Update a flow
   */
  async updateAppFlow(
    requestParameters: UpdateAppFlowRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<FlowEntity> {
    const response = await this.updateAppFlowRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have APPLICATION[UPDATE] permission on the specified application or APPLICATION[UPDATE] permission on the specified domain or APPLICATION[UPDATE] permission on the specified environment or APPLICATION[UPDATE] permission on the specified organization
   * Update an application
   */
  async updateApplicationRaw(
    requestParameters: UpdateApplicationRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Application>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateApplication.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateApplication.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateApplication.',
      );
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling updateApplication.',
      );
    }

    if (requestParameters.patchApplication === null || requestParameters.patchApplication === undefined) {
      throw new runtime.RequiredError(
        'patchApplication',
        'Required parameter requestParameters.patchApplication was null or undefined when calling updateApplication.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: PatchApplicationToJSON(requestParameters.patchApplication),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ApplicationFromJSON(jsonValue));
  }

  /**
   * User must have APPLICATION[UPDATE] permission on the specified application or APPLICATION[UPDATE] permission on the specified domain or APPLICATION[UPDATE] permission on the specified environment or APPLICATION[UPDATE] permission on the specified organization
   * Update an application
   */
  async updateApplication(
    requestParameters: UpdateApplicationRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Application> {
    const response = await this.updateApplicationRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have APPLICATION[UPDATE] permission on the specified application or APPLICATION[UPDATE] permission on the specified domain or APPLICATION[UPDATE] permission on the specified environment or APPLICATION[UPDATE] permission on the specified organization
   * Update an application type
   */
  async updateApplicationTypeRaw(
    requestParameters: UpdateApplicationTypeRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Application>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateApplicationType.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateApplicationType.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateApplicationType.',
      );
    }

    if (requestParameters.application === null || requestParameters.application === undefined) {
      throw new runtime.RequiredError(
        'application',
        'Required parameter requestParameters.application was null or undefined when calling updateApplicationType.',
      );
    }

    if (requestParameters.patchApplicationType === null || requestParameters.patchApplicationType === undefined) {
      throw new runtime.RequiredError(
        'patchApplicationType',
        'Required parameter requestParameters.patchApplicationType was null or undefined when calling updateApplicationType.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/applications/{application}/type`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'application'}}`, encodeURIComponent(String(requestParameters.application))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: PatchApplicationTypeToJSON(requestParameters.patchApplicationType),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ApplicationFromJSON(jsonValue));
  }

  /**
   * User must have APPLICATION[UPDATE] permission on the specified application or APPLICATION[UPDATE] permission on the specified domain or APPLICATION[UPDATE] permission on the specified environment or APPLICATION[UPDATE] permission on the specified organization
   * Update an application type
   */
  async updateApplicationType(
    requestParameters: UpdateApplicationTypeRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Application> {
    const response = await this.updateApplicationTypeRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_AUTHORIZATION_ENGINE[UPDATE] permission on the specified domain or DOMAIN_AUTHORIZATION_ENGINE[UPDATE] permission on the specified environment or DOMAIN_AUTHORIZATION_ENGINE[UPDATE] permission on the specified organization
   * Update an authorization engine
   */
  async updateAuthorizationEngineRaw(
    requestParameters: UpdateAuthorizationEngineRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<AuthorizationEngine>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateAuthorizationEngine.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateAuthorizationEngine.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateAuthorizationEngine.',
      );
    }

    if (requestParameters.engineId === null || requestParameters.engineId === undefined) {
      throw new runtime.RequiredError(
        'engineId',
        'Required parameter requestParameters.engineId was null or undefined when calling updateAuthorizationEngine.',
      );
    }

    if (requestParameters.updateAuthorizationEngine === null || requestParameters.updateAuthorizationEngine === undefined) {
      throw new runtime.RequiredError(
        'updateAuthorizationEngine',
        'Required parameter requestParameters.updateAuthorizationEngine was null or undefined when calling updateAuthorizationEngine.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/authorization-engines/{engineId}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'engineId'}}`, encodeURIComponent(String(requestParameters.engineId))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: UpdateAuthorizationEngineToJSON(requestParameters.updateAuthorizationEngine),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => AuthorizationEngineFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_AUTHORIZATION_ENGINE[UPDATE] permission on the specified domain or DOMAIN_AUTHORIZATION_ENGINE[UPDATE] permission on the specified environment or DOMAIN_AUTHORIZATION_ENGINE[UPDATE] permission on the specified organization
   * Update an authorization engine
   */
  async updateAuthorizationEngine(
    requestParameters: UpdateAuthorizationEngineRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<AuthorizationEngine> {
    const response = await this.updateAuthorizationEngineRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_BOT_DETECTION[UPDATE] permission on the specified domain or DOMAIN_BOT_DETECTION[UPDATE] permission on the specified environment or DOMAIN_BOT_DETECTION[UPDATE] permission on the specified organization
   * Update a bot detection
   */
  async updateBotDetectionRaw(
    requestParameters: UpdateBotDetectionRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<BotDetection>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateBotDetection.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateBotDetection.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateBotDetection.',
      );
    }

    if (requestParameters.botDetection === null || requestParameters.botDetection === undefined) {
      throw new runtime.RequiredError(
        'botDetection',
        'Required parameter requestParameters.botDetection was null or undefined when calling updateBotDetection.',
      );
    }

    if (requestParameters.updateBotDetection === null || requestParameters.updateBotDetection === undefined) {
      throw new runtime.RequiredError(
        'updateBotDetection',
        'Required parameter requestParameters.updateBotDetection was null or undefined when calling updateBotDetection.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/bot-detections/{botDetection}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'botDetection'}}`, encodeURIComponent(String(requestParameters.botDetection))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: UpdateBotDetectionToJSON(requestParameters.updateBotDetection),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => BotDetectionFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_BOT_DETECTION[UPDATE] permission on the specified domain or DOMAIN_BOT_DETECTION[UPDATE] permission on the specified environment or DOMAIN_BOT_DETECTION[UPDATE] permission on the specified organization
   * Update a bot detection
   */
  async updateBotDetection(
    requestParameters: UpdateBotDetectionRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<BotDetection> {
    const response = await this.updateBotDetectionRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_CERTIFICATE[UPDATE] permission on the specified domain or DOMAIN_CERTIFICATE[UPDATE] permission on the specified environment or DOMAIN_CERTIFICATE[UPDATE] permission on the specified organization
   * Update a certificate
   */
  async updateCertificateRaw(
    requestParameters: UpdateCertificateRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ModifiedCertificateEntity>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateCertificate.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateCertificate.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateCertificate.',
      );
    }

    if (requestParameters.certificate === null || requestParameters.certificate === undefined) {
      throw new runtime.RequiredError(
        'certificate',
        'Required parameter requestParameters.certificate was null or undefined when calling updateCertificate.',
      );
    }

    if (requestParameters.updateCertificate === null || requestParameters.updateCertificate === undefined) {
      throw new runtime.RequiredError(
        'updateCertificate',
        'Required parameter requestParameters.updateCertificate was null or undefined when calling updateCertificate.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/certificates/{certificate}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'certificate'}}`, encodeURIComponent(String(requestParameters.certificate))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: UpdateCertificateToJSON(requestParameters.updateCertificate),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ModifiedCertificateEntityFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_CERTIFICATE[UPDATE] permission on the specified domain or DOMAIN_CERTIFICATE[UPDATE] permission on the specified environment or DOMAIN_CERTIFICATE[UPDATE] permission on the specified organization
   * Update a certificate
   */
  async updateCertificate(
    requestParameters: UpdateCertificateRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<ModifiedCertificateEntity> {
    const response = await this.updateCertificateRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_DEVICE_IDENTIFIER[UPDATE] permission on the specified domain or DOMAIN_DEVICE_IDENTIFIER[UPDATE] permission on the specified environment or DOMAIN_DEVICE_IDENTIFIER[UPDATE] permission on the specified organization
   * Update a Device identifier
   */
  async updateDeviceIdentifierRaw(
    requestParameters: UpdateDeviceIdentifierRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<DeviceIdentifier>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateDeviceIdentifier.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateDeviceIdentifier.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateDeviceIdentifier.',
      );
    }

    if (requestParameters.deviceIdentifier === null || requestParameters.deviceIdentifier === undefined) {
      throw new runtime.RequiredError(
        'deviceIdentifier',
        'Required parameter requestParameters.deviceIdentifier was null or undefined when calling updateDeviceIdentifier.',
      );
    }

    if (requestParameters.updateDeviceIdentifier === null || requestParameters.updateDeviceIdentifier === undefined) {
      throw new runtime.RequiredError(
        'updateDeviceIdentifier',
        'Required parameter requestParameters.updateDeviceIdentifier was null or undefined when calling updateDeviceIdentifier.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/device-identifiers/{deviceIdentifier}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'deviceIdentifier'}}`, encodeURIComponent(String(requestParameters.deviceIdentifier))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: UpdateDeviceIdentifierToJSON(requestParameters.updateDeviceIdentifier),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => DeviceIdentifierFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_DEVICE_IDENTIFIER[UPDATE] permission on the specified domain or DOMAIN_DEVICE_IDENTIFIER[UPDATE] permission on the specified environment or DOMAIN_DEVICE_IDENTIFIER[UPDATE] permission on the specified organization
   * Update a Device identifier
   */
  async updateDeviceIdentifier(
    requestParameters: UpdateDeviceIdentifierRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<DeviceIdentifier> {
    const response = await this.updateDeviceIdentifierRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_SETTINGS[UPDATE] permission on the specified domain or DOMAIN_SETTINGS[UPDATE] permission on the specified environment or DOMAIN_SETTINGS[UPDATE] permission on the specified organization.
   * Update the security domain
   */
  async updateDomainRaw(
    requestParameters: UpdateDomainRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Domain>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateDomain.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateDomain.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateDomain.',
      );
    }

    if (requestParameters.patchDomain === null || requestParameters.patchDomain === undefined) {
      throw new runtime.RequiredError(
        'patchDomain',
        'Required parameter requestParameters.patchDomain was null or undefined when calling updateDomain.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: PatchDomainToJSON(requestParameters.patchDomain),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => DomainFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_SETTINGS[UPDATE] permission on the specified domain or DOMAIN_SETTINGS[UPDATE] permission on the specified environment or DOMAIN_SETTINGS[UPDATE] permission on the specified organization.
   * Update the security domain
   */
  async updateDomain(requestParameters: UpdateDomainRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Domain> {
    const response = await this.updateDomainRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_FLOW[UPDATE] permission on the specified domain or DOMAIN_FLOW[UPDATE] permission on the specified environment or DOMAIN_FLOW[UPDATE] permission on the specified organization
   * Update a flow
   */
  async updateDomainFlowRaw(
    requestParameters: UpdateDomainFlowRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<FlowEntity>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateDomainFlow.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateDomainFlow.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateDomainFlow.',
      );
    }

    if (requestParameters.flow === null || requestParameters.flow === undefined) {
      throw new runtime.RequiredError(
        'flow',
        'Required parameter requestParameters.flow was null or undefined when calling updateDomainFlow.',
      );
    }

    if (requestParameters.flow2 === null || requestParameters.flow2 === undefined) {
      throw new runtime.RequiredError(
        'flow2',
        'Required parameter requestParameters.flow2 was null or undefined when calling updateDomainFlow.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/flows/{flow}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'flow'}}`, encodeURIComponent(String(requestParameters.flow))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: FlowToJSON(requestParameters.flow2),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => FlowEntityFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_FLOW[UPDATE] permission on the specified domain or DOMAIN_FLOW[UPDATE] permission on the specified environment or DOMAIN_FLOW[UPDATE] permission on the specified organization
   * Update a flow
   */
  async updateDomainFlow(
    requestParameters: UpdateDomainFlowRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<FlowEntity> {
    const response = await this.updateDomainFlowRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_EXTENSION_GRANT[UPDATE] permission on the specified domain or DOMAIN_EXTENSION_GRANT[UPDATE] permission on the specified environment or DOMAIN_EXTENSION_GRANT[UPDATE] permission on the specified organization
   * Update an extension grant
   */
  async updateExtensionGrantRaw(
    requestParameters: UpdateExtensionGrantRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ExtensionGrant>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateExtensionGrant.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateExtensionGrant.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateExtensionGrant.',
      );
    }

    if (requestParameters.extensionGrant === null || requestParameters.extensionGrant === undefined) {
      throw new runtime.RequiredError(
        'extensionGrant',
        'Required parameter requestParameters.extensionGrant was null or undefined when calling updateExtensionGrant.',
      );
    }

    if (requestParameters.updateExtensionGrant === null || requestParameters.updateExtensionGrant === undefined) {
      throw new runtime.RequiredError(
        'updateExtensionGrant',
        'Required parameter requestParameters.updateExtensionGrant was null or undefined when calling updateExtensionGrant.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/extensionGrants/{extensionGrant}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'extensionGrant'}}`, encodeURIComponent(String(requestParameters.extensionGrant))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: UpdateExtensionGrantToJSON(requestParameters.updateExtensionGrant),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ExtensionGrantFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_EXTENSION_GRANT[UPDATE] permission on the specified domain or DOMAIN_EXTENSION_GRANT[UPDATE] permission on the specified environment or DOMAIN_EXTENSION_GRANT[UPDATE] permission on the specified organization
   * Update an extension grant
   */
  async updateExtensionGrant(
    requestParameters: UpdateExtensionGrantRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<ExtensionGrant> {
    const response = await this.updateExtensionGrantRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_FACTOR[UPDATE] permission on the specified domain or DOMAIN_FACTOR[UPDATE] permission on the specified environment or DOMAIN_FACTOR[UPDATE] permission on the specified organization
   * Update a factor
   */
  async updateFactorRaw(
    requestParameters: UpdateFactorRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Factor>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateFactor.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateFactor.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateFactor.',
      );
    }

    if (requestParameters.factor === null || requestParameters.factor === undefined) {
      throw new runtime.RequiredError(
        'factor',
        'Required parameter requestParameters.factor was null or undefined when calling updateFactor.',
      );
    }

    if (requestParameters.updateFactor === null || requestParameters.updateFactor === undefined) {
      throw new runtime.RequiredError(
        'updateFactor',
        'Required parameter requestParameters.updateFactor was null or undefined when calling updateFactor.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/factors/{factor}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'factor'}}`, encodeURIComponent(String(requestParameters.factor))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: UpdateFactorToJSON(requestParameters.updateFactor),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => FactorFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_FACTOR[UPDATE] permission on the specified domain or DOMAIN_FACTOR[UPDATE] permission on the specified environment or DOMAIN_FACTOR[UPDATE] permission on the specified organization
   * Update a factor
   */
  async updateFactor(requestParameters: UpdateFactorRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Factor> {
    const response = await this.updateFactorRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_GROUP[UPDATE] permission on the specified domain or DOMAIN_GROUP[UPDATE] permission on the specified environment or DOMAIN_GROUP[UPDATE] permission on the specified organization
   * Update a group
   */
  async updateGroupRaw(
    requestParameters: UpdateGroupRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Group>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateGroup.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateGroup.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateGroup.',
      );
    }

    if (requestParameters.group === null || requestParameters.group === undefined) {
      throw new runtime.RequiredError(
        'group',
        'Required parameter requestParameters.group was null or undefined when calling updateGroup.',
      );
    }

    if (requestParameters.updateGroup === null || requestParameters.updateGroup === undefined) {
      throw new runtime.RequiredError(
        'updateGroup',
        'Required parameter requestParameters.updateGroup was null or undefined when calling updateGroup.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/groups/{group}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'group'}}`, encodeURIComponent(String(requestParameters.group))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: UpdateGroupToJSON(requestParameters.updateGroup),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => GroupFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_GROUP[UPDATE] permission on the specified domain or DOMAIN_GROUP[UPDATE] permission on the specified environment or DOMAIN_GROUP[UPDATE] permission on the specified organization
   * Update a group
   */
  async updateGroup(requestParameters: UpdateGroupRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Group> {
    const response = await this.updateGroupRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_IDENTITY_PROVIDER[UPDATE] permission on the specified domain or DOMAIN_IDENTITY_PROVIDER[UPDATE] permission on the specified environment or DOMAIN_IDENTITY_PROVIDER[UPDATE] permission on the specified organization
   * Update an identity provider
   */
  async updateIdentityProviderRaw(
    requestParameters: UpdateIdentityProviderRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<IdentityProvider>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateIdentityProvider.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateIdentityProvider.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateIdentityProvider.',
      );
    }

    if (requestParameters.identity === null || requestParameters.identity === undefined) {
      throw new runtime.RequiredError(
        'identity',
        'Required parameter requestParameters.identity was null or undefined when calling updateIdentityProvider.',
      );
    }

    if (requestParameters.updateIdentityProvider === null || requestParameters.updateIdentityProvider === undefined) {
      throw new runtime.RequiredError(
        'updateIdentityProvider',
        'Required parameter requestParameters.updateIdentityProvider was null or undefined when calling updateIdentityProvider.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/identities/{identity}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'identity'}}`, encodeURIComponent(String(requestParameters.identity))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: UpdateIdentityProviderToJSON(requestParameters.updateIdentityProvider),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => IdentityProviderFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_IDENTITY_PROVIDER[UPDATE] permission on the specified domain or DOMAIN_IDENTITY_PROVIDER[UPDATE] permission on the specified environment or DOMAIN_IDENTITY_PROVIDER[UPDATE] permission on the specified organization
   * Update an identity provider
   */
  async updateIdentityProvider(
    requestParameters: UpdateIdentityProviderRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<IdentityProvider> {
    const response = await this.updateIdentityProviderRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_SETTINGS[UPDATE] permission on the specified domain or DOMAIN_SETTINGS[UPDATE] permission on the specified environment or DOMAIN_SETTINGS[UPDATE] permission on the specified organization
   * Update a password policy
   */
  async updatePasswordPolicyRaw(
    requestParameters: UpdatePasswordPolicyRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<PasswordPolicy>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updatePasswordPolicy.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updatePasswordPolicy.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updatePasswordPolicy.',
      );
    }

    if (requestParameters.policy === null || requestParameters.policy === undefined) {
      throw new runtime.RequiredError(
        'policy',
        'Required parameter requestParameters.policy was null or undefined when calling updatePasswordPolicy.',
      );
    }

    if (requestParameters.updatePasswordPolicy === null || requestParameters.updatePasswordPolicy === undefined) {
      throw new runtime.RequiredError(
        'updatePasswordPolicy',
        'Required parameter requestParameters.updatePasswordPolicy was null or undefined when calling updatePasswordPolicy.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/password-policies/{policy}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'policy'}}`, encodeURIComponent(String(requestParameters.policy))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: UpdatePasswordPolicyToJSON(requestParameters.updatePasswordPolicy),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => PasswordPolicyFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_SETTINGS[UPDATE] permission on the specified domain or DOMAIN_SETTINGS[UPDATE] permission on the specified environment or DOMAIN_SETTINGS[UPDATE] permission on the specified organization
   * Update a password policy
   */
  async updatePasswordPolicy(
    requestParameters: UpdatePasswordPolicyRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<PasswordPolicy> {
    const response = await this.updatePasswordPolicyRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the PROTECTED_RESOURCE[UPDATE] permission on the specified resource or PROTECTED_RESOURCE[UPDATE] permission on the specified domain or PROTECTED_RESOURCE[UPDATE] permission on the specified environment or PROTECTED_RESOURCE[UPDATE] permission on the specified organization.
   * Update a Protected Resource
   */
  async updateProtectedResourceRaw(
    requestParameters: UpdateProtectedResourceRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ProtectedResource>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateProtectedResource.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateProtectedResource.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateProtectedResource.',
      );
    }

    if (requestParameters.protectedResource === null || requestParameters.protectedResource === undefined) {
      throw new runtime.RequiredError(
        'protectedResource',
        'Required parameter requestParameters.protectedResource was null or undefined when calling updateProtectedResource.',
      );
    }

    if (requestParameters.updateProtectedResource === null || requestParameters.updateProtectedResource === undefined) {
      throw new runtime.RequiredError(
        'updateProtectedResource',
        'Required parameter requestParameters.updateProtectedResource was null or undefined when calling updateProtectedResource.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/protected-resources/{protected-resource}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'protected-resource'}}`, encodeURIComponent(String(requestParameters.protectedResource))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: UpdateProtectedResourceToJSON(requestParameters.updateProtectedResource),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ProtectedResourceFromJSON(jsonValue));
  }

  /**
   * User must have the PROTECTED_RESOURCE[UPDATE] permission on the specified resource or PROTECTED_RESOURCE[UPDATE] permission on the specified domain or PROTECTED_RESOURCE[UPDATE] permission on the specified environment or PROTECTED_RESOURCE[UPDATE] permission on the specified organization.
   * Update a Protected Resource
   */
  async updateProtectedResource(
    requestParameters: UpdateProtectedResourceRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<ProtectedResource> {
    const response = await this.updateProtectedResourceRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_RESOURCE[UPDATE] permission on the specified domain or DOMAIN_RESOURCE[UPDATE] permission on the specified environment or DOMAIN_RESOURCE[UPDATE] permission on the specified organization
   * Update a resource
   */
  async updateResourceRaw(
    requestParameters: UpdateResourceRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ServiceResource>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateResource.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateResource.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateResource.',
      );
    }

    if (requestParameters.resource === null || requestParameters.resource === undefined) {
      throw new runtime.RequiredError(
        'resource',
        'Required parameter requestParameters.resource was null or undefined when calling updateResource.',
      );
    }

    if (requestParameters.updateServiceResource === null || requestParameters.updateServiceResource === undefined) {
      throw new runtime.RequiredError(
        'updateServiceResource',
        'Required parameter requestParameters.updateServiceResource was null or undefined when calling updateResource.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/resources/{resource}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'resource'}}`, encodeURIComponent(String(requestParameters.resource))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: UpdateServiceResourceToJSON(requestParameters.updateServiceResource),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ServiceResourceFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_RESOURCE[UPDATE] permission on the specified domain or DOMAIN_RESOURCE[UPDATE] permission on the specified environment or DOMAIN_RESOURCE[UPDATE] permission on the specified organization
   * Update a resource
   */
  async updateResource(
    requestParameters: UpdateResourceRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<ServiceResource> {
    const response = await this.updateResourceRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_ROLE[UPDATE] permission on the specified domain or DOMAIN_ROLE[UPDATE] permission on the specified environment or DOMAIN_ROLE[UPDATE] permission on the specified organization
   * Update a role
   */
  async updateRoleRaw(
    requestParameters: UpdateRoleRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<RoleEntity>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateRole.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateRole.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateRole.',
      );
    }

    if (requestParameters.role === null || requestParameters.role === undefined) {
      throw new runtime.RequiredError('role', 'Required parameter requestParameters.role was null or undefined when calling updateRole.');
    }

    if (requestParameters.updateRole === null || requestParameters.updateRole === undefined) {
      throw new runtime.RequiredError(
        'updateRole',
        'Required parameter requestParameters.updateRole was null or undefined when calling updateRole.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/roles/{role}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'role'}}`, encodeURIComponent(String(requestParameters.role))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: UpdateRoleToJSON(requestParameters.updateRole),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => RoleEntityFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_ROLE[UPDATE] permission on the specified domain or DOMAIN_ROLE[UPDATE] permission on the specified environment or DOMAIN_ROLE[UPDATE] permission on the specified organization
   * Update a role
   */
  async updateRole(requestParameters: UpdateRoleRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<RoleEntity> {
    const response = await this.updateRoleRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_SCOPE[UPDATE] permission on the specified domain or DOMAIN_SCOPE[UPDATE] permission on the specified environment or DOMAIN_SCOPE[UPDATE] permission on the specified organization
   * Update a scope
   */
  async updateScopeRaw(
    requestParameters: UpdateScopeRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Scope>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateScope.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateScope.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateScope.',
      );
    }

    if (requestParameters.scope === null || requestParameters.scope === undefined) {
      throw new runtime.RequiredError(
        'scope',
        'Required parameter requestParameters.scope was null or undefined when calling updateScope.',
      );
    }

    if (requestParameters.updateScope === null || requestParameters.updateScope === undefined) {
      throw new runtime.RequiredError(
        'updateScope',
        'Required parameter requestParameters.updateScope was null or undefined when calling updateScope.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/scopes/{scope}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'scope'}}`, encodeURIComponent(String(requestParameters.scope))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: UpdateScopeToJSON(requestParameters.updateScope),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ScopeFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_SCOPE[UPDATE] permission on the specified domain or DOMAIN_SCOPE[UPDATE] permission on the specified environment or DOMAIN_SCOPE[UPDATE] permission on the specified organization
   * Update a scope
   */
  async updateScope(requestParameters: UpdateScopeRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Scope> {
    const response = await this.updateScopeRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_THEME[UPDATE] permission on the specified domain or DOMAIN_THEME[UPDATE] permission on the specified environment or DOMAIN_THEME[UPDATE] permission on the specified organization
   * Update a theme on the specified security domain
   */
  async updateThemeRaw(
    requestParameters: UpdateThemeRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ThemeEntity>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateTheme.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateTheme.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateTheme.',
      );
    }

    if (requestParameters.themeId === null || requestParameters.themeId === undefined) {
      throw new runtime.RequiredError(
        'themeId',
        'Required parameter requestParameters.themeId was null or undefined when calling updateTheme.',
      );
    }

    if (requestParameters.themeEntity === null || requestParameters.themeEntity === undefined) {
      throw new runtime.RequiredError(
        'themeEntity',
        'Required parameter requestParameters.themeEntity was null or undefined when calling updateTheme.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/themes/{themeId}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'themeId'}}`, encodeURIComponent(String(requestParameters.themeId))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: ThemeEntityToJSON(requestParameters.themeEntity),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ThemeEntityFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_THEME[UPDATE] permission on the specified domain or DOMAIN_THEME[UPDATE] permission on the specified environment or DOMAIN_THEME[UPDATE] permission on the specified organization
   * Update a theme on the specified security domain
   */
  async updateTheme(
    requestParameters: UpdateThemeRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<ThemeEntity> {
    const response = await this.updateThemeRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Update a user
   */
  async updateUserRaw(
    requestParameters: UpdateUserRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<User>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateUser.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateUser.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateUser.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError('user', 'Required parameter requestParameters.user was null or undefined when calling updateUser.');
    }

    if (requestParameters.updateUser === null || requestParameters.updateUser === undefined) {
      throw new runtime.RequiredError(
        'updateUser',
        'Required parameter requestParameters.updateUser was null or undefined when calling updateUser.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: UpdateUserToJSON(requestParameters.updateUser),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Update a user
   */
  async updateUser(requestParameters: UpdateUserRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<User> {
    const response = await this.updateUserRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Update a user status
   */
  async updateUserStatusRaw(
    requestParameters: UpdateUserStatusRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<User>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateUserStatus.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateUserStatus.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateUserStatus.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling updateUserStatus.',
      );
    }

    if (requestParameters.statusEntity === null || requestParameters.statusEntity === undefined) {
      throw new runtime.RequiredError(
        'statusEntity',
        'Required parameter requestParameters.statusEntity was null or undefined when calling updateUserStatus.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/status`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: StatusEntityToJSON(requestParameters.statusEntity),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Update a user status
   */
  async updateUserStatus(
    requestParameters: UpdateUserStatusRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<User> {
    const response = await this.updateUserStatusRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Update a user username
   */
  async updateUsernameRaw(
    requestParameters: UpdateUsernameRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<User>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateUsername.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateUsername.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateUsername.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling updateUsername.',
      );
    }

    if (requestParameters.usernameEntity === null || requestParameters.usernameEntity === undefined) {
      throw new runtime.RequiredError(
        'usernameEntity',
        'Required parameter requestParameters.usernameEntity was null or undefined when calling updateUsername.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/username`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'PATCH',
        headers: headerParameters,
        query: queryParameters,
        body: UsernameEntityToJSON(requestParameters.usernameEntity),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Update a user username
   */
  async updateUsername(requestParameters: UpdateUsernameRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<User> {
    const response = await this.updateUsernameRaw(requestParameters, initOverrides);
    return await response.value();
  }
}

/**
 * @export
 */
export const Get11TemplateEnum = {
  Login: 'LOGIN',
  Registration: 'REGISTRATION',
  RegistrationConfirmation: 'REGISTRATION_CONFIRMATION',
  RegistrationVerify: 'REGISTRATION_VERIFY',
  ForgotPassword: 'FORGOT_PASSWORD',
  ResetPassword: 'RESET_PASSWORD',
  Oauth2UserConsent: 'OAUTH2_USER_CONSENT',
  MfaEnroll: 'MFA_ENROLL',
  MfaChallenge: 'MFA_CHALLENGE',
  MfaChallengeAlternatives: 'MFA_CHALLENGE_ALTERNATIVES',
  MfaRecoveryCode: 'MFA_RECOVERY_CODE',
  BlockedAccount: 'BLOCKED_ACCOUNT',
  CompleteProfile: 'COMPLETE_PROFILE',
  WebauthnRegister: 'WEBAUTHN_REGISTER',
  WebauthnRegisterSuccess: 'WEBAUTHN_REGISTER_SUCCESS',
  WebauthnLogin: 'WEBAUTHN_LOGIN',
  IdentifierFirstLogin: 'IDENTIFIER_FIRST_LOGIN',
  Error: 'ERROR',
  CertificateExpiration: 'CERTIFICATE_EXPIRATION',
  ClientSecretExpiration: 'CLIENT_SECRET_EXPIRATION',
  VerifyAttempt: 'VERIFY_ATTEMPT',
} as const;
export type Get11TemplateEnum = typeof Get11TemplateEnum[keyof typeof Get11TemplateEnum];
/**
 * @export
 */
export const Get12TemplateEnum = {
  Login: 'LOGIN',
  Registration: 'REGISTRATION',
  RegistrationConfirmation: 'REGISTRATION_CONFIRMATION',
  RegistrationVerify: 'REGISTRATION_VERIFY',
  ForgotPassword: 'FORGOT_PASSWORD',
  ResetPassword: 'RESET_PASSWORD',
  Oauth2UserConsent: 'OAUTH2_USER_CONSENT',
  MfaEnroll: 'MFA_ENROLL',
  MfaChallenge: 'MFA_CHALLENGE',
  MfaChallengeAlternatives: 'MFA_CHALLENGE_ALTERNATIVES',
  MfaRecoveryCode: 'MFA_RECOVERY_CODE',
  BlockedAccount: 'BLOCKED_ACCOUNT',
  CompleteProfile: 'COMPLETE_PROFILE',
  WebauthnRegister: 'WEBAUTHN_REGISTER',
  WebauthnRegisterSuccess: 'WEBAUTHN_REGISTER_SUCCESS',
  WebauthnLogin: 'WEBAUTHN_LOGIN',
  IdentifierFirstLogin: 'IDENTIFIER_FIRST_LOGIN',
  Error: 'ERROR',
  CertificateExpiration: 'CERTIFICATE_EXPIRATION',
  ClientSecretExpiration: 'CLIENT_SECRET_EXPIRATION',
  VerifyAttempt: 'VERIFY_ATTEMPT',
} as const;
export type Get12TemplateEnum = typeof Get12TemplateEnum[keyof typeof Get12TemplateEnum];
/**
 * @export
 */
export const Get5TemplateEnum = {
  Login: 'LOGIN',
  Registration: 'REGISTRATION',
  RegistrationConfirmation: 'REGISTRATION_CONFIRMATION',
  RegistrationVerify: 'REGISTRATION_VERIFY',
  ForgotPassword: 'FORGOT_PASSWORD',
  ResetPassword: 'RESET_PASSWORD',
  Oauth2UserConsent: 'OAUTH2_USER_CONSENT',
  MfaEnroll: 'MFA_ENROLL',
  MfaChallenge: 'MFA_CHALLENGE',
  MfaChallengeAlternatives: 'MFA_CHALLENGE_ALTERNATIVES',
  MfaRecoveryCode: 'MFA_RECOVERY_CODE',
  BlockedAccount: 'BLOCKED_ACCOUNT',
  CompleteProfile: 'COMPLETE_PROFILE',
  WebauthnRegister: 'WEBAUTHN_REGISTER',
  WebauthnRegisterSuccess: 'WEBAUTHN_REGISTER_SUCCESS',
  WebauthnLogin: 'WEBAUTHN_LOGIN',
  IdentifierFirstLogin: 'IDENTIFIER_FIRST_LOGIN',
  Error: 'ERROR',
  CertificateExpiration: 'CERTIFICATE_EXPIRATION',
  ClientSecretExpiration: 'CLIENT_SECRET_EXPIRATION',
  VerifyAttempt: 'VERIFY_ATTEMPT',
} as const;
export type Get5TemplateEnum = typeof Get5TemplateEnum[keyof typeof Get5TemplateEnum];
/**
 * @export
 */
export const Get6TemplateEnum = {
  Login: 'LOGIN',
  Registration: 'REGISTRATION',
  RegistrationConfirmation: 'REGISTRATION_CONFIRMATION',
  RegistrationVerify: 'REGISTRATION_VERIFY',
  ForgotPassword: 'FORGOT_PASSWORD',
  ResetPassword: 'RESET_PASSWORD',
  Oauth2UserConsent: 'OAUTH2_USER_CONSENT',
  MfaEnroll: 'MFA_ENROLL',
  MfaChallenge: 'MFA_CHALLENGE',
  MfaChallengeAlternatives: 'MFA_CHALLENGE_ALTERNATIVES',
  MfaRecoveryCode: 'MFA_RECOVERY_CODE',
  BlockedAccount: 'BLOCKED_ACCOUNT',
  CompleteProfile: 'COMPLETE_PROFILE',
  WebauthnRegister: 'WEBAUTHN_REGISTER',
  WebauthnRegisterSuccess: 'WEBAUTHN_REGISTER_SUCCESS',
  WebauthnLogin: 'WEBAUTHN_LOGIN',
  IdentifierFirstLogin: 'IDENTIFIER_FIRST_LOGIN',
  Error: 'ERROR',
  CertificateExpiration: 'CERTIFICATE_EXPIRATION',
  ClientSecretExpiration: 'CLIENT_SECRET_EXPIRATION',
  VerifyAttempt: 'VERIFY_ATTEMPT',
} as const;
export type Get6TemplateEnum = typeof Get6TemplateEnum[keyof typeof Get6TemplateEnum];
