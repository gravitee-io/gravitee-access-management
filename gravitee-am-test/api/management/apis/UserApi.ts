/*
 * Copyright (C) 2015 The Gravitee team (http://gravitee.io)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* Gravitee.io - Access Management API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/* tslint:disable */
/* eslint-disable */

import * as runtime from '../runtime';
import {
  AccountAccessToken,
  AccountAccessTokenFromJSON,
  AccountAccessTokenToJSON,
  Audit,
  AuditFromJSON,
  AuditToJSON,
  BulkResponse,
  BulkResponseFromJSON,
  BulkResponseToJSON,
  Credential,
  CredentialFromJSON,
  CredentialToJSON,
  DomainUserBulkRequest,
  DomainUserBulkRequestFromJSON,
  DomainUserBulkRequestToJSON,
  EmailValue,
  EmailValueFromJSON,
  EmailValueToJSON,
  EnrolledFactorEntity,
  EnrolledFactorEntityFromJSON,
  EnrolledFactorEntityToJSON,
  NewAccountAccessToken,
  NewAccountAccessTokenFromJSON,
  NewAccountAccessTokenToJSON,
  NewOrganizationUser,
  NewOrganizationUserFromJSON,
  NewOrganizationUserToJSON,
  NewUser,
  NewUserFromJSON,
  NewUserToJSON,
  OrganizationUserBulkRequest,
  OrganizationUserBulkRequestFromJSON,
  OrganizationUserBulkRequestToJSON,
  Page,
  PageFromJSON,
  PageToJSON,
  PasswordValue,
  PasswordValueFromJSON,
  PasswordValueToJSON,
  Role,
  RoleFromJSON,
  RoleToJSON,
  ScopeApprovalEntity,
  ScopeApprovalEntityFromJSON,
  ScopeApprovalEntityToJSON,
  StatusEntity,
  StatusEntityFromJSON,
  StatusEntityToJSON,
  UpdateUser,
  UpdateUserFromJSON,
  UpdateUserToJSON,
  User,
  UserFromJSON,
  UserToJSON,
  UserEntity,
  UserEntityFromJSON,
  UserEntityToJSON,
  UserIdentityEntity,
  UserIdentityEntityFromJSON,
  UserIdentityEntityToJSON,
  UserNotificationContent,
  UserNotificationContentFromJSON,
  UserNotificationContentToJSON,
  UserPage,
  UserPageFromJSON,
  UserPageToJSON,
  UsernameEntity,
  UsernameEntityFromJSON,
  UsernameEntityToJSON,
} from '../models';

export interface AssignRolesToUserRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  requestBody: Array<string>;
}

export interface BulkOrganisationUserOperationRequest {
  organizationId: string;
  organizationUserBulkRequest: OrganizationUserBulkRequest;
}

export interface BulkUserOperationRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  domainUserBulkRequest: DomainUserBulkRequest;
}

export interface CreateAccountAccessTokenRequest {
  organizationId: string;
  user: string;
  newAccountAccessToken?: NewAccountAccessToken;
}

export interface CreateOrganisationUserRequest {
  organizationId: string;
  newOrganizationUser: NewOrganizationUser;
}

export interface CreateUserRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  newUser: NewUser;
}

export interface DeleteOrganizationUserRequest {
  organizationId: string;
  user: string;
}

export interface DeleteUserRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
}

export interface DeleteUserDeviceRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  device: string;
}

export interface DeleteUserFactorRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  factor: string;
}

export interface FindUserRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
}

export interface GetOrganizationUserRequest {
  organizationId: string;
  user: string;
}

export interface GetOrganizationUserTokensRequest {
  organizationId: string;
  user: string;
}

export interface GetUserAuditLogRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  audit: string;
}

export interface GetUserConsentRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  consent: string;
}

export interface GetUserCredentialRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  credential: string;
}

export interface ListOrganisationUsersRequest {
  organizationId: string;
  q?: string;
  filter?: string;
  page?: number;
  size?: number;
}

export interface ListUserAuditLogsRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  type?: string;
  status?: string;
  from?: number;
  to?: number;
  size?: number;
  page?: number;
}

export interface ListUserConsentsRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  clientId?: string;
}

export interface ListUserCredentialsRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
}

export interface ListUserDevicesRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
}

export interface ListUserEnrolledFactorsRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
}

export interface ListUserIdentitiesRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
}

export interface ListUserRolesRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  dynamic?: boolean;
}

export interface ListUsersRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  q?: string;
  filter?: string;
  page?: number;
  size?: number;
}

export interface LockUserRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
}

export interface MarkNotificationAsReadRequest {
  notificationId: string;
}

export interface ResetOrganizationUserPasswordRequest {
  organizationId: string;
  user: string;
  passwordValue: PasswordValue;
}

export interface ResetPasswordRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  passwordValue: PasswordValue;
}

export interface RevokeAccountAccessTokenRequest {
  organizationId: string;
  user: string;
  tokenId: string;
}

export interface RevokeUserConsentRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  consent: string;
}

export interface RevokeUserConsentsRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  clientId?: string;
}

export interface RevokeUserCredentialRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  credential: string;
}

export interface RevokeUserRoleRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  role: string;
}

export interface SendRegistrationConfirmationRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
}

export interface SubscribeNewsletterRequest {
  emailValue: EmailValue;
}

export interface UnlinkUserIdentityRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  identity: string;
}

export interface UnlockUserRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
}

export interface UpdateOrganisationUsernameRequest {
  organizationId: string;
  user: string;
  usernameEntity: UsernameEntity;
}

export interface UpdateOrganizationUserRequest {
  organizationId: string;
  user: string;
  updateUser: UpdateUser;
}

export interface UpdateOrganizationUserStatusRequest {
  organizationId: string;
  user: string;
  statusEntity: StatusEntity;
}

export interface UpdateUserRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  updateUser: UpdateUser;
}

export interface UpdateUserStatusRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  statusEntity: StatusEntity;
}

export interface UpdateUsernameRequest {
  organizationId: string;
  environmentId: string;
  domain: string;
  user: string;
  usernameEntity: UsernameEntity;
}

/**
 *
 */
export class UserApi extends runtime.BaseAPI {
  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Assign roles to a user
   */
  async assignRolesToUserRaw(
    requestParameters: AssignRolesToUserRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<User>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling assignRolesToUser.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling assignRolesToUser.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling assignRolesToUser.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling assignRolesToUser.',
      );
    }

    if (requestParameters.requestBody === null || requestParameters.requestBody === undefined) {
      throw new runtime.RequiredError(
        'requestBody',
        'Required parameter requestParameters.requestBody was null or undefined when calling assignRolesToUser.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/roles`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.requestBody,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Assign roles to a user
   */
  async assignRolesToUser(
    requestParameters: AssignRolesToUserRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<User> {
    const response = await this.assignRolesToUserRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the ORGANIZATION_USER[CREATE/UPDATE/DELETE] permission on the specified organization
   * Create/update/delete platform users or Service Accounts
   */
  async bulkOrganisationUserOperationRaw(
    requestParameters: BulkOrganisationUserOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<BulkResponse>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling bulkOrganisationUserOperation.',
      );
    }

    if (requestParameters.organizationUserBulkRequest === null || requestParameters.organizationUserBulkRequest === undefined) {
      throw new runtime.RequiredError(
        'organizationUserBulkRequest',
        'Required parameter requestParameters.organizationUserBulkRequest was null or undefined when calling bulkOrganisationUserOperation.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/users/bulk`.replace(
          `{${'organizationId'}}`,
          encodeURIComponent(String(requestParameters.organizationId)),
        ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: OrganizationUserBulkRequestToJSON(requestParameters.organizationUserBulkRequest),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => BulkResponseFromJSON(jsonValue));
  }

  /**
   * User must have the ORGANIZATION_USER[CREATE/UPDATE/DELETE] permission on the specified organization
   * Create/update/delete platform users or Service Accounts
   */
  async bulkOrganisationUserOperation(
    requestParameters: BulkOrganisationUserOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<BulkResponse> {
    const response = await this.bulkOrganisationUserOperationRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[CREATE/UPDATE/DELETE] permission on the specified domain, the environment, or the organization
   * Create/update/delete multiple users on the specified security domain
   */
  async bulkUserOperationRaw(
    requestParameters: BulkUserOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<BulkResponse>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling bulkUserOperation.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling bulkUserOperation.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling bulkUserOperation.',
      );
    }

    if (requestParameters.domainUserBulkRequest === null || requestParameters.domainUserBulkRequest === undefined) {
      throw new runtime.RequiredError(
        'domainUserBulkRequest',
        'Required parameter requestParameters.domainUserBulkRequest was null or undefined when calling bulkUserOperation.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/bulk`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: DomainUserBulkRequestToJSON(requestParameters.domainUserBulkRequest),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => BulkResponseFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_USER[CREATE/UPDATE/DELETE] permission on the specified domain, the environment, or the organization
   * Create/update/delete multiple users on the specified security domain
   */
  async bulkUserOperation(
    requestParameters: BulkUserOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<BulkResponse> {
    const response = await this.bulkUserOperationRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the ORGANIZATION_USER[UPDATE] permission on the specified organization
   * Generate an account access token for a user
   */
  async createAccountAccessTokenRaw(
    requestParameters: CreateAccountAccessTokenRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<AccountAccessToken>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createAccountAccessToken.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling createAccountAccessToken.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/users/{user}/tokens`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewAccountAccessTokenToJSON(requestParameters.newAccountAccessToken),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => AccountAccessTokenFromJSON(jsonValue));
  }

  /**
   * User must have the ORGANIZATION_USER[UPDATE] permission on the specified organization
   * Generate an account access token for a user
   */
  async createAccountAccessToken(
    requestParameters: CreateAccountAccessTokenRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<AccountAccessToken> {
    const response = await this.createAccountAccessTokenRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the ORGANIZATION_USER[READ] permission on the specified organization
   * Create a platform user or Service Account
   */
  async createOrganisationUserRaw(
    requestParameters: CreateOrganisationUserRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<User>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createOrganisationUser.',
      );
    }

    if (requestParameters.newOrganizationUser === null || requestParameters.newOrganizationUser === undefined) {
      throw new runtime.RequiredError(
        'newOrganizationUser',
        'Required parameter requestParameters.newOrganizationUser was null or undefined when calling createOrganisationUser.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/users`.replace(
          `{${'organizationId'}}`,
          encodeURIComponent(String(requestParameters.organizationId)),
        ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewOrganizationUserToJSON(requestParameters.newOrganizationUser),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
  }

  /**
   * User must have the ORGANIZATION_USER[READ] permission on the specified organization
   * Create a platform user or Service Account
   */
  async createOrganisationUser(
    requestParameters: CreateOrganisationUserRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<User> {
    const response = await this.createOrganisationUserRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[CREATE] permission on the specified domain or DOMAIN_USER[CREATE] permission on the specified environment or DOMAIN_USER[CREATE] permission on the specified organization
   * Create a user on the specified security domain
   */
  async createUserRaw(
    requestParameters: CreateUserRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<User>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling createUser.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling createUser.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling createUser.',
      );
    }

    if (requestParameters.newUser === null || requestParameters.newUser === undefined) {
      throw new runtime.RequiredError(
        'newUser',
        'Required parameter requestParameters.newUser was null or undefined when calling createUser.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: NewUserToJSON(requestParameters.newUser),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_USER[CREATE] permission on the specified domain or DOMAIN_USER[CREATE] permission on the specified environment or DOMAIN_USER[CREATE] permission on the specified organization
   * Create a user on the specified security domain
   */
  async createUser(requestParameters: CreateUserRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<User> {
    const response = await this.createUserRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the ORGANIZATION_USER[DELETE] permission on the specified organization
   * Delete a user
   */
  async deleteOrganizationUserRaw(
    requestParameters: DeleteOrganizationUserRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteOrganizationUser.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling deleteOrganizationUser.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/users/{user}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the ORGANIZATION_USER[DELETE] permission on the specified organization
   * Delete a user
   */
  async deleteOrganizationUser(
    requestParameters: DeleteOrganizationUserRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.deleteOrganizationUserRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_USER[DELETE] permission on the specified domain or DOMAIN_USER[DELETE] permission on the specified environment or DOMAIN_USER[DELETE] permission on the specified organization
   * Delete a user
   */
  async deleteUserRaw(
    requestParameters: DeleteUserRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteUser.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteUser.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteUser.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError('user', 'Required parameter requestParameters.user was null or undefined when calling deleteUser.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_USER[DELETE] permission on the specified domain or DOMAIN_USER[DELETE] permission on the specified environment or DOMAIN_USER[DELETE] permission on the specified organization
   * Delete a user
   */
  async deleteUser(requestParameters: DeleteUserRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.deleteUserRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_USER_DEVICE[DELETE] permission on the specified domain or DOMAIN_USER_DEVICE[DELETE] permission on the specified environment or DOMAIN_USER_DEVICE[DELETE] permission on the specified organization
   * Delete a device
   */
  async deleteUserDeviceRaw(
    requestParameters: DeleteUserDeviceRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteUserDevice.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteUserDevice.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteUserDevice.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling deleteUserDevice.',
      );
    }

    if (requestParameters.device === null || requestParameters.device === undefined) {
      throw new runtime.RequiredError(
        'device',
        'Required parameter requestParameters.device was null or undefined when calling deleteUserDevice.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/devices/{device}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user)))
          .replace(`{${'device'}}`, encodeURIComponent(String(requestParameters.device))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_USER_DEVICE[DELETE] permission on the specified domain or DOMAIN_USER_DEVICE[DELETE] permission on the specified environment or DOMAIN_USER_DEVICE[DELETE] permission on the specified organization
   * Delete a device
   */
  async deleteUserDevice(
    requestParameters: DeleteUserDeviceRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.deleteUserDeviceRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Revoke user factor
   */
  async deleteUserFactorRaw(
    requestParameters: DeleteUserFactorRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling deleteUserFactor.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling deleteUserFactor.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling deleteUserFactor.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling deleteUserFactor.',
      );
    }

    if (requestParameters.factor === null || requestParameters.factor === undefined) {
      throw new runtime.RequiredError(
        'factor',
        'Required parameter requestParameters.factor was null or undefined when calling deleteUserFactor.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/factors/{factor}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user)))
          .replace(`{${'factor'}}`, encodeURIComponent(String(requestParameters.factor))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Revoke user factor
   */
  async deleteUserFactor(
    requestParameters: DeleteUserFactorRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.deleteUserFactorRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user
   */
  async findUserRaw(
    requestParameters: FindUserRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<UserEntity>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling findUser.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling findUser.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling findUser.');
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError('user', 'Required parameter requestParameters.user was null or undefined when calling findUser.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => UserEntityFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user
   */
  async findUser(requestParameters: FindUserRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<UserEntity> {
    const response = await this.findUserRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Get the current user
   */
  async getCurrentUserRaw(
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<{ [key: string]: string }>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/user`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * Get the current user
   */
  async getCurrentUser(initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<{ [key: string]: string }> {
    const response = await this.getCurrentUserRaw(initOverrides);
    return await response.value();
  }

  /**
   * User must have the ORGANIZATION_USER[READ] permission on the specified organization
   * Get a user
   */
  async getOrganizationUserRaw(
    requestParameters: GetOrganizationUserRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<UserEntity>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getOrganizationUser.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling getOrganizationUser.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/users/{user}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => UserEntityFromJSON(jsonValue));
  }

  /**
   * User must have the ORGANIZATION_USER[READ] permission on the specified organization
   * Get a user
   */
  async getOrganizationUser(
    requestParameters: GetOrganizationUserRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<UserEntity> {
    const response = await this.getOrganizationUserRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the ORGANIZATION_USER[READ] permission on the specified organization
   * Get tokens of a user
   */
  async getOrganizationUserTokensRaw(
    requestParameters: GetOrganizationUserTokensRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<AccountAccessToken>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getOrganizationUserTokens.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling getOrganizationUserTokens.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/users/{user}/tokens`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => AccountAccessTokenFromJSON(jsonValue));
  }

  /**
   * User must have the ORGANIZATION_USER[READ] permission on the specified organization
   * Get tokens of a user
   */
  async getOrganizationUserTokens(
    requestParameters: GetOrganizationUserTokensRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<AccountAccessToken> {
    const response = await this.getOrganizationUserTokensRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Get taglines to display in the newsletter
   */
  async getTaglinesRaw(initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<string>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/user/newsletter/taglines`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.TextApiResponse(response) as any;
  }

  /**
   * Get taglines to display in the newsletter
   */
  async getTaglines(initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<string> {
    const response = await this.getTaglinesRaw(initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user audit log
   */
  async getUserAuditLogRaw(
    requestParameters: GetUserAuditLogRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Audit>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getUserAuditLog.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getUserAuditLog.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getUserAuditLog.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling getUserAuditLog.',
      );
    }

    if (requestParameters.audit === null || requestParameters.audit === undefined) {
      throw new runtime.RequiredError(
        'audit',
        'Required parameter requestParameters.audit was null or undefined when calling getUserAuditLog.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/audits/{audit}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user)))
          .replace(`{${'audit'}}`, encodeURIComponent(String(requestParameters.audit))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => AuditFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user audit log
   */
  async getUserAuditLog(
    requestParameters: GetUserAuditLogRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Audit> {
    const response = await this.getUserAuditLogRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user consent
   */
  async getUserConsentRaw(
    requestParameters: GetUserConsentRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ScopeApprovalEntity>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getUserConsent.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getUserConsent.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getUserConsent.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling getUserConsent.',
      );
    }

    if (requestParameters.consent === null || requestParameters.consent === undefined) {
      throw new runtime.RequiredError(
        'consent',
        'Required parameter requestParameters.consent was null or undefined when calling getUserConsent.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/consents/{consent}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user)))
          .replace(`{${'consent'}}`, encodeURIComponent(String(requestParameters.consent))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ScopeApprovalEntityFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user consent
   */
  async getUserConsent(
    requestParameters: GetUserConsentRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<ScopeApprovalEntity> {
    const response = await this.getUserConsentRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user credential
   */
  async getUserCredentialRaw(
    requestParameters: GetUserCredentialRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Credential>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling getUserCredential.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling getUserCredential.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling getUserCredential.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling getUserCredential.',
      );
    }

    if (requestParameters.credential === null || requestParameters.credential === undefined) {
      throw new runtime.RequiredError(
        'credential',
        'Required parameter requestParameters.credential was null or undefined when calling getUserCredential.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/credentials/{credential}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user)))
          .replace(`{${'credential'}}`, encodeURIComponent(String(requestParameters.credential))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => CredentialFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user credential
   */
  async getUserCredential(
    requestParameters: GetUserCredentialRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Credential> {
    const response = await this.getUserCredentialRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * List notifications received by the current user
   */
  async listNotificationsRaw(
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<UserNotificationContent>>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/user/notifications`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UserNotificationContentFromJSON));
  }

  /**
   * List notifications received by the current user
   */
  async listNotifications(initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Array<UserNotificationContent>> {
    const response = await this.listNotificationsRaw(initOverrides);
    return await response.value();
  }

  /**
   * User must have the ORGANIZATION_USER[LIST] permission on the specified organization. Each returned user is filtered and contains only basic information such as id and username and displayname. Last login and identity provider name will be also returned if current user has ORGANIZATION_USER[READ] permission on the organization.
   * List users of the organization
   */
  async listOrganisationUsersRaw(
    requestParameters: ListOrganisationUsersRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Page>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listOrganisationUsers.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.q !== undefined) {
      queryParameters['q'] = requestParameters.q;
    }

    if (requestParameters.filter !== undefined) {
      queryParameters['filter'] = requestParameters.filter;
    }

    if (requestParameters.page !== undefined) {
      queryParameters['page'] = requestParameters.page;
    }

    if (requestParameters.size !== undefined) {
      queryParameters['size'] = requestParameters.size;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/users`.replace(
          `{${'organizationId'}}`,
          encodeURIComponent(String(requestParameters.organizationId)),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => PageFromJSON(jsonValue));
  }

  /**
   * User must have the ORGANIZATION_USER[LIST] permission on the specified organization. Each returned user is filtered and contains only basic information such as id and username and displayname. Last login and identity provider name will be also returned if current user has ORGANIZATION_USER[READ] permission on the organization.
   * List users of the organization
   */
  async listOrganisationUsers(
    requestParameters: ListOrganisationUsersRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Page> {
    const response = await this.listOrganisationUsersRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user audit logs
   */
  async listUserAuditLogsRaw(
    requestParameters: ListUserAuditLogsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<Audit>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listUserAuditLogs.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listUserAuditLogs.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listUserAuditLogs.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling listUserAuditLogs.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.type !== undefined) {
      queryParameters['type'] = requestParameters.type;
    }

    if (requestParameters.status !== undefined) {
      queryParameters['status'] = requestParameters.status;
    }

    if (requestParameters.from !== undefined) {
      queryParameters['from'] = requestParameters.from;
    }

    if (requestParameters.to !== undefined) {
      queryParameters['to'] = requestParameters.to;
    }

    if (requestParameters.size !== undefined) {
      queryParameters['size'] = requestParameters.size;
    }

    if (requestParameters.page !== undefined) {
      queryParameters['page'] = requestParameters.page;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/audits`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AuditFromJSON));
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user audit logs
   */
  async listUserAuditLogs(
    requestParameters: ListUserAuditLogsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<Audit>> {
    const response = await this.listUserAuditLogsRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user consents
   */
  async listUserConsentsRaw(
    requestParameters: ListUserConsentsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<ScopeApprovalEntity>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listUserConsents.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listUserConsents.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listUserConsents.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling listUserConsents.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.clientId !== undefined) {
      queryParameters['clientId'] = requestParameters.clientId;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/consents`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => ScopeApprovalEntityFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user consents
   */
  async listUserConsents(
    requestParameters: ListUserConsentsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<ScopeApprovalEntity> {
    const response = await this.listUserConsentsRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user credentials
   */
  async listUserCredentialsRaw(
    requestParameters: ListUserCredentialsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Credential>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listUserCredentials.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listUserCredentials.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listUserCredentials.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling listUserCredentials.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/credentials`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => CredentialFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user credentials
   */
  async listUserCredentials(
    requestParameters: ListUserCredentialsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Credential> {
    const response = await this.listUserCredentialsRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER_DEVICES[LIST] permission on the specified domain or DOMAIN_USER_DEVICES[LIST] permission on the specified environment or DOMAIN_USER_DEVICES[LIST] permission on the specified organization.
   * List users for a security domain
   */
  async listUserDevicesRaw(
    requestParameters: ListUserDevicesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<User>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listUserDevices.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listUserDevices.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listUserDevices.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling listUserDevices.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/devices`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UserFromJSON));
  }

  /**
   * User must have the DOMAIN_USER_DEVICES[LIST] permission on the specified domain or DOMAIN_USER_DEVICES[LIST] permission on the specified environment or DOMAIN_USER_DEVICES[LIST] permission on the specified organization.
   * List users for a security domain
   */
  async listUserDevices(
    requestParameters: ListUserDevicesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<User>> {
    const response = await this.listUserDevicesRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user enrolled factors
   */
  async listUserEnrolledFactorsRaw(
    requestParameters: ListUserEnrolledFactorsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<EnrolledFactorEntity>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listUserEnrolledFactors.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listUserEnrolledFactors.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listUserEnrolledFactors.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling listUserEnrolledFactors.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/factors`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(EnrolledFactorEntityFromJSON));
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user enrolled factors
   */
  async listUserEnrolledFactors(
    requestParameters: ListUserEnrolledFactorsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<EnrolledFactorEntity>> {
    const response = await this.listUserEnrolledFactorsRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user linked identities
   */
  async listUserIdentitiesRaw(
    requestParameters: ListUserIdentitiesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<UserIdentityEntity>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listUserIdentities.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listUserIdentities.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listUserIdentities.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling listUserIdentities.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/identities`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UserIdentityEntityFromJSON));
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user linked identities
   */
  async listUserIdentities(
    requestParameters: ListUserIdentitiesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<UserIdentityEntity>> {
    const response = await this.listUserIdentitiesRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user roles
   */
  async listUserRolesRaw(
    requestParameters: ListUserRolesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<Array<Role>>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listUserRoles.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listUserRoles.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listUserRoles.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling listUserRoles.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.dynamic !== undefined) {
      queryParameters['dynamic'] = requestParameters.dynamic;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/roles`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(RoleFromJSON));
  }

  /**
   * User must have the DOMAIN_USER[READ] permission on the specified domain or DOMAIN_USER[READ] permission on the specified environment or DOMAIN_USER[READ] permission on the specified organization
   * Get a user roles
   */
  async listUserRoles(
    requestParameters: ListUserRolesRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<Array<Role>> {
    const response = await this.listUserRolesRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[LIST] permission on the specified domain or DOMAIN_USER[LIST] permission on the specified environment or DOMAIN_USER[LIST] permission on the specified organization. Each returned user is filtered and contains only basic information such as id and username and displayname. Last login and identity provider name will be also returned if current user has DOMAIN_USER[READ] permission on the domain, environment or organization.
   * List users for a security domain
   */
  async listUsersRaw(
    requestParameters: ListUsersRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<UserPage>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling listUsers.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling listUsers.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling listUsers.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.q !== undefined) {
      queryParameters['q'] = requestParameters.q;
    }

    if (requestParameters.filter !== undefined) {
      queryParameters['filter'] = requestParameters.filter;
    }

    if (requestParameters.page !== undefined) {
      queryParameters['page'] = requestParameters.page;
    }

    if (requestParameters.size !== undefined) {
      queryParameters['size'] = requestParameters.size;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => UserPageFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_USER[LIST] permission on the specified domain or DOMAIN_USER[LIST] permission on the specified environment or DOMAIN_USER[LIST] permission on the specified organization. Each returned user is filtered and contains only basic information such as id and username and displayname. Last login and identity provider name will be also returned if current user has DOMAIN_USER[READ] permission on the domain, environment or organization.
   * List users for a security domain
   */
  async listUsers(requestParameters: ListUsersRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<UserPage> {
    const response = await this.listUsersRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Lock a user
   */
  async lockUserRaw(
    requestParameters: LockUserRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling lockUser.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling lockUser.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError('domain', 'Required parameter requestParameters.domain was null or undefined when calling lockUser.');
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError('user', 'Required parameter requestParameters.user was null or undefined when calling lockUser.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/lock`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Lock a user
   */
  async lockUser(requestParameters: LockUserRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.lockUserRaw(requestParameters, initOverrides);
  }

  /**
   * Mark User notification as read
   */
  async markNotificationAsReadRaw(
    requestParameters: MarkNotificationAsReadRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.notificationId === null || requestParameters.notificationId === undefined) {
      throw new runtime.RequiredError(
        'notificationId',
        'Required parameter requestParameters.notificationId was null or undefined when calling markNotificationAsRead.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/user/notifications/{notificationId}/acknowledge`.replace(
          `{${'notificationId'}}`,
          encodeURIComponent(String(requestParameters.notificationId)),
        ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Mark User notification as read
   */
  async markNotificationAsRead(
    requestParameters: MarkNotificationAsReadRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.markNotificationAsReadRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the ORGANIZATION_USER[UPDATE] permission on the specified organization
   * Reset password
   */
  async resetOrganizationUserPasswordRaw(
    requestParameters: ResetOrganizationUserPasswordRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling resetOrganizationUserPassword.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling resetOrganizationUserPassword.',
      );
    }

    if (requestParameters.passwordValue === null || requestParameters.passwordValue === undefined) {
      throw new runtime.RequiredError(
        'passwordValue',
        'Required parameter requestParameters.passwordValue was null or undefined when calling resetOrganizationUserPassword.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/users/{user}/resetPassword`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: PasswordValueToJSON(requestParameters.passwordValue),
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the ORGANIZATION_USER[UPDATE] permission on the specified organization
   * Reset password
   */
  async resetOrganizationUserPassword(
    requestParameters: ResetOrganizationUserPasswordRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.resetOrganizationUserPasswordRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Reset password
   */
  async resetPasswordRaw(
    requestParameters: ResetPasswordRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling resetPassword.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling resetPassword.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling resetPassword.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling resetPassword.',
      );
    }

    if (requestParameters.passwordValue === null || requestParameters.passwordValue === undefined) {
      throw new runtime.RequiredError(
        'passwordValue',
        'Required parameter requestParameters.passwordValue was null or undefined when calling resetPassword.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/resetPassword`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: PasswordValueToJSON(requestParameters.passwordValue),
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Reset password
   */
  async resetPassword(requestParameters: ResetPasswordRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.resetPasswordRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the ORGANIZATION_USER[UPDATE] permission on the specified organization
   * Revoke an account access token
   */
  async revokeAccountAccessTokenRaw(
    requestParameters: RevokeAccountAccessTokenRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling revokeAccountAccessToken.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling revokeAccountAccessToken.',
      );
    }

    if (requestParameters.tokenId === null || requestParameters.tokenId === undefined) {
      throw new runtime.RequiredError(
        'tokenId',
        'Required parameter requestParameters.tokenId was null or undefined when calling revokeAccountAccessToken.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/users/{user}/tokens/{tokenId}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user)))
          .replace(`{${'tokenId'}}`, encodeURIComponent(String(requestParameters.tokenId))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the ORGANIZATION_USER[UPDATE] permission on the specified organization
   * Revoke an account access token
   */
  async revokeAccountAccessToken(
    requestParameters: RevokeAccountAccessTokenRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.revokeAccountAccessTokenRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Revoke a user consent
   */
  async revokeUserConsentRaw(
    requestParameters: RevokeUserConsentRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling revokeUserConsent.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling revokeUserConsent.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling revokeUserConsent.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling revokeUserConsent.',
      );
    }

    if (requestParameters.consent === null || requestParameters.consent === undefined) {
      throw new runtime.RequiredError(
        'consent',
        'Required parameter requestParameters.consent was null or undefined when calling revokeUserConsent.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/consents/{consent}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user)))
          .replace(`{${'consent'}}`, encodeURIComponent(String(requestParameters.consent))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Revoke a user consent
   */
  async revokeUserConsent(
    requestParameters: RevokeUserConsentRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.revokeUserConsentRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Revoke user consents
   */
  async revokeUserConsentsRaw(
    requestParameters: RevokeUserConsentsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling revokeUserConsents.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling revokeUserConsents.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling revokeUserConsents.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling revokeUserConsents.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.clientId !== undefined) {
      queryParameters['clientId'] = requestParameters.clientId;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/consents`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Revoke user consents
   */
  async revokeUserConsents(
    requestParameters: RevokeUserConsentsRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.revokeUserConsentsRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Revoke a user credential
   */
  async revokeUserCredentialRaw(
    requestParameters: RevokeUserCredentialRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling revokeUserCredential.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling revokeUserCredential.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling revokeUserCredential.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling revokeUserCredential.',
      );
    }

    if (requestParameters.credential === null || requestParameters.credential === undefined) {
      throw new runtime.RequiredError(
        'credential',
        'Required parameter requestParameters.credential was null or undefined when calling revokeUserCredential.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/credentials/{credential}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user)))
          .replace(`{${'credential'}}`, encodeURIComponent(String(requestParameters.credential))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Revoke a user credential
   */
  async revokeUserCredential(
    requestParameters: RevokeUserCredentialRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.revokeUserCredentialRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Revoke role to a user
   */
  async revokeUserRoleRaw(
    requestParameters: RevokeUserRoleRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<User>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling revokeUserRole.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling revokeUserRole.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling revokeUserRole.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling revokeUserRole.',
      );
    }

    if (requestParameters.role === null || requestParameters.role === undefined) {
      throw new runtime.RequiredError(
        'role',
        'Required parameter requestParameters.role was null or undefined when calling revokeUserRole.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/roles/{role}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user)))
          .replace(`{${'role'}}`, encodeURIComponent(String(requestParameters.role))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Revoke role to a user
   */
  async revokeUserRole(requestParameters: RevokeUserRoleRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<User> {
    const response = await this.revokeUserRoleRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Send registration confirmation email
   */
  async sendRegistrationConfirmationRaw(
    requestParameters: SendRegistrationConfirmationRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling sendRegistrationConfirmation.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling sendRegistrationConfirmation.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling sendRegistrationConfirmation.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling sendRegistrationConfirmation.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/sendRegistrationConfirmation`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Send registration confirmation email
   */
  async sendRegistrationConfirmation(
    requestParameters: SendRegistrationConfirmationRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.sendRegistrationConfirmationRaw(requestParameters, initOverrides);
  }

  /**
   * Subscribe to the newsletter the authenticated user
   */
  async subscribeNewsletterRaw(
    requestParameters: SubscribeNewsletterRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<UserEntity>> {
    if (requestParameters.emailValue === null || requestParameters.emailValue === undefined) {
      throw new runtime.RequiredError(
        'emailValue',
        'Required parameter requestParameters.emailValue was null or undefined when calling subscribeNewsletter.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/user/newsletter/_subscribe`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: EmailValueToJSON(requestParameters.emailValue),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => UserEntityFromJSON(jsonValue));
  }

  /**
   * Subscribe to the newsletter the authenticated user
   */
  async subscribeNewsletter(
    requestParameters: SubscribeNewsletterRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<UserEntity> {
    const response = await this.subscribeNewsletterRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Unlink user identity
   */
  async unlinkUserIdentityRaw(
    requestParameters: UnlinkUserIdentityRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling unlinkUserIdentity.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling unlinkUserIdentity.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling unlinkUserIdentity.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling unlinkUserIdentity.',
      );
    }

    if (requestParameters.identity === null || requestParameters.identity === undefined) {
      throw new runtime.RequiredError(
        'identity',
        'Required parameter requestParameters.identity was null or undefined when calling unlinkUserIdentity.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/identities/{identity}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user)))
          .replace(`{${'identity'}}`, encodeURIComponent(String(requestParameters.identity))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Unlink user identity
   */
  async unlinkUserIdentity(
    requestParameters: UnlinkUserIdentityRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<void> {
    await this.unlinkUserIdentityRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Unlock a user
   */
  async unlockUserRaw(
    requestParameters: UnlockUserRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling unlockUser.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling unlockUser.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling unlockUser.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError('user', 'Required parameter requestParameters.user was null or undefined when calling unlockUser.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/unlock`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Unlock a user
   */
  async unlockUser(requestParameters: UnlockUserRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<void> {
    await this.unlockUserRaw(requestParameters, initOverrides);
  }

  /**
   * User must have the ORGANIZATION_USER[UPDATE] permission on the specified organization
   * Update a user username
   */
  async updateOrganisationUsernameRaw(
    requestParameters: UpdateOrganisationUsernameRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<User>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateOrganisationUsername.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling updateOrganisationUsername.',
      );
    }

    if (requestParameters.usernameEntity === null || requestParameters.usernameEntity === undefined) {
      throw new runtime.RequiredError(
        'usernameEntity',
        'Required parameter requestParameters.usernameEntity was null or undefined when calling updateOrganisationUsername.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/users/{user}/username`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'PATCH',
        headers: headerParameters,
        query: queryParameters,
        body: UsernameEntityToJSON(requestParameters.usernameEntity),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
  }

  /**
   * User must have the ORGANIZATION_USER[UPDATE] permission on the specified organization
   * Update a user username
   */
  async updateOrganisationUsername(
    requestParameters: UpdateOrganisationUsernameRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<User> {
    const response = await this.updateOrganisationUsernameRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the ORGANIZATION_USER[UPDATE] permission on the specified organization
   * Update a user
   */
  async updateOrganizationUserRaw(
    requestParameters: UpdateOrganizationUserRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<User>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateOrganizationUser.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling updateOrganizationUser.',
      );
    }

    if (requestParameters.updateUser === null || requestParameters.updateUser === undefined) {
      throw new runtime.RequiredError(
        'updateUser',
        'Required parameter requestParameters.updateUser was null or undefined when calling updateOrganizationUser.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/users/{user}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: UpdateUserToJSON(requestParameters.updateUser),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
  }

  /**
   * User must have the ORGANIZATION_USER[UPDATE] permission on the specified organization
   * Update a user
   */
  async updateOrganizationUser(
    requestParameters: UpdateOrganizationUserRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<User> {
    const response = await this.updateOrganizationUserRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the ORGANIZATION_USER[UPDATE] permission on the specified organization
   * Update a user status
   */
  async updateOrganizationUserStatusRaw(
    requestParameters: UpdateOrganizationUserStatusRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<User>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateOrganizationUserStatus.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling updateOrganizationUserStatus.',
      );
    }

    if (requestParameters.statusEntity === null || requestParameters.statusEntity === undefined) {
      throw new runtime.RequiredError(
        'statusEntity',
        'Required parameter requestParameters.statusEntity was null or undefined when calling updateOrganizationUserStatus.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/users/{user}/status`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: StatusEntityToJSON(requestParameters.statusEntity),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
  }

  /**
   * User must have the ORGANIZATION_USER[UPDATE] permission on the specified organization
   * Update a user status
   */
  async updateOrganizationUserStatus(
    requestParameters: UpdateOrganizationUserStatusRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<User> {
    const response = await this.updateOrganizationUserStatusRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Update a user
   */
  async updateUserRaw(
    requestParameters: UpdateUserRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<User>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateUser.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateUser.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateUser.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError('user', 'Required parameter requestParameters.user was null or undefined when calling updateUser.');
    }

    if (requestParameters.updateUser === null || requestParameters.updateUser === undefined) {
      throw new runtime.RequiredError(
        'updateUser',
        'Required parameter requestParameters.updateUser was null or undefined when calling updateUser.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: UpdateUserToJSON(requestParameters.updateUser),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Update a user
   */
  async updateUser(requestParameters: UpdateUserRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<User> {
    const response = await this.updateUserRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Update a user status
   */
  async updateUserStatusRaw(
    requestParameters: UpdateUserStatusRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<User>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateUserStatus.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateUserStatus.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateUserStatus.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling updateUserStatus.',
      );
    }

    if (requestParameters.statusEntity === null || requestParameters.statusEntity === undefined) {
      throw new runtime.RequiredError(
        'statusEntity',
        'Required parameter requestParameters.statusEntity was null or undefined when calling updateUserStatus.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/status`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: StatusEntityToJSON(requestParameters.statusEntity),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Update a user status
   */
  async updateUserStatus(
    requestParameters: UpdateUserStatusRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<User> {
    const response = await this.updateUserStatusRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Update a user username
   */
  async updateUsernameRaw(
    requestParameters: UpdateUsernameRequest,
    initOverrides?: RequestInit | runtime.InitOverideFunction,
  ): Promise<runtime.ApiResponse<User>> {
    if (requestParameters.organizationId === null || requestParameters.organizationId === undefined) {
      throw new runtime.RequiredError(
        'organizationId',
        'Required parameter requestParameters.organizationId was null or undefined when calling updateUsername.',
      );
    }

    if (requestParameters.environmentId === null || requestParameters.environmentId === undefined) {
      throw new runtime.RequiredError(
        'environmentId',
        'Required parameter requestParameters.environmentId was null or undefined when calling updateUsername.',
      );
    }

    if (requestParameters.domain === null || requestParameters.domain === undefined) {
      throw new runtime.RequiredError(
        'domain',
        'Required parameter requestParameters.domain was null or undefined when calling updateUsername.',
      );
    }

    if (requestParameters.user === null || requestParameters.user === undefined) {
      throw new runtime.RequiredError(
        'user',
        'Required parameter requestParameters.user was null or undefined when calling updateUsername.',
      );
    }

    if (requestParameters.usernameEntity === null || requestParameters.usernameEntity === undefined) {
      throw new runtime.RequiredError(
        'usernameEntity',
        'Required parameter requestParameters.usernameEntity was null or undefined when calling updateUsername.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('gravitee-auth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/organizations/{organizationId}/environments/{environmentId}/domains/{domain}/users/{user}/username`
          .replace(`{${'organizationId'}}`, encodeURIComponent(String(requestParameters.organizationId)))
          .replace(`{${'environmentId'}}`, encodeURIComponent(String(requestParameters.environmentId)))
          .replace(`{${'domain'}}`, encodeURIComponent(String(requestParameters.domain)))
          .replace(`{${'user'}}`, encodeURIComponent(String(requestParameters.user))),
        method: 'PATCH',
        headers: headerParameters,
        query: queryParameters,
        body: UsernameEntityToJSON(requestParameters.usernameEntity),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
  }

  /**
   * User must have the DOMAIN_USER[UPDATE] permission on the specified domain or DOMAIN_USER[UPDATE] permission on the specified environment or DOMAIN_USER[UPDATE] permission on the specified organization
   * Update a user username
   */
  async updateUsername(requestParameters: UpdateUsernameRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<User> {
    const response = await this.updateUsernameRaw(requestParameters, initOverrides);
    return await response.value();
  }
}
