/*
 * Copyright (C) 2015 The Gravitee team (http://gravitee.io)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import fetch from 'cross-fetch';
import { afterAll, beforeAll, describe, expect, it, jest } from '@jest/globals';
import { requestAdminAccessToken } from '@management-commands/token-management-commands';
import {
  safeDeleteDomain,
  getDomain,
  startDomain,
  createDomain,
  listDomains,
} from '@management-commands/domain-management-commands';
import { uniqueName } from '@utils-commands/misc';
import type { Domain } from '@management-models/Domain';

global.fetch = fetch;

const SMALL_BATCH_SIZE = 5;
const LARGE_BATCH_SIZE = 55;
const WILDCARD_BATCH_SIZE = 8;
const DEFAULT_PAGE_SIZE = 50;
const RUN_PREFIX = `${Date.now()}`;
const SMALL_PREFIX = `${RUN_PREFIX}-small`;
const LARGE_PREFIX = `${RUN_PREFIX}-large`;
const WILDCARD_PREFIX = `${RUN_PREFIX}-shared`;
const SEEDED_DOMAIN_COUNT = SMALL_BATCH_SIZE + LARGE_BATCH_SIZE;

jest.setTimeout(200000);

let accessToken: string;
const createdDomainIds: string[] = [];
const smallBatch: Domain[] = [];
const largeBatch: Domain[] = [];
const wildcardBatch: Domain[] = [];

const recordDomainForCleanup = (domain?: Domain) => {
  if (domain?.id) {
    createdDomainIds.push(domain.id);
  }
};

const createAndStartDomain = async (name: string): Promise<Domain> => {
  const created = await createDomain(accessToken, name, `Generated by domains.jest.spec.ts (${name})`);
  recordDomainForCleanup(created);
  const started = await startDomain(created.id!, accessToken);
  return started;
};

type BatchOptions = {
  buildName?: (index: number) => string;
  onDomainCreated?: (domain: Domain, index: number) => void;
};

const seedBatch = async (count: number, store: Domain[], options: BatchOptions = {}) => {
  for (let i = 0; i < count; i++) {
    const name = options?.buildName?.(i);
    expect(name).toBeDefined();
    const startedDomain = await createAndStartDomain(name!);
    store.push(startedDomain);
    options?.onDomainCreated?.(startedDomain, i);
  }
};

beforeAll(async () => {
  accessToken = await requestAdminAccessToken();

  await seedBatch(SMALL_BATCH_SIZE, smallBatch, {
    buildName: (index) => `${SMALL_PREFIX}-${index}-${uniqueName('domain', true)}`,
  });

  await seedBatch(
    LARGE_BATCH_SIZE,
    largeBatch,
    {
      buildName: (index) =>
        index < WILDCARD_BATCH_SIZE
          ? `${WILDCARD_PREFIX}-${index}-${uniqueName('domain', true)}`
          : `${LARGE_PREFIX}-${index}-${uniqueName('domain', true)}`,
      onDomainCreated: (domain, index) => {
        if (index < WILDCARD_BATCH_SIZE) {
          wildcardBatch.push(domain);
        }
      },
    },
  );

  await createAndStartDomain(`${RUN_PREFIX}-unique123`);
});

afterAll(async () => {
  for (const domainId of createdDomainIds) {
    await safeDeleteDomain(domainId, accessToken);
  }
});

describe('domain lifecycle operations', () => {
  it('creates, starts, and retrieves a domain', async () => {
    const lifecycleName = `${RUN_PREFIX}-lifecycle-${uniqueName('domain', true)}`;
    const created = await createDomain(accessToken, lifecycleName, 'Lifecycle validation domain');
    recordDomainForCleanup(created);
    expect(created.enabled).toBeFalsy();

    const started = await startDomain(created.id!, accessToken);
    expect(started.enabled).toBeTruthy();

    const fetched = await getDomain(started.id!, accessToken);
    expect(fetched).toBeDefined();
    expect(fetched.id).toEqual(started.id);
    expect(fetched.enabled).toBeTruthy();
  });
});

describe('domain search and pagination', () => {
  it('returns a small page without a query', async () => {
    const pageResponse = await listDomains(accessToken, { size: SMALL_BATCH_SIZE });

    expect(pageResponse.data?.length).toBeLessThanOrEqual(SMALL_BATCH_SIZE);
    expect(pageResponse.totalCount).toBeGreaterThanOrEqual(SEEDED_DOMAIN_COUNT);
  });

  it('defaults to 50 results per page when many domains exist', async () => {
    const pageResponse = await listDomains(accessToken);

    expect(pageResponse.data?.length).toBe(DEFAULT_PAGE_SIZE);
    expect(pageResponse.totalCount).toBeGreaterThanOrEqual(SEEDED_DOMAIN_COUNT);
  });

  it('paginates results when requesting a custom page and size', async () => {
    const firstPageDomains = (await listDomains(accessToken, { page: 0, size: 10 })).data;
    const secondPageDomains = (await listDomains(accessToken, { page: 1, size: 10 })).data;

    expect(firstPageDomains.length).toBe(10);
    expect(secondPageDomains.length).toBe(10);

    const firstPageIds = new Set(firstPageDomains.map((domain) => domain.id));
    const overlap = secondPageDomains.filter((domain) => firstPageIds.has(domain.id));
    expect(overlap).toHaveLength(0);
  });

  it('finds a domain when searching by its HRID', async () => {
    const pageResponse = await listDomains(accessToken, { q: `${RUN_PREFIX}-unique123` });

    expect(pageResponse.data?.length).toBe(1);
    expect(pageResponse.data?.[0].hrid).toEqual(`${RUN_PREFIX}-unique123`);
  });

  it('supports wildcard searches across matching domains', async () => {
    const wildcardQuery = `${WILDCARD_PREFIX}*`;
    const pageResponse = await listDomains(accessToken, { q: wildcardQuery, size: 100 });
    const expectedIds = wildcardBatch.map((domain) => domain.id);

    expect(pageResponse.data).toHaveLength(expectedIds.length);
    pageResponse.data?.forEach((domain) => {
      expect(domain.name?.startsWith(WILDCARD_PREFIX)).toBe(true);
    });
    expect(pageResponse.data?.map((domain) => domain.id).sort()).toEqual([...expectedIds].sort());
  });
});
