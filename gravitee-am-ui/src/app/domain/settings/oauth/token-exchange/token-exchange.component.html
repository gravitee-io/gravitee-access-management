<!--

    Copyright (C) 2015 The Gravitee team (http://gravitee.io)

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

            http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->
<div class="gv-page-container">
  <h1>Token Exchange</h1>
  <div class="gv-page-content">
    <div fxLayout="column" fxFlex="70">
      <form (ngSubmit)="save()">
        <div class="gv-form-section" fxLayout="column">
          <mat-slide-toggle (change)="enableTokenExchange($event)" [checked]="isTokenExchangeEnabled()" [disabled]="!editMode">
            Enable Token Exchange
          </mat-slide-toggle>
          <mat-hint style="font-size: 75%">Enable RFC 8693 OAuth 2.0 Token Exchange</mat-hint>
        </div>

        <div *ngIf="isTokenExchangeEnabled()">
          <!-- Subject Token Types Section -->
          <div class="gv-form-section" fxLayout="column">
            <div class="gv-form-section-title">
              <h5>Subject Token Configuration</h5>
              <mat-divider></mat-divider>
            </div>

            <mat-form-field appearance="outline">
              <mat-label>Allowed Subject Token Types</mat-label>
              <mat-select
                multiple
                name="allowedSubjectTokenTypes"
                [(ngModel)]="domain.tokenExchangeSettings.allowedSubjectTokenTypes"
                (selectionChange)="modelChanged()"
                [disabled]="!editMode"
              >
                <mat-option *ngFor="let tokenType of SUBJECT_TOKEN_TYPES" [value]="tokenType.value">{{ tokenType.label }}</mat-option>
              </mat-select>
              <mat-hint>Token types that can be submitted as subject_token for exchange</mat-hint>
            </mat-form-field>
          </div>

          <!-- Requested Token Types Section -->
          <div class="gv-form-section" fxLayout="column">
            <div class="gv-form-section-title">
              <h5>Requested Token Configuration</h5>
              <mat-divider></mat-divider>
            </div>

            <mat-form-field appearance="outline">
              <mat-label>Allowed Requested Token Types</mat-label>
              <mat-select
                multiple
                name="allowedRequestedTokenTypes"
                [(ngModel)]="domain.tokenExchangeSettings.allowedRequestedTokenTypes"
                (selectionChange)="modelChanged()"
                [disabled]="!editMode"
              >
                <mat-option *ngFor="let tokenType of REQUESTED_TOKEN_TYPES" [value]="tokenType.value">{{ tokenType.label }}</mat-option>
              </mat-select>
              <mat-hint>Token types that can be requested via requested_token_type parameter</mat-hint>
            </mat-form-field>
          </div>

          <!-- Impersonation Settings Section -->
          <div class="gv-form-section" fxLayout="column">
            <div class="gv-form-section-title">
              <h5>Impersonation Settings</h5>
              <mat-divider></mat-divider>
            </div>

            <mat-slide-toggle
              name="allowImpersonation"
              [(ngModel)]="domain.tokenExchangeSettings.allowImpersonation"
              (change)="modelChanged()"
              [disabled]="!editMode"
            >
              Allow Impersonation
            </mat-slide-toggle>
            <mat-hint style="font-size: 75%; margin-bottom: 16px">
              Allow token exchange for impersonation scenarios (no actor_token)
            </mat-hint>
          </div>

          <!-- Delegation Settings Section -->
          <div class="gv-form-section" fxLayout="column">
            <div class="gv-form-section-title">
              <h5>Delegation Settings</h5>
              <mat-divider></mat-divider>
            </div>

            <mat-slide-toggle
              name="allowDelegation"
              [(ngModel)]="domain.tokenExchangeSettings.allowDelegation"
              (change)="modelChanged()"
              [disabled]="!editMode"
            >
              Allow Delegation
            </mat-slide-toggle>
            <mat-hint style="font-size: 75%; margin-bottom: 16px">
              Allow token exchange for delegation scenarios (with actor_token). The issued token will contain an "act" claim.
            </mat-hint>

            <div *ngIf="domain.tokenExchangeSettings.allowDelegation" style="margin-top: 16px">
              <mat-form-field appearance="outline">
                <mat-label>Allowed Actor Token Types</mat-label>
                <mat-select
                  multiple
                  name="allowedActorTokenTypes"
                  [(ngModel)]="domain.tokenExchangeSettings.allowedActorTokenTypes"
                  (selectionChange)="modelChanged()"
                  [disabled]="!editMode"
                >
                  <mat-option *ngFor="let tokenType of ACTOR_TOKEN_TYPES" [value]="tokenType.value">{{ tokenType.label }}</mat-option>
                </mat-select>
                <mat-hint>Token types that can be submitted as actor_token for delegation</mat-hint>
              </mat-form-field>

              <mat-form-field appearance="outline" style="margin-top: 16px">
                <mat-label>Maximum Delegation Depth</mat-label>
                <input
                  matInput
                  type="number"
                  name="maxDelegationDepth"
                  [(ngModel)]="domain.tokenExchangeSettings.maxDelegationDepth"
                  (ngModelChange)="modelChanged()"
                  [disabled]="!editMode"
                  [min]="minDelegationDepth"
                  [max]="maxDelegationDepthLimit"
                  required
                />
                <mat-hint>
                  Maximum depth of delegation chain (nested "act" claims). Must be between {{ minDelegationDepth }} and
                  {{ maxDelegationDepthLimit }}. Default is {{ defaultDelegationDepth }}.
                </mat-hint>
              </mat-form-field>
            </div>
          </div>

          <!-- Trusted Issuers Section -->
          <div class="gv-form-section" fxLayout="column">
            <div class="gv-form-section-title">
              <h5>Trusted Issuers</h5>
              <mat-divider></mat-divider>
            </div>
            <mat-hint style="font-size: 75%; margin-bottom: 16px">
              Configure external token issuers whose JWTs are accepted as subject or actor tokens during token exchange.
            </mat-hint>

            <div
              *ngFor="let issuer of domain.tokenExchangeSettings.trustedIssuers; let i = index"
              class="trusted-issuer-card"
              fxLayout="column"
            >
              <div fxLayout="row" fxLayoutAlign="space-between center">
                <h5 style="margin: 0">Issuer #{{ i + 1 }}</h5>
                <button mat-icon-button type="button" (click)="removeTrustedIssuer(i)" [disabled]="!editMode" matTooltip="Remove issuer">
                  <mat-icon>delete</mat-icon>
                </button>
              </div>

              <mat-form-field appearance="outline">
                <mat-label>Issuer URL</mat-label>
                <input
                  matInput
                  [name]="'issuerUrl_' + i"
                  [(ngModel)]="issuer.issuer"
                  (ngModelChange)="modelChanged()"
                  [disabled]="!editMode"
                  placeholder="https://external-idp.example.com"
                />
                <mat-hint>The expected "iss" claim value in the external JWT</mat-hint>
              </mat-form-field>

              <mat-form-field appearance="outline" style="margin-top: 16px">
                <mat-label>Key Resolution Method</mat-label>
                <mat-select
                  [name]="'keyResolutionMethod_' + i"
                  [(ngModel)]="issuer.keyResolutionMethod"
                  (selectionChange)="modelChanged()"
                  [disabled]="!editMode"
                >
                  <mat-option *ngFor="let method of KEY_RESOLUTION_METHODS" [value]="method.value">{{ method.label }}</mat-option>
                </mat-select>
                <mat-hint>How to obtain the public key for JWT signature verification</mat-hint>
              </mat-form-field>

              <mat-form-field *ngIf="issuer.keyResolutionMethod === 'JWKS_URL'" appearance="outline" style="margin-top: 16px">
                <mat-label>JWKS URL</mat-label>
                <input
                  matInput
                  [name]="'jwksUri_' + i"
                  [(ngModel)]="issuer.jwksUri"
                  (ngModelChange)="modelChanged()"
                  [disabled]="!editMode"
                  placeholder="https://external-idp.example.com/.well-known/jwks.json"
                />
                <mat-hint>URL of the JSON Web Key Set endpoint for the issuer</mat-hint>
              </mat-form-field>

              <mat-form-field *ngIf="issuer.keyResolutionMethod === 'PEM'" appearance="outline" style="margin-top: 16px">
                <mat-label>PEM Certificate</mat-label>
                <textarea
                  matInput
                  [name]="'certificate_' + i"
                  [(ngModel)]="issuer.certificate"
                  (ngModelChange)="modelChanged()"
                  [disabled]="!editMode"
                  rows="6"
                  placeholder="-----BEGIN CERTIFICATE-----&#10;...&#10;-----END CERTIFICATE-----"
                ></textarea>
                <mat-hint>PEM-encoded X.509 certificate containing the public key</mat-hint>
              </mat-form-field>

              <!-- Scope Mappings -->
              <div style="margin-top: 16px">
                <h5 style="margin: 0">Scope Mappings</h5>
                <mat-hint style="font-size: 75%; margin-bottom: 8px; display: block">
                  Map external scopes from this issuer to domain scopes. Unmapped scopes will be dropped.
                </mat-hint>

                <div
                  fxLayout="row"
                  fxLayoutAlign="start center"
                  fxLayoutGap="10px"
                  style="padding: 15px; border: 1px solid rgba(0, 0, 0, 0.12); border-radius: 4px"
                >
                  <mat-form-field appearance="outline" fxFlex>
                    <mat-label>External Scope</mat-label>
                    <input
                      matInput
                      [name]="'newExtScope_' + i"
                      [(ngModel)]="newScopeMapping[i].externalScope"
                      [disabled]="!editMode"
                      placeholder="External scope name"
                    />
                  </mat-form-field>
                  <span class="mapping-separator">&mdash;</span>
                  <mat-form-field appearance="outline" fxFlex>
                    <mat-label>Domain Scope</mat-label>
                    <mat-select [name]="'newDomScope_' + i" [(ngModel)]="newScopeMapping[i].domainScope" [disabled]="!editMode">
                      <mat-option *ngFor="let scope of domainScopes" [value]="scope.key">
                        <span>{{ scope.name }}</span> | <small>{{ scope.description }}</small>
                      </mat-option>
                    </mat-select>
                  </mat-form-field>
                  <button
                    mat-stroked-button
                    type="button"
                    (click)="addScopeMapping(i)"
                    [disabled]="!editMode || !newScopeMapping[i]?.externalScope || !newScopeMapping[i]?.domainScope"
                  >
                    <mat-icon svgIcon="gio:plus"></mat-icon>ADD
                  </button>
                </div>

                <div
                  *ngFor="let mapping of scopeMappingEntries[i]; let j = index"
                  fxLayout="row"
                  fxLayoutAlign="start center"
                  fxLayoutGap="8px"
                  style="margin-top: 8px"
                >
                  <span fxFlex>{{ mapping.externalScope }}</span>
                  <span class="mapping-separator">&mdash;</span>
                  <span fxFlex>{{ mapping.domainScope }}</span>
                  <button mat-icon-button type="button" (click)="removeScopeMapping(i, j)" [disabled]="!editMode">
                    <mat-icon>close</mat-icon>
                  </button>
                </div>
              </div>

              <!-- User Binding -->
              <div style="margin-top: 16px">
                <mat-slide-toggle
                  [name]="'userBindingEnabled_' + i"
                  [(ngModel)]="issuer.userBindingEnabled"
                  (change)="modelChanged()"
                  [disabled]="!editMode"
                >
                  Enable User Binding
                </mat-slide-toggle>
                <mat-hint style="font-size: 75%; margin-bottom: 8px; display: block">
                  When enabled, the minted token will carry the domain user's roles, groups, and profile data instead of a synthetic user.
                </mat-hint>

                <div *ngIf="issuer.userBindingEnabled" style="margin-top: 8px">
                  <h5 style="margin: 0">User Binding Mappings</h5>
                  <mat-hint style="font-size: 75%; margin-bottom: 8px; display: block">
                    Map user attributes to JWT claims for domain user lookup. Use claim names (e.g., "email") or EL expressions (e.g.,
                    "&#123;#token['email']&#125;").
                  </mat-hint>

                  <div
                    fxLayout="row"
                    fxLayoutAlign="start center"
                    fxLayoutGap="10px"
                    style="padding: 15px; border: 1px solid rgba(0, 0, 0, 0.12); border-radius: 4px"
                  >
                    <mat-form-field appearance="outline" fxFlex>
                      <mat-label>User Attribute</mat-label>
                      <input
                        matInput
                        [name]="'newUbAttr_' + i"
                        [(ngModel)]="newUserBindingMapping[i].userAttribute"
                        [disabled]="!editMode"
                        placeholder="User profile attribute"
                      />
                    </mat-form-field>
                    <span class="mapping-separator">&mdash;</span>
                    <mat-form-field appearance="outline" fxFlex>
                      <mat-label>Claim / Expression</mat-label>
                      <input
                        matInput
                        [name]="'newUbClaim_' + i"
                        [(ngModel)]="newUserBindingMapping[i].claimExpression"
                        [disabled]="!editMode"
                        placeholder="email or {#token['email']}"
                      />
                    </mat-form-field>
                    <button
                      mat-stroked-button
                      type="button"
                      (click)="addUserBindingMapping(i)"
                      [disabled]="!editMode || !newUserBindingMapping[i]?.userAttribute || !newUserBindingMapping[i]?.claimExpression"
                    >
                      <mat-icon svgIcon="gio:plus"></mat-icon>ADD
                    </button>
                  </div>

                  <div
                    *ngFor="let mapping of userBindingMappingEntries[i]; let k = index"
                    fxLayout="row"
                    fxLayoutAlign="start center"
                    fxLayoutGap="8px"
                    style="margin-top: 8px"
                  >
                    <span fxFlex>{{ mapping.userAttribute }}</span>
                    <span class="mapping-separator">&mdash;</span>
                    <span fxFlex>{{ mapping.claimExpression }}</span>
                    <button mat-icon-button type="button" (click)="removeUserBindingMapping(i, k)" [disabled]="!editMode">
                      <mat-icon>close</mat-icon>
                    </button>
                  </div>
                </div>
              </div>
            </div>

            <button
              mat-stroked-button
              type="button"
              (click)="addTrustedIssuer()"
              [disabled]="!editMode"
              style="align-self: flex-start; margin-top: 8px"
            >
              <mat-icon svgIcon="gio:plus"></mat-icon>ADD TRUSTED ISSUER
            </button>
          </div>

          <!-- Validation warnings -->
          <div *ngFor="let error of getValidationErrors()" class="gv-form-section validation-error">
            <mat-icon>warning</mat-icon>
            <span style="margin-left: 8px">{{ error }}</span>
          </div>
        </div>
        <div fxLayout="row" *ngIf="editMode">
          <button mat-raised-button color="primary" [disabled]="!formChanged || !isFormValid()" type="submit">SAVE</button>
        </div>
      </form>
    </div>
    <div class="gv-page-description" fxFlex>
      <h3>What is Token Exchange?</h3>
      <div class="gv-page-description-content">
        <p>
          OAuth 2.0 Token Exchange (<a href="https://datatracker.ietf.org/doc/html/rfc8693">RFC 8693</a>) is a protocol for requesting and
          obtaining security tokens from an authorization server.
        </p>
        <h4>Impersonation</h4>
        <p>
          In <strong>Impersonation</strong> scenarios, a token is exchanged for a new token. The exchanged token inherits the subject's
          identity and permissions.
        </p>
        <h4>Delegation</h4>
        <p>
          In <strong>Delegation</strong> scenarios, an actor acts on behalf of the subject. The request includes both a
          <code>subject_token</code> (who the action is performed for) and an <code>actor_token</code> (who is performing the action). The
          issued token contains an <code>act</code> claim identifying the actor.
        </p>
        <p>
          <strong>Key features:</strong>
        </p>
        <ul>
          <li>Exchange valid tokens for new access tokens or ID tokens</li>
          <li>Generated tokens include the client_id claim identifying the requesting client</li>
          <li>No refresh tokens are issued during token exchange</li>
          <li>When requesting an ID token, it is returned in the access_token field with token_type "N_A"</li>
        </ul>
        <h4>Trusted Issuers</h4>
        <p>
          Configure <strong>Trusted Issuers</strong> to accept JWTs from external identity providers as subject or actor tokens. Each issuer
          requires a key resolution method (JWKS URL or PEM certificate) for signature verification. Optional scope mappings allow
          translating external scopes to domain scopes.
        </p>
        <h4>User Binding</h4>
        <p>
          Enable <strong>User Binding</strong> on a trusted issuer to look up a domain user matching the external JWT claims. When a
          matching user is found, the minted token carries the domain user's roles, groups, and profile data. If no match is found, the
          exchange is rejected (fail-closed). Mappings define which user attribute to match against which JWT claim or EL expression.
        </p>
        <p>
          Clients must have the <code>Token Exchange</code> grant type enabled to use token exchange.
          <br />
          Token request must have the <code>urn:ietf:params:oauth:grant-type:token-exchange</code> as <code>grant_type</code> parameter.
        </p>
      </div>
    </div>
  </div>
</div>
